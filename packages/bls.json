{"name":"bls","keywords":["rtmp","framework","edge","cluster","push","pull"],"version":"1.1.1","description":"a rtmp server framework","main":"./bls.js","dependencies":{"node-amfutils":"0.0.1","nan":"2.5.1"},"repository":"https://github.com/yuliangc9/bls2","license":"MIT","scripts":{"install":"node-gyp rebuild"},"gypfile":true,"gitHead":"e5c146be930fa3935bc9a9de168bc1fefa16c27d","homepage":"https://github.com/yuliangc9/bls2#readme","versions":[{"number":"0.0.1","date":"2017-01-09T09:55:04.508Z"},{"number":"0.0.2","date":"2017-01-09T11:10:29.369Z"},{"number":"1.0.0","date":"2017-01-09T11:19:43.604Z"},{"number":"1.0.1","date":"2017-01-11T15:06:26.746Z"},{"number":"1.0.2","date":"2017-01-12T05:48:07.659Z"},{"number":"1.0.3","date":"2017-01-12T14:35:58.246Z"},{"number":"1.0.4","date":"2017-01-12T14:50:41.913Z"},{"number":"1.0.5","date":"2017-01-15T03:45:06.274Z"},{"number":"1.0.6","date":"2017-01-19T05:31:57.805Z"},{"number":"1.1.0","date":"2017-02-10T05:40:24.279Z"},{"number":"1.1.1","date":"2017-02-16T03:47:42.129Z"}],"readme":"# bls\nBLS is a rtmp server framework for Nodejs. This server is developed in libuv I/O framework which is used by Nodejs. So it's performace in case of a large number of clients push or pull stream data concurrently is very good. At the same time, you can add custom logics, such as auth/cluster, in this framework easily with js api. A variety of API are provided to manage RTMP stream, such as open and close a stream, get the quality of one stream.\n\n-------------\n\n##Requirement\n- support nodejs 6.9. nodejs 0.1x is no longer supported.\n- Linux 64 bit\n\n##Install\n```\nnpm install bls\n```\n\n##Features of RTMP\n\n- Not the full RTMP protocal is supported. But the basic function of live play has been realised.\n- BLS cache the last gop of a stream. So player can show video picture very quickly.\n- Only support H264/AAC.\n- One client can only publishs/plays one stream just now.\n\n##Example\n###SimpleServer\nA simple RTMP server. You can publish stream with ffmpeg, and play stream with flash/vlc/ffmpeg...\n```javascript\n//simple_server.js\n\nvar server = require(\"bls\");\n\nvar config = {\n    //log file path bls write its own log to\n    log_path : \"log/bls.log\",\n\n    //trace:0 debug:1 info:2 warn:3 err:4 critical:5 off:6\n    //if you use low level, bls will be more busy\n    log_level : 1,\n\n    //the maximum number of clients connect to server concurrently\n    max_client_num : 2000,\n\n    //port listen to\n    port : 8956,\n\n    //the interval seconds bls uses to send heartbeat msg to clients\n    ping_pong_time : 10,\n};\n\n//record the publishing stream's name\nvar publishing_stream = {};\n\n//start listen and serve as RTMP server\n//cb func is called when a client connects(tcp connect) to server\n//client argument presents a rtmp client\nserver.start_server(config, function(client){\n    console.log(\"client come on! id: %s\", client.client_id);\n\n    //the callback func when this client sends RTMP connect command\n    client.on(\"connect\", function(trans_id, connect_info)\n    {\n        console.log(\"new client connect. %s tsid: %d connect_info: %j\", \n            client.client_id, trans_id, connect_info);\n\n        client.accept(true);\n        //client.accept(false, \"NetConnection.Connect.Rejected\", \"reject\");\n        \n        //you can send any command to client\n        //if you need result from client, the callback function must be set\n        client.call(\"needResult\", [{}, {data:66}], function(res_cmd, res_args){\n            console.log(\"get result from client %s %s\", res_cmd, res_args);\n        });\n    });\n\n    //this client leave\n    client.on(\"close\", function(close_status)\n    {\n        console.log(\"%s client close \", client.client_id, close_status);\n\n        if (client.publish_stream_name) {\n            delete publishing_stream[client.publish_stream_name];\n        }\n    });\n\n    //register a cb func when this client wants to publish a stream.\n    //note: bls just allows one client publishs one stream now.\n    client.on(\"publish\", function(trans_id, cmd_objs, stream_name)\n    {\n        console.log(\"client call publish. tsid: %d cmd_objs: %j stream_name: %s\",\n            trans_id, cmd_objs, stream_name);\n\n        //if this stream name is publishing, you can not publish the same stream name\n        if (!publishing_stream[stream_name]) {\n            //if you allow this client to publish stream with stream_name, just need to call publish function\n            //trans_id must be same with trans_id in cb arguments\n            //you can custom the stream name which bls uses to publish\n            client.publish(trans_id, stream_name);\n\n            publishing_stream[stream_name] = true;\n            client.publish_stream_name = stream_name;\n        } else {\n            client.close();\n        }\n    });\n\n    //register a cb func when this client wants to play a stream\n    //note: bls just allows one client play one stream now.\n    client.on(\"play\", function(trans_id, cmd_obj, stream_name){\n        console.log(\"client call play. tsid: %d cmd_objs: %j stream_name: %s\",\n            trans_id, cmd_obj, stream_name);\n\n        if (publishing_stream[stream_name]) {\n            //trans_id must be same with the cb arguments\n            //you can choose a stream name for this client, not must be same with the client wants\n            //\n            //NOTE: you can also wait for publish src ready than call play method. In this example, \n            //we just close this player.\n            client.play(trans_id, stream_name);\n        } else {\n            client.close();\n        }\n    });\n\n    //when client publishs a stream, there will be a meta data in stream data\n    //meta data size should not be bigger than MAX_BUFFER_LEN, default is 2KB\n    client.on(\"onMetaData\", function(meta_data){\n        console.log(\"get metadata %j\", meta_data);\n    })\n\n    //when this client call stop play command\n    client.on(\"unplay\", function(){\n        console.log(\"client unplay stream......\");\n    });\n\n    //when this client call unplish, which means this client wants stop publish stream\n    client.on(\"unpublish\", function(){\n        console.log(\"client unpublish stream......\");\n    });\n\n    //bls sends heartbeat to client with seconds interval, which is indicated in config\n    //when client send back pong msg, which is required, this cb func will be called\n    //delay indicates the transport delay between bls and client\n    client.on(\"ping_pong_request\", function(delay, recv_sum){\n        console.log(\"get pong response! %d %d\", delay, recv_sum);\n    });\n\n    //listen to custom command from client, so client can send custom data to bls\n    client.on(\"customCmd\", function(trans_id, cmd_obj, data){\n        console.log(\"get user custom command. %s %s %s\", trans_id, cmd_obj, data);\n\n        var result = [\"result data\"];\n\n        //you can answer client with \"_result\" or \"_error\"\n        //trans_id must be same with the one in cb func arguments\n        client.result(\"_result\", trans_id, result);\n    });\n\n    client.enable_av_cb(function(av_type, timestamp, is_sh, is_key, data){\n        console.log(\"get a %s data. ts:%d, is sequence header:%s, is key frame:%s\", \n            av_type, timestamp, is_sh, is_key);\n    });\n    \n    setTimeout(function(){\n        client.disable_av_cb()\n    }, 5000);\n});\n```\n###Cluster\nA RTMP cluster with two hosts. The simple server upon runs as a source host. This edge server pull stream from source host.You can build more complex topo with BLS.\n```javascript\n//test_edge_server.js\n\nvar bls = require(\"bls\");\n\nvar config = {\n\tlog_path : \"log/bls_edge.log\",\n    log_level : 3,\n\tmax_client_num : 20,\n\tport : 8900,\n\tping_pong_time : 10,\n};\n\nvar edged_stream = {};\n\nvar result = bls.start_server(config, function(client){\n\tconsole.log(\"client come on! id: %s\", client.client_id);\n\n\tclient.on(\"connect\", function(trans_id, connect_info)\n\t{\n\t\tconsole.log(\"new client connect. tsid: %d connect_info: %j\", \n\t\t\ttrans_id, connect_info);\n\t\tclient.accept(true);\n\t\t//client.accept(false, \"NetConnection.Connect.Rejected\", \"hehe\");\n\t});\n\n\tclient.on(\"close\", function(close_status)\n\t{\n\t\tconsole.log(\"client close \", close_status);\n\t});\n\n\tclient.on(\"play\", function(trans_id, cmd_obj, stream_name){\n\t\tconsole.log(\"client call play. tsid: %d cmd_objs: %j stream_name: %s\",\n\t\t\ttrans_id, cmd_obj, stream_name);\n\n        //if the stream has beed pull from src host,\n        //then it can play directly.\n        if (edged_stream[stream_name]) {\n            console.log(\"play %s directly\", stream_name);\n\t\t    client.play(trans_id, stream_name);\n        } else {\n            console.log(\"need pull from src host\");\n            pull_stream_from_src(stream_name, function(res) {\n                if (res) {\n                    edged_stream[stream_name] = true;\n                    client.play(trans_id, stream_name);\n                } else {\n                    console.log(\"pull stream fail\");\n                    client.close();\n                    console.log(\"debug\");\n                }\n            });\n        }\n\t});\n\n\tclient.on(\"unplay\", function(){\n\t\tconsole.log(\"client unplay stream......\");\n\t});\n\n\t// setTimeout(function(){\n\t// \tclient.close();\n\t// }, 5000);\n});\n\nfunction pull_stream_from_src(stream_name, cb_func){\n    //connect remote src BLS first\n\tbls.remote_connect(\"127.0.0.1\", 8956, function(edge_connect){\n\n        //TCP connect success\n\t\tif(edge_connect)\n\t\t{\n\t\t\tconsole.log(\"connect remote server success.\")\n\n            var has_return = false;\n\n            //you can send custom infomations to source BLS when doing RTMP connect\n\t\t\tedge_connect.connect({info:\"custom info\"}, function(results){\n\t\t\t\tconsole.log(\"send connect to remote server. recv:\");\n\t\t\t\tconsole.dir(arguments);\n\n\t\t\t\tedge_connect.edge(stream_name, function(){\n                    //Note: If this edge client is closed when waiting for edge result, \n                    //this call back will never be triggled.\n                    console.log(\"edge complete\");\n\n                    //call back success\n                    cb_func(true);\n                    has_return = true;\n                });\n\t\t\t});\n\n            edge_connect.on(\"close\", function(){\n                console.log(\"edge for %s close\", stream_name);\n                \n                if (!has_return) {\n                    cb_func(false);\n                }\n            });\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconsole.log(\"connect remote server fail\");\n            cb_func(false);\n\t\t}\n\t});\n\n}\n```\n\n##Performance\nWe test BLS's performance with many ffmpegs client connecting to BLS at a time pushing and pulling streams.\nOne player plays one publisher, as a pair. With the number of pairs grows up, CPU idle is the main resource BLS takes. So we just forcus on usage of one CPU core. Result is shown below.\n\n>The rate of each stream is about 800Kb/s\n\n|  number of pair  |  CPU usage  |\n|------------------|-------------|\n| 300 | 10% |\n| 500 | 20% |\n| 1000 | 40% |\n| 2000 | 80% |\n| 3000 | 99% |\n\n##API\n\n###Function: start_server(config, cb(client))\n--------------------\n\nstart a rtmp server. If start and listen fail, this process will just exit.\n- **config**  `[object]` configuration for server, including log path / port and so on. \n- **cb** `[function]` callback function which is triggled when a new client come on TCP level. In this function, you can register many event callbacks for client, and control this client\n\t- **client** `[BlsClient]` callback argument. stand for a client, see detail about [BlsClient]()\n\nconfigure items:\n\n| Item      |    required | type | description |\n|-----------|-------------|------|-------------|\n| log_path |  yes | string | log file path for bls to record detail info  |\n| log_level | yes | number | trace:0 debug:1 info:2 warn:3 err:4 critical:5 off:6 |\n| max_client_num | yes | number | how many clients the server can hold at the same time |\n| port| yes | number | the port server listens to |\n| ping_pong_time | no | number | the interval seconds server sends ping package for detecting whether this client is alive or not. Default 10. |\n\n###Function:remote_connect(ip, port, cb(client))\n--------------------\n\nCreate a TCP connection to another bls server.\n- **ip** `[string]` remote bls server ip\n- **port** `[number]` remote bls server port\n- **cb** `[function]` callback function\n\t- **client** `[BlsClient]` callback argument. If connect fail client will be None, else it will be a BlsClient instance. You should call client.connect() method to complete RTMP connect.\n\nExample\n```javascript\nvar bls = require(\"bls\");\nbls.remote_connect(\"127.0.0.1\", 8955, function(edge_connect){\n    if(edge_connect)\n    {\n        console.log(\"connect remote server success.\")\n        edge_connect.connect({info:\"auth\"}, function(flag, args){\n            console.log(\"send connect to remote server. flag:%s args:%j\", flag, args);\n        });\n    }\n    else\n    {\n        console.log(\"connect remote server fail\");\n    }\n});\n```\n\n###Var:MAX_BUFFER_LEN\n--------------------\n\nIndicate the max size of command data.\n\n###Class:BlsClient\n--------------------\n\nBlsClient instance stands for a client that connects to server. A lot of events can be catched from a client, and you can control this client through APIs. BlsClient inherits from Emitter.\n\n####BlsClient.prototype.accept(allow, code, descript)\n--------------------\n\nDecide whether accept this client in RTMP protocol.\n- **allow** `[boolean]` true means accept, false means reject\n- **code** `[string]` RTMP connect reject code. If allow is true, code is  NetConnection.Connect.Success default. Otherwise it is [NetConnection.Connect.Error|NetConnection.Connect.Fail|...]\n- **descript** `[string]` description about rejection result.\n\n```javascript\n    client.on(\"connect\", function(trans_id, connect_info)\n    {\n        console.log(\"new client connect. %s tsid: %d connect_info: %j\",\n            client.client_id, trans_id, connect_info);\n\n\t\t//accept\n        client.accept(true);\n        ////reject\n        //client.accept(false, \"NetConnection.Connect.Rejected\", \"reject\");\n        });\n    });\n```\n\n####BlsClient.prototype.call(cmd_name, args_array, cb_func(result_flag, args))\n--------------------\n\nSend user custom command to client. If result is not needed, cb_func should be None.\n- **cmd_name** `[cmd_name]` user custom command name\n- **args_array** `[array]` command args. \n- **cb_func** `[function]` callback function when client sends result according to this command.\n\t- **result_flag** `[string]` \"_result\" or \"_error\" recv from client.\n\t- **args** `[array]` result data recv from client\n\t\n####BlsClient.prototype.close()\n--------------------\n\nClose this client connection.\n\n####BlsClient.prototype.edge(stream_name, cb())\n--------------------\n\nThis method is made for cluster. Local BLS can pull stream data from a remote BLS server as a source. Then player clients can play this stream from local BLS. The client must be producted from `remote_connect` function.\n- **stream_name** `[string]` the name of stream you want to pull from remote BLS. And this stream_name will be local stream name.\n- **cb** `[function]` called when pull finish, which means players can play the stream name from local BLS from now on.\n```javascript\nbls.remote_connect(\"127.0.0.1\", 8956, function(edge_connect){\n    if(edge_connect)\n    {\n        console.log(\"connect remote server success.\")\n        edge_connect.connect({info:\"hehe\"}, function(results){\n            console.log(\"send connect to remote server. recv:\");\n            console.dir(arguments);\n\n            edge_connect.edge(\"78c1f9ba124611e4815aac853dd1c904\", function(){\n                console.log(\"edge complete\");\n            });\n        });\n    }\n    else\n    {\n        console.log(\"connect remote server fail\");\n    }\n});\n```\n\n####BlsClient.prototype.get_aac_sh()\n--------------------\n\nreturn aac sequence header data recieved from client.\n\n####BlsClient.prototype.get_avc_sh()\n--------------------\n\nreturn avc sequence header data recieved from client.\n\n####BlsClient.prototype.is_closed()\n--------------------\n\nreturn True if client is not alive.\n\n####BlsClient.prototype.play(trans_id, stream_name)\n--------------------\n\nAllow client to play one stream.\n>**Note**: One client can only play one stream now.\n>**Note**: If this stream name is not publishing, the player will never get stream data even if this stream publish later. So you can wait for publish soucre ready then call play method of player.\n\n- **trans_id** `[number]` must be same with trans id in play event\n- **stream_name** `[number]` indicates which stream is passed to client. The stream_name must be same with the publish one. But it is not necessary same with stream name in play event.\n\n####BlsClient.prototype.publish(trans_id, stream_name)\n--------------------\n\nAllow client to publish one stream\n\n>**Note**: One client can only publish one stream at the same time.\n\n- **trans_id** `[number]` must be same with trans id in publish event.\n- **stream_name** `[number]` indicates the stream name to publish with this client.\n\n####BlsClient.prototype.push(stream_name, cb)\n--------------------\n\nThis method is made for cluster. Local BLS can push stream data to a remote BLS server as a source. Then player clients can play this stream from remote BLS. The BLS client must be producted from `remote_connect` function.\n\n- **stream_name** `[string]` the name of stream you want to push to remote BLS. \n- **cb** `[function]` called when push finish, which means players can play the stream name from remote BLS from now on.\n\n####BlsClient.prototype.result(result_flag, transid, args)\n--------------------\n\nSend result to client according to the command received from client.\n\n- **result_flag** `[string]` \"_result\" or \"_error\"\n- **transid** `[number]` must be same with transid in command event\n- **args** `[array]` result data\n\nExample:\n```javascript\n    //listen to custom command from client, so client can send custom data to bls\n    client.on(\"customCmd\", function(trans_id, cmd_obj, data){\n        console.log(\"get user custom command. %s %s %s\", trans_id, cmd_obj, data);\n\n        var result = [\"result data\"];\n\n        //you can answer client with \"_result\" or \"_error\"\n        //trans_id must be same with the one in cb func arguments\n        client.result(\"_result\", trans_id, result);\n    });\n```\n\n####BlsClient.prototype.unpublish()\n--------------------\n\nClient stop publishing stream.\n\n####BlsClient.prototype.enable_av_cb(cb(av_type, timestamp, is_sh, is_key, data))\n--------------------\n\nYou can get each audio/video frame from client with this method.\n- **cb** `[function]` call back function called when get a frame\n    - **av_type** `[string]` \"video\" or \"audio\"\n    - **timestamp** `[number]` time stamp carried with this frame\n    - **is_sh** `[boolean]` whether is sequence header data\n    - **is_key** `[boolean]` whether is key frame\n    - **data** `[buffer]` frame data\n\nexample:\n```javascript\nclient.enable_av_cb(function(av_type, timestamp, is_sh, is_key, data){\n    console.log(\"get a %s data. ts:%d, is sequence header:%s, is key frame:%s\", \n        av_type, timestamp, is_sh, is_key);\n});\n```\n\n####BlsClient.prototype.disable_av_cb()\n--------------------\n\ndon't throw up audio/video data to js call back function.\n\n####Event:connect(trans_id, connect_info)\n--------------------\n\nEmitted when a client send RTMP connect command to BLS.\n- **trans_id** `[number]` rtmp protocol needs.\n- **connect_info** `[object]` connect information recieved from client.\n\n####Event:close(close_status)\n--------------------\n\nEmitted when client leave.\n\n####Event:publish(trans_id, cmd_objs, stream_name)\n--------------------\n\nEmitted when client wants to publish a stream\n\n####Event:play(trans_id, cmd_obj, stream_name)\n--------------------\n\nEmitted when client wants to play a stream\n\n####Event:play_stop_event()\n--------------------\n\nWhen a stream stop publishing, players to this source will get this event emitted.\n\n####Event:onMetaData(meta_data)\n--------------------\n\nEmitted when recieved meta data from client in process of publish stream.\n\n####Event:unplay()\n--------------------\n\nEmitted when client stop play stream.\n\n####Event:unpublish()\n--------------------\n\nEmitted when client stop publish stream.\n\n####Event:ping_pong_request(delay, recv_sum)\n--------------------\n\nEmitted when client send pong response to BLS.\n- **delay** `[number]` delay after BLS send ping request to client.\n- **recv_sum** `[number]` how many bytes recved from client totally.\n\n####Event:{customCommand}(trans_id, cmd_obj, data)\n--------------------\n\nEmitted when receive user custom command.\n","starsCount":1,"created":"2017-01-09T09:55:04.508Z","modified":"2017-02-16T03:47:42.129Z","lastPublisher":{"name":"sssjszz","email":"yuliangc9@gmail.com"},"owners":[{"name":"sssjszz","email":"yuliangc9@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"bls","_nodeVersion":"6.9.4","_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/bls-1.1.1.tgz_1487216860081_0.3880354652646929"},"_npmUser":{"name":"sssjszz","email":"yuliangc9@gmail.com"},"_npmVersion":"3.10.10","_rev":"12-113eb9868c69eb6b3b8740c9d1b74b84","_shasum":"3cfc2efe9d8e27be26e48c38aa29680b44a6b538","bugs":{"url":"https://github.com/yuliangc9/bls2/issues"},"contributors":[{"name":"chenyuliang","email":"yuliangc9@gmail.com"}],"directories":{},"dist-tags":{"latest":"1.1.1"},"dist":{"shasum":"3cfc2efe9d8e27be26e48c38aa29680b44a6b538","tarball":"https://registry.npmjs.org/bls/-/bls-1.1.1.tgz"},"maintainers":[{"name":"sssjszz","email":"yuliangc9@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-02-16T03:47:42.129Z","created":"2017-01-09T09:55:04.508Z","0.0.1":"2017-01-09T09:55:04.508Z","0.0.2":"2017-01-09T11:10:29.369Z","1.0.0":"2017-01-09T11:19:43.604Z","1.0.1":"2017-01-11T15:06:26.746Z","1.0.2":"2017-01-12T05:48:07.659Z","1.0.3":"2017-01-12T14:35:58.246Z","1.0.4":"2017-01-12T14:50:41.913Z","1.0.5":"2017-01-15T03:45:06.274Z","1.0.6":"2017-01-19T05:31:57.805Z","1.1.0":"2017-02-10T05:40:24.279Z","1.1.1":"2017-02-16T03:47:42.129Z"},"users":{"sssjszz":true}}}