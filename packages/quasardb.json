{"license":"BSD-2-Clause","homepage":"https://www.quasardb.net","name":"quasardb","description":"Official quasardb nodejs library","keywords":["quasardb","nosql","database","store"],"main":"./index.js","version":"2.0.4","repository":"https://github.com/bureau14/qdb-api-nodejs","dependencies":{"node-pre-gyp":"^0.6.29"},"devDependencies":{"bluebird":"^3.4.3","mocha":"^3.0.2","unit.js":"^2.0.0"},"scripts":{"install":"node-pre-gyp install","test":"mocha test","package":"node-pre-gyp package"},"binary":{"module_name":"quasardb","module_path":"./lib/binding/","host":"https://npm.quasardb.net/"},"bundleDependencies":["node-pre-gyp"],"versions":[{"number":"2.0.0","date":"2016-07-07T16:00:00.334Z"},{"number":"2.0.1","date":"2016-07-08T15:58:40.186Z"},{"number":"2.0.2","date":"2016-09-23T14:51:23.375Z"},{"number":"2.0.3","date":"2016-12-22T16:50:49.392Z"},{"number":"2.0.4","date":"2017-01-26T17:28:41.315Z"}],"readme":"# quasardb node.js API\n\nThis is the official quasardb API, suitable for production. The full documentation is available [here](https://doc.quasardb.net/).\n\n[quasardb](https://www.quasardb.net/) 2.0 or later required. You need a C++ 11 compiler to compile this addon.\n\n## Installation\n\n```\nnpm install quasardb --save\n```\n\n## Compilation\n\nAlternatively if you want to compile from source:\n\n1. Clone git repository\n2. [Download quasardb server and C api](https://download.quasardb.net/quasardb/)\n3. Extract both tarballs into `qdb-api-nodejs\\deps\\qdb`\n\nThen:\n\n```\nnpm install --build-from-source\nnpm test\n```\n\n## Introduction\n\nUsing *quasardb* starts with a Cluster:\n\n```javascript\nvar qdb = require('quasardb');\n\nvar c = new qdb.Cluster('qdb://127.0.0.1:2836');\n```\n\nAnd creating a connection:\n\n```javascript\nc.connect(function() {\n        // successfully connected to the cluster\n    },\n    function(err) {\n        // error\n    });\n```\n\n > The error callback you provide on the connect will also be called if you later get disconnected from the cluster or a fatal error preventing normal operation occurs.\n\nNow that we have a connection to the cluster, let's store some binary data:\n\n```javascript\nvar b = c.blob('bam');\n\nb.put(new Buffer(\"boom\"), function(err) { /* */  });\nb.get(function(err, data) { /* */  });\n```\n\nWant a queue? We have distributed double-ended queues (aka deques).\n\n```javascript\nvar q = c.deque('q2');\n\nq.pushBack(new Buffer(\"boom\"), function(err) { /* */ });\nq.popFront(function(err, data) { /* */ });\nq.pushFront(new Buffer(\"bang\"), function(err) { /* */ });\nq.size(function(err, s) { /* */ });\nq.at(2, function(err, data) { /* */ });\n```\n\nquasardb comes out of the box with server-side atomic integers:\n\n```javascript\nvar i = c.integer('some_int');\ni.put(3, function(err){ /* */});\ni.add(7, function(err, data){ /* */});\n```\n\nWe also provide distributed sets:\n\n```javascript\nvar s = c.set('the_set');\n\ns.insert(new Buffer(\"boom\"), function(err) { /* */ });\n```\n\n## Tags\n\n[quasardb](https://www.quasardb.net/) is advanced key-value store with a powerful tagging feature. Tags lookup are fast, scalable and reliable.\n\nAny entry can be tagged, including tags.\n\n```javascript\nvar b = c.blob('bam');\n\nb.attachTag('dasTag', function(err) { /* */ });\n\nvar i = c.integer('bom');\n\ni.attachTag('dasTag', function(err) { /* */ });\n\nvar t = c.tag('dasTag');\n\nt.getEntries(function(err, entries} { /* entries is the list of entries */ });\n```\n\nIt is also possible to list the tags of an entry or test for the existence of a tag:\n\n```javascript\nb.hasTag('dasTag', function(err) { /* */ });\n\nb.getTags(function(err, tags) { /* tags is the list of tags */ });\n```\n\n## Expiry\n\nIntegers and blob can be configured to automatically expire. The expiry can be specified with an absolute value at the entry creation or update, or can\nlater be set with expiresAt and expiresFromNow.\n\nThe expiry is second-precise.\n\n```javascript\nvar b = c.blob('bam');\n\n// value will be removed at the specified time\nb.put(new Buffer(\"boom\"), new Date(\"October 1st, 2016 11:13:00\"), function(err) { /* */  });\n\n// value expires now!\nb.expiresAt(new Date());\n\n// entry will be removed in 20 seconds relative to the current time\nb.expiresFromNow(20);\n```\n\nEverytime you update a value without providing an expiry, the expiry time is set to \"infinite\" (i.e. never expires).\n\nYou can query the expiry time of an entry with getExpiry:\n\n```javascript\n// returns a Date object\nvar expiry = b.getExpiry();\n```\n\nWhat if you want to update but *do not want to change the expiry*?\n\nThere is a special value `qdb.PRESERVE_EXPIRATION` that can be used:\n\n```javascript\nvar b = c.blob('bam');\n\n// value will be removed at the specified time\nb.put(new Buffer(\"boom\"), new Date(\"October 1st, 2016 11:13:00\"), function(err) { /* */  });\n\n// do stuff\n\nb.update(new Buffer(\"bang\"), qdb.PRESERVE_EXPIRATION, function(err) { /* */ });\n```\n\nWhen using the special value `qdb.PRESERVE_EXPIRATION` updates will keep the previous expiration. If you want an entry to never expire you can either not specify an expiration or use `qdb.NEVER_EXPIRES`.\n\nTags, sets and queues do not expire (but can of course be manually removed).\n\n## Timeout\n\nYou can configure the *client-side* timeout (the server-side timeout is a cluster configuration which cannot be remotely changed).\n\nThe client-side timeout is the time duration after which a client will consider a request to have timed out. The default value is one minute (60,000 ms). You may want to lower this value on low-latency networks.\n\n\n```javascript\n// sets the timeout to 10s\nc.setTimeout(10000);\n```\n\nIdeally the timeout should be set before calling connect.\n\n## Metadata\n\nYou may want to get some metainformation about an entry without actually acquiring the data itself. For this purpose, `getMetadata` method may be invoked on any entry.\nIt returns an object that describes the type of the entry, its creation, last modification and expiry times, as well as its unique identifier (reference).\nFor blob entries, the size of the content is also returned.\n\n```javascript\nvar b = c.blob('bam');\n\nb.getMetadata(function(err, meta)) {\n    if (err) {\n        throw err.message;\n    }\n\n    console.log(JSON.stringify(meta, null, ' '));\n}\n```\n\nThe result may be something like:\n\n```json\n{\n \"reference\": [\n  7876229558754302000,\n  -5412596186697675000,\n  2684719845372276000,\n  -4458640659107684400\n ],\n \"type\": 0,\n \"size\": 11,\n \"modification_time\": \"2016-08-02T09:23:31.139Z\"\n}\n```\n\n## Errors\n\nQuasardb callback return error objects. When the callback is successful, the error object is null. You can therefore safely write:\n\n```javascript\nvar b = c.blob('bam');\n\nb.put(new Buffer(\"boom\"), function(err) {\n    if (err) {\n        // error management\n        throw err.message;\n    }\n\n    // ...\n});\n```\n\nYou may not want to throw at every error. Some errors are *transient*. Meaning the underlying problem may (or may not) solve by itself. Transient errors are typically:\n\n  * Transactions conflicts\n  * Network timeouts\n  * Cluster is currently stabilizing\n\nBecause you may want to try again before giving up, you can check if an error is transient with the transient() method:\n\n```javascript\nvar b = c.blob('bam');\n\nb.put(new Buffer(\"boom\"), function(err) {\n    if (err) {\n        if (err.transient) {\n            // let's try again\n        }\n    }\n\n    // ...\n});\n```\n\nYou can also query if an error is *informational*. An informational error means that the query has been succesfully processed by the server and your parameters were valid but the result is either empty or unavailable. Typical informational errors are:\n\n * Non-existing entry\n * Empty collection\n * Index out of range\n * Integer overflow/underflow\n\n```javascript\nvar b = c.blob('bam');\n\nb.put(new Buffer(\"boom\"), function(err) {\n    if (err) {\n        if (err.informational) {\n            // let's do something different\n        }\n    }\n\n    // ...\n});\n```\n\n## Not supported yet\n\nThe quasardb nodejs addon is still a work in progress, the following quasardb features are not supported:\n\n * Advanced atomic operations such as compare and swap and conditional removal\n * Batches and transactions\n","created":"2016-07-07T16:00:00.334Z","modified":"2017-01-26T17:28:41.315Z","lastPublisher":{"name":"quasardb","email":"npm@quasardb.net"},"owners":[{"name":"quasardb","email":"npm@quasardb.net"}],"other":{"_attachments":{},"_from":".","_id":"quasardb","_nodeVersion":"6.9.1","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/quasardb-2.0.4.tgz_1485451715524_0.26976669020950794"},"_npmUser":{"name":"quasardb","email":"npm@quasardb.net"},"_npmVersion":"3.10.8","_rev":"3-2e4b3bf5b993233efeaa7bf7cf09d9fb","_shasum":"d31b97dca3c88a5f64a493c1ce9b3fff35000c91","author":{"name":"quasardb"},"bugs":{"url":"https://quasardb.zendesk.com"},"directories":{},"dist-tags":{"latest":"2.0.4"},"dist":{"shasum":"d31b97dca3c88a5f64a493c1ce9b3fff35000c91","tarball":"https://registry.npmjs.org/quasardb/-/quasardb-2.0.4.tgz"},"maintainers":[{"name":"quasardb","email":"npm@quasardb.net"}],"readmeFilename":"README.md","time":{"modified":"2017-01-26T17:28:41.315Z","created":"2016-07-07T16:00:00.334Z","2.0.0":"2016-07-07T16:00:00.334Z","2.0.1":"2016-07-08T15:58:40.186Z","2.0.2":"2016-09-23T14:51:23.375Z","2.0.3":"2016-12-22T16:50:49.392Z","2.0.4":"2017-01-26T17:28:41.315Z"}}}