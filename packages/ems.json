{"name":"ems","version":"1.4.4","description":"Persistent Shared Memory and Parallel Programming Model","scripts":{"test":"cd Tests && rm -f EMSthreadStub.js && for test in `ls *js`; do node $test 8; err=$?; echo $test \": ERROR=\" $err;  if [ $err -ne 0 ] ; then exit 1; fi; done","example":"cd Examples; node concurrent_Q_and_TM.js 8","install":"node-gyp rebuild"},"main":"nodejs/ems.js","repository":"https://github.com/syntheticsemantics/ems","homepage":"https://synsem.com/EMS.js","keywords":["non volatile memory","NVM","NVMe","multithreading","multithreaded","parallel","parallelism","concurrency","shared memory","multicore","manycore","transactional memory","TM","persistent memory","pmem","Extended Memory Semantics","EMS"],"license":"BSD-3-Clause","engines":{"node":">=0.10.25"},"dependencies":{"bindings":"^1.2.1","ffi":"^2.0.0","nan":"^2.1.0","node-gyp":"^3.2.1"},"gypfile":true,"gitHead":"b2efeb20232eca400d24ce10eeec091e9421c2b7","versions":[{"number":"0.1.0","date":"2014-03-30T18:09:08.113Z"},{"number":"0.1.1","date":"2014-03-30T21:13:52.145Z"},{"number":"0.1.2","date":"2014-03-30T21:21:01.075Z"},{"number":"0.1.3","date":"2014-03-30T22:38:50.550Z"},{"number":"0.1.4","date":"2014-03-30T22:39:22.583Z"},{"number":"0.1.5","date":"2014-03-30T22:49:18.341Z"},{"number":"0.1.6","date":"2014-03-31T00:24:20.773Z"},{"number":"0.1.7","date":"2014-03-31T04:11:12.047Z"},{"number":"0.1.8","date":"2014-04-01T06:28:07.270Z"},{"number":"0.1.9","date":"2014-04-30T17:44:01.020Z"},{"number":"0.1.10","date":"2014-05-09T21:07:09.106Z"},{"number":"0.1.11","date":"2014-05-12T19:47:09.470Z"},{"number":"0.1.12","date":"2014-05-12T20:07:59.370Z"},{"number":"0.1.13","date":"2014-05-20T05:17:33.441Z"},{"number":"0.1.14","date":"2014-05-21T00:56:33.872Z"},{"number":"0.1.15","date":"2014-06-30T03:01:00.946Z"},{"number":"0.2.0","date":"2014-07-20T23:53:38.185Z"},{"number":"0.2.1","date":"2014-07-21T15:55:16.825Z"},{"number":"0.2.2","date":"2014-07-23T17:01:24.261Z"},{"number":"1.0.1","date":"2016-01-04T05:37:44.033Z"},{"number":"1.0.2","date":"2016-01-04T05:43:56.411Z"},{"number":"1.0.3","date":"2016-01-04T05:46:34.431Z"},{"number":"1.0.5","date":"2016-01-04T06:05:51.267Z"},{"number":"1.0.6","date":"2016-01-04T06:26:25.616Z"},{"number":"1.0.7","date":"2016-01-05T06:10:20.660Z"},{"number":"1.0.8","date":"2016-01-11T00:12:51.735Z"},{"number":"1.0.10","date":"2016-01-17T01:26:18.762Z"},{"number":"1.0.11","date":"2016-01-17T23:52:01.376Z"},{"number":"1.0.14","date":"2016-01-25T04:28:29.466Z"},{"number":"1.1.0","date":"2016-02-07T04:42:21.722Z"},{"number":"1.1.1","date":"2016-02-07T19:36:20.654Z"},{"number":"1.2.0","date":"2016-02-16T05:12:21.755Z"},{"number":"1.3.1","date":"2016-05-02T04:03:15.361Z"},{"number":"1.3.2","date":"2016-05-02T04:12:30.749Z"},{"number":"1.3.3","date":"2016-05-02T04:31:53.243Z"},{"number":"1.3.4","date":"2016-05-14T19:06:20.077Z"},{"number":"1.3.5","date":"2016-06-13T01:17:57.908Z"},{"number":"1.3.6","date":"2016-06-13T01:36:31.371Z"},{"number":"1.4.0","date":"2016-10-24T01:07:28.754Z"},{"number":"1.4.2","date":"2017-01-23T06:27:41.198Z"},{"number":"1.4.3","date":"2017-02-21T05:47:02.221Z"},{"number":"1.4.4","date":"2017-03-12T05:17:13.099Z"}],"readme":"OSX | Linux | Node 6.x, 5.x, 4.x, 0.10, iojs, Python2/3:\n[![Build Status](https://travis-ci.org/SyntheticSemantics/ems.svg?branch=master)](https://travis-ci.org/SyntheticSemantics/ems)\n[![npm version](https://badge.fury.io/js/ems.svg)](https://www.npmjs.com/package/ems)\n[![NPM](https://nodei.co/npm/ems.png?downloads=true&stars=true&downloadRank=true)](https://www.npmjs.org/package/ems)\n[![NPM](https://nodei.co/npm-dl/ems.png?months=1&height=3)](https://www.npmjs.com/package/ems)\n\n### [API Documentation](http://syntheticsemantics.com/EMS.js/reference.html) | [EMS Website](http://syntheticsemantics.com/EMS.js)\n\n# Extended Memory Semantics (EMS)\n___EMS makes possible shared memory parallelism between Node.js, Python, and C/C++___.\n\nExtended Memory Semantics (EMS) is a unified programming and execution model\nthat addresses several challenges of parallel programming:\n+ Allows any number or kind of processes to share objects\n+ Manages synchronization and object coherency\n+ Implements persistence to NVM and secondary storage\n+ Provides dynamic load-balancing between processes\n+ May substitute or complement other forms of parallelism\n\n#### Table of Contents\n* [Parallel Execution Models Supported](#Types\\ of\\ Concurrency)\n* [Atomic Operations](#Built-in\\ Atomic\\ Operations)\n* [Examples](https://github.com/SyntheticSemantics/ems/tree/master/Examples)\n* [Benchmarks](#Examples\\ and\\ Benchmarks)\n* [Synchronization as a Property of the Data, Not a Duty for Tasks](Synchronization\\ as\\ a\\ Property\\ of\\ the\\ Data,\\ Not\\ a\\ Duty\\ for\\ Tasks)\n* [Installation](#Installation)\n* [Roadmap](#Roadmap)\n\n#### EMS is targeted at tasks too large for one core or one process\n\nA modern multicore server has 16-32 cores and over 200GB of memory,\nequivalent to an entire rack of systems from a few years ago.\nAs a consequence, jobs formerly requiring a Map-Reduce cluster\ncan now be performed entirely in shared memory on a single server\nwithout using distributed programming.\n\n## Sharing Persistent Objects Between Python and Javascript\n<img src=\"http://synsem.com/images/ems_js_py.gif\" />\n\nInter-language example in [interlanguage.{js,py}](https://github.com/SyntheticSemantics/ems/tree/master/Examples)\n\n* Start Node.js REPL, create an EMS memory\n* Store \"Hello\"\n* Open a second session, begin the Python REPL\n* Connect to the EMS shared memory from Python\n* Show the object created by JS is present\n* Modify the object, and show the modification can be seen in JS\n* Exit both REPLs so no programs are running to \"own\" the EMS memory\n* Restart Python, show the memory is still present\n* Initialize a counter from Python\n* Demonstrate atomic Fetch and Add in JS\n* Start a loop in Python incrementing the counter\n* Simultaneously print and modify the value from JS\n* Try to read \"empty\" data from Python, process blocks\n* Write the empty memory, marking it full, Python resumes execution\n\n## Types of Concurrency\n<table>\n    <tr>\n      <td>\nEMS extends application capabilities to include transactional memory and\nother fine-grained synchronization capabilities.\n<br><br>\nEMS implements several different parallel execution models:\n<ul>\n<li> <B>Fork-Join Multiprocess</B>: execution begins with a single process that creates new processes\n  when needed, those processes then wait for each other to complete.\n\n<li> <B>Bulk Synchronous Parallel</B>: execution begins with each process starting the program at the\n  <code>main</code> entry point and executing all the statements\n\n<li> <B>User Defined</B>: parallelism may include ad-hoc processes and mixed-language applications\n</ul>\n\t\t</td>\n        <td width=\"50%\">\n        <center>\n\t\t  <img height=\"350px\" style=\"margin: 10px;\" src=\"http://synsem.com/images/ems/typesOfParallelism.svg\" type=\"image/svg+xml\"  />\n        </center>\n        </td>\n    </tr>\n</table>\n\n\n## Built-in Atomic Operations\nEMS operations may performed using any JSON data type, read-modify-write operations\nmay use any combination of JSON data types, producing identical results to\nlike operations on ordinary data.\n\nAll basic and atomic read-modify-write operations are available\nin all concurrency modes, however collectives are not \ncurrently available in user defined modes.\n\n- __Basic Operations__: \n\tRead, write, readers-writer lock, read full/empty, write empty/full\n\n- __Primitives__:\n\tStacks, queues, transactions\n\n- __Atomic Read-Modify-Write__:\n\tFetch-and-Add, Compare and Swap\n\n- __Collective Operations__:\n\tAll basic [OpenMP](https://en.wikipedia.org/wiki/OpenMP)\n    collective operations are implemented in EMS:\n    dynamic, block, guided, and static loop scheduling, \n    barriers, master and single execution regions\n\n## Examples and Benchmarks\n\n### Word Counting Using Atomic Operations\nMap-Reduce is often demonstrated using word counting because each document can\nbe processed in parallel, and the results of each document's dictionary reduced\ninto a single dictionary.  This EMS implementation also\niterates over documents in parallel, but it maintains a single shared dictionary\nacross processes, atomically incrementing the count of each word found.\nThe final word counts are sorted and the most frequently appearing words\nare printed with their counts.\n\n\n<img height=\"300px\" src=\"http://synsem.com/images/ems/wordcount.svg\" />\n\nThe performance of this program was measured using an Amazon EC2 instance:<br>\n`c4.8xlarge (132 ECUs, 36 vCPUs, 2.9 GHz, Intel Xeon E5-2666v3, 60 GiB memory`\nThe leveling of scaling aroung 16 cores despite the presence of ample work\nmay be related to the use of non-dedicated hardware:\nHalf of the 36 vCPUs are presumably HyperThreads or otherwise shared resoruce.\nAWS instances are also bandwidth limited to EBS storage, where our Gutenberg\ncorpus is stored.\n\n### Bandwidth Benchmarking\nA benchmark similar to [STREAMS](https://www.cs.virginia.edu/stream/)\ngives us the maximum speed EMS double precision\nfloating point operations can be performed on a\n`c4.8xlarge (132 ECUs, 36 vCPUs, 2.9 GHz, Intel Xeon E5-2666v3, 60 GiB memory`.\n\n<img src=\"http://synsem.com/images/ems/streams.svg\" type=\"image/svg+xml\" height=\"300px\">\n\n\n### Benchmarking of Transactions and Work Queues\nThe micro-benchmarked raw transactional performance and \nperformance in the context of a workload are measured separately.\nThe experiments were run using an Amazon EC2 instance:<br>\n<code>c4.8xlarge (132 ECUs, 36 vCPUs, 2.9 GHz, Intel Xeon E5-2666v3, 60 GiB memory</code>\n\n#### Experiment Design\nSix EMS arrays are created, each holding 1,000,000 numbers.  During the\nbenchmark, 1,000,000 transactions are performed, each transaction involves 1-5\nrandomly selected elements of randomly selected EMS arrays.\nThe transaction reads all the elements and\nperforms a read-modify-write operation involving at least 80% of the elements.\nAfter all the transactions are complete, the array elements are checked\nto confirm all the operations have occurred.\n\nThe parallel process scheduling model used is *block dynamic* (the default),\nwhere each process is responsible for successively smaller blocks\nof iterations.  The execution model is *bulk synchronous parallel*, each\nprocesses enters the program at the same main entry point\nand executes all the statements in the program.\n`forEach` loops have their normal semantics of performing all iterations,\n`parForEach` loops are distributed across threads, each process executing\nonly a portion of the total iteration space.\n\n\n<table width=100%>\n\t<tr>\n    \t<td>\n\t    <center>\n\t\t\t<img style=\"vertical-align:text-top;\" src=\"http://synsem.com/images/ems/tm_no_q.svg\" />\n            <br><b>Immediate Transactions:</b> Each process generates a transaction on integer data then immediately performs it.\n    \t</center>\n\t    </td>\n    \t<td width=\"50%\">\n\t    <center>\n\t\t\t<img style=\"vertical-align:text-top;\" src=\"http://synsem.com/images/ems/tm_from_q.svg\" />\n            <br><b>Transactions from a Queue:</b> One of the processes generates the individual transactions and appends\n\t\t\t\tthem to a work queue the other threads get work from.  \n                <B>Note:</b> As the number of processes increases, the process generating the transactions\n\t\t    \tand appending them to the work queue is starved out by processes performing transactions,\n                naturally maximizing the data access rate.\n\t    </center>\n\t    </td>\n    </tr>\n\t<tr>\n    \t<td>\n\t    <center>\n\t\t\t<img style=\"vertical-align:text-top;\" src=\"http://synsem.com/images/ems/tm_no_q_str.svg\"/>\n            <br><b>Immediate Transactions on Strings:</b> Each process generates a transaction appending to\n\t\t\ta string, and then immediately performs the transaction.\n    \t</center>\n\t    </td>\n    \t<td width=\"50%\">\n        <center>\n        <b>Measurements</b>\n        </center><br>\n        <b>Elem. Ref'd:</b> Total number of elements read and/or written\n\t\t<br>\n        <b>Table Updates:</b> Number of different EMS arrays (tables) written to\n\t\t<br>\n        <b>Trans. Performed:</b> Number of transactions performed across all EMS arrays (tables)\n\t\t<br>\n        <b>Trans. Enqueued:</b> Rate transactions are added to the work queue (only 1 generator thread in these experiments)\n\t    </td>\n    </tr>\n</table>\n\n\n\n## Synchronization as a Property of the Data, Not a Duty for Tasks\n\nEMS internally stores tags that are used for synchronization of\nuser data, allowing synchronization to happen independently of\nthe number or kind of processes accessing the data.  The tags\ncan be thought of as being in one of three states, _Empty,\nFull,_ or _Read-Only_, and the EMS intrinsic functions\nenforce atomic access through automatic state transitions.\n\nThe EMS array may be indexed directly using an integer, or using a key-index\nmapping from any primitive type.  When a map is used, the key and data\nitself are updated atomically.\n\n<table >\n    <tr>\n      <td>\n    <center>\n      <img style=\"width:350px; \"\n\t   src=\"http://synsem.com/EMS.js/memLayoutLogical.svg\" type=\"image/svg+xml\" />\n      <em>    <br><br> \n    EMS memory is an array of JSON primitive values\n        (Number, Boolean, String, or Undefined) accessed using atomic\n        operators and/or transactional memory.  Safe parallel access\n        is managed by passing through multiple gates: First mapping a\n        key to an index, then accessing user data protected by EMS\n        tags, and completing the whole operation atomically.\n      </center>\n    </em>\n    </td>\n    <td width=\"50%\">\n      <center>\n  <img style=\"height:270px; \"\n   src=\"http://synsem.com/EMS.js/fsmSimple.svg\" type=\"image/svg+xml\" />\n    <em>    <br><br> EMS Data Tag Transitions & Atomic operations:\n    F=Full, E=Empty, X=Don't Care, RW=Readers-Writer lock (# of current readers)\n    CAS=Compare-and-Swap, FAA=Fetch-and-Add</em>\n      </center>\n    </td>\n    </tr>\n</table>\n\n\n## More Technical Information\n\nFor a more complete description of the principles of operation,\n[visit the EMS web site.](http://synsem.com/EMS.js/)\n\n[ Complete API reference ](http://synsem.com/EMS.js/reference.html)\n  \n<br>\n<center>\n  <img src=\"http://synsem.com/EMS.js/blockDiagram.svg\" type=\"image/svg+xml\" height=\"300px\" style=\"vertical-align:text-top;\"/>\n</center>\n\n\n## Installation\n\nBecause all systems are already multicore, \nparallel programs require no additional equipment, system permissions,\nor application services, making it easy to get started.\nThe reduced complexity of\nlightweight threads communicating through shared memory\nis reflected in a rapid code-debug cycle for ad-hoc application development.\n\n### Quick Start with the Makefile\nTo build and test all C, Python 2 and 3, and Node.js targets,\na makefile can automate most build and test tasks.\n\n```sh\ndunlin> make help\n         Extended Memory Semantics  --  Build Targets\n===========================================================\n    all                       Build all targets, run all tests\n    node                      Build only Node.js\n    py                        Build both Python 2 and 3\n\n    py[2|3]                   Build only Python2 or 3\n    test                      Run both Node.js and Py tests\n    test[_js|_py|_py2|_py3]   Run only Node.js, or only Py tests, respectively\n    clean                     Remove all files that can be regenerated\n    clean[_js|_py|_py2|_py3]  Remove Node.js or Py files that can be regenerated\n```\n\n\n### Install via npm\nEMS is available as a NPM Package.  EMS itself has no external dependencies,\nbut does require compiling native C++ functions using <code>node-gyp</code>,\nwhich is also available as a NPM (<code>sudo npm install -g node-gyp</code>).\n\nThe native C parts of EMS depend on other NPM packages to compile and load.\nSpecifically, the Foreign Function Interface (ffi), C-to-V8 symbol renaming (bindings),\nand the native addon abstraction layer (nan) are also required to compile EMS.\n\n```sh\nnpm install ems\n```\n\n### Install via GitHub\nDownload the source code, then compile the native code:\n\n```sh\ngit clone https://github.com/SyntheticSemantics/ems.git\ncd ems\nnpm install\n```\n\nTo use this EMS development build to run the examples or tests,\nset up a global npm link to the current build:\n\n```sh\nsudo npm link ../ems\n```\n\n\n### Run Some Examples\nOn a Mac and most Linux distributions EMS will \"just work\", but\nsome Linux distributions restrict access to shared memory.  The\nquick workaround is to run jobs as root, a long-term solution will\nvary with Linux distribution.\n\n\nRun the work queue driven transaction processing example on 8 processes:\n```sh\nnpm run <example>\n```\n\nOr manually via:\n```sh\ncd Examples\nnode concurrent_Q_and_TM.js 8\n```\n\nRunning all the tests with 8 processes:\n```sh\nnpm run test      # Alternatively: npm test\n```\n\n```sh\ncd Tests\nrm -f EMSthreadStub.js   # Do not run the machine generated script used by EMS\nfor test in `ls *js`; do node $test 8; done\n```\n\n## Platforms Supported\nAs of 2016-05-01, Mac/Darwin and Linux are supported.  A windows port pull request is welcomed!\n\n\n## Roadmap\nEMS 1.0 uses Nan for long-term Node.js support, we continue to\ndevelop on OSX and Linux via Vagrant.\n\nEMS 1.3 introduces a C API.\n\nEMS 1.4 Python API\n\nEMS 1.5 **[Planned]** Support for [persistent main system memory](http://pmem.io/).\n\nEMS 2.0 **[Planned]** New API with more tightly integrate with \nES6, Python, and other dynamically typed languages languages,\nmaking atomic operations on persistent memory more transparent.\n\n## License\nBSD, other commercial and open source licenses are available.\n\n## Links\n[Visit the EMS web site](http://synsem.com/EMS.js/)\n\n[Download the NPM](https://www.npmjs.org/package/ems)\n\n[Get the source at GitHub](https://github.com/SyntheticSemantics/ems)\n\n## About\nJace A Mogill specializes in FPGA/Software Co-Design, recently\nembedding a FPGA emulation of an ASIC into Python and also \ndesigning an hardware accelerator for Python, Javascript, and other languages.\nHe has over 20 years experience optimizing software for distributed, multi-core, and \nhybrid computer architectures.\nHe regularly responds to mogill@synsem.com.\n","starsCount":11,"created":"2014-03-30T18:09:08.113Z","modified":"2017-07-15T06:40:19.626Z","lastPublisher":{"name":"mogill","email":"mogill@synsem.com"},"owners":[{"name":"mogill","email":"mogill@synsem.com"}],"other":{"_attachments":{},"_from":".","_id":"ems","_nodeVersion":"6.7.0","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/ems-1.4.4.tgz_1489295832850_0.004950550617650151"},"_npmUser":{"name":"mogill","email":"mogill@synsem.com"},"_npmVersion":"3.10.3","_rev":"11-77883878a84cb43b9940766ce5e2dd4e","_shasum":"c0d3e5a6b7bd1ad44829111e7e1073ff561278c4","author":{"name":"Synthetic Semantics","email":"info@synsem.com"},"bugs":{"url":"https://github.com/syntheticsemantics/ems/issues"},"contributors":[{"name":"Jace A Mogill","email":"mogill@synsem.com"}],"directories":{},"dist-tags":{"latest":"1.4.4"},"dist":{"shasum":"c0d3e5a6b7bd1ad44829111e7e1073ff561278c4","tarball":"https://registry.npmjs.org/ems/-/ems-1.4.4.tgz"},"maintainers":[{"name":"mogill","email":"mogill@synsem.com"}],"readmeFilename":"README.md","time":{"modified":"2017-07-15T06:40:19.626Z","created":"2014-03-30T18:09:08.113Z","0.1.0":"2014-03-30T18:09:08.113Z","0.1.1":"2014-03-30T21:13:52.145Z","0.1.2":"2014-03-30T21:21:01.075Z","0.1.3":"2014-03-30T22:38:50.550Z","0.1.4":"2014-03-30T22:39:22.583Z","0.1.5":"2014-03-30T22:49:18.341Z","0.1.6":"2014-03-31T00:24:20.773Z","0.1.7":"2014-03-31T04:11:12.047Z","0.1.8":"2014-04-01T06:28:07.270Z","0.1.9":"2014-04-30T17:44:01.020Z","0.1.10":"2014-05-09T21:07:09.106Z","0.1.11":"2014-05-12T19:47:09.470Z","0.1.12":"2014-05-12T20:07:59.370Z","0.1.13":"2014-05-20T05:17:33.441Z","0.1.14":"2014-05-21T00:56:33.872Z","0.1.15":"2014-06-30T03:01:00.946Z","0.2.0":"2014-07-20T23:53:38.185Z","0.2.1":"2014-07-21T15:55:16.825Z","0.2.2":"2014-07-23T17:01:24.261Z","1.0.1":"2016-01-04T05:37:44.033Z","1.0.2":"2016-01-04T05:43:56.411Z","1.0.3":"2016-01-04T05:46:34.431Z","1.0.5":"2016-01-04T06:05:51.267Z","1.0.6":"2016-01-04T06:26:25.616Z","1.0.7":"2016-01-05T06:10:20.660Z","1.0.8":"2016-01-11T00:12:51.735Z","1.0.10":"2016-01-17T01:26:18.762Z","1.0.11":"2016-01-17T23:52:01.376Z","1.0.14":"2016-01-25T04:28:29.466Z","1.1.0":"2016-02-07T04:42:21.722Z","1.1.1":"2016-02-07T19:36:20.654Z","1.2.0":"2016-02-16T05:12:21.755Z","1.3.1":"2016-05-02T04:03:15.361Z","1.3.2":"2016-05-02T04:12:30.749Z","1.3.3":"2016-05-02T04:31:53.243Z","1.3.4":"2016-05-14T19:06:20.077Z","1.3.5":"2016-06-13T01:17:57.908Z","1.3.6":"2016-06-13T01:36:31.371Z","1.4.0":"2016-10-24T01:07:28.754Z","1.4.2":"2017-01-23T06:27:41.198Z","1.4.3":"2017-02-21T05:47:02.221Z","1.4.4":"2017-03-12T05:17:13.099Z"},"users":{"rtgibbons":true,"evantorrie":true,"sopepos":true,"horpto":true,"octalmage":true,"bengi":true,"andr":true,"shiningray":true,"ramy":true,"godber":true,"sahlzen":true}}}