{"name":"eos","version":"0.4.1","description":"A truly asynchronous ODBC library for node.js","scripts":{"configure":"node-gyp configure","build":"node-gyp build","test":"grunt test","install":"node-gyp rebuild"},"keywords":["odbc","async","sql"],"main":"./lib/eos","dependencies":{"nan":"^1.3.0"},"devDependencies":{"async":"^0.9.0","chai":"~1.9.0","colors":"^1.0.3","grunt":"~0.4.2","grunt-contrib-jshint":"~0.8.0","grunt-jasmine-node":"~0.1.0","heapdump":"^0.3.2"},"license":"MIT","engines":{"node":">=0.10"},"gypfile":true,"gitHead":"118d461cb36a04fe4a2267e757458df3af6a70ef","versions":[{"number":"0.1.0","date":"2014-04-09T19:27:46.912Z"},{"number":"0.2.0","date":"2014-06-20T21:57:12.985Z"},{"number":"0.3.0","date":"2014-09-08T13:25:44.840Z"},{"number":"0.3.1","date":"2014-09-10T11:32:11.440Z"},{"number":"0.3.2","date":"2014-10-24T22:35:36.860Z"},{"number":"0.4.0","date":"2014-12-04T21:37:22.360Z"},{"number":"0.4.1","date":"2015-01-16T16:40:20.250Z"}],"readme":"What is this \"eos\"?\n===================\n\n * It's an ODBC library for [Node.js](http://www.nodejs.org), with support for v0.10 and (tentatively) v0.11.\n * It makes **asynchronous** requests using the notification method on Windows 8.1, falling back to `libuv` on other platforms.\n * The aim is to be a set of **bindings** rather than a fully-fledged ODBC library, and does not provide functionality which could be written in JavaScript. Hence it is small and fairly well documented.\n * Anything that can be asynchronous, is. It is possible to **stream large column values** by calling `SQLGetData` and `SQLPutData` in chunks.\n * Or, if you have lots of small columns, why not **bind them to a buffer** with `SQLBindCol`?\n * It's **MIT-licensed**, but contributions via pull requests are welcome.\n \n# Example\n\n```js\nvar eos = require('eos');\n\n// Yeah, this is quite a lot of code for such a simple task! Remember, this\n// is a set of bindings first and foremost. \nfunction getCustomerName(customerID, callback) {\n    var env = new eos.Environment();\n    var conn = env.newConnection();\n\n    conn.driverConnect(\"DSN=Customers;UID=Sara;PWD=12345\", function(err) {\n        if (err)\n            return callback(err);\n\n        var stmt = conn.newStatement();\n        \n        stmt.bindParameter(1, eos.SQL_PARAM_INPUT, eos.SQL_INTEGER, 0, 0, customerID);\n        var name = stmt.bindCol(1, eos.SQL_WVARCHAR, new Buffer(100));\n        \n        stmt.execDirect(\"select name from Customers where ID = ?\", function (err) {\n            if (err)\n                return callback(err);\n            \n            stmt.fetch(function(err, hasData) {\n                if (!err)\n                    return callback (err);\n                if (!hasData)\n                    return callback (new Error(\"Customer not found\"));\n                \n                callback(null, name.value);\n                \n                // You'd actually want to handle exceptions here - see documentation of \n                // closeCursor for details.\n                stmt.closeCursor();\n                \n                stmt.free();\n                conn.disconnect(function(err) {\n                    if (err)\n                        console.log(\"Couldn't disconnect!\", err.message);\n                    \n                    conn.free();\n                    env.free();\n                });\n            });\n        });\n    });\n}\n```\n\n# API\n\nThere are 4 types of handles in ODBC: environment, connection, statement, and descriptor. Eos\nwraps these handles in JavaScript objects. The handle will automatically be freed when the \nJavaScript object is garbage collected, but you may choose to do so earlier.\n\nEos makes no attempt to provide bells and whistles: this is a low-level wrapper around ODBC which\ncan be used as a building block for a more high-level library.\n\nMost functions in Eos are asynchronous (any ODBC call which can return `SQL_STILL_EXECUTING`), \nhowever some are guaranteed to return synchronously and are marked here with _(synchronous)_ \naccordingly.\n\n### Asynchronous execution\n\nODBC itself provides for synchronous calls, and asynchronous calls using either [polling](http://msdn.microsoft.com/en-us/library/ms713563%28v=vs.85%29.aspx) (requires ODBC 3.80, e.g. Windows 7) or the [notification method](http://msdn.microsoft.com/en-us/library/hh405038%28v=vs.85%29.aspx) (requires ODBC 3.81, e.g. Windows 8). \n\nEos uses the notification method where possible, and falls back to using synchronous calls on the  [libuv](https://github.com/joyent/libuv) thread pool where the notification method is not supported. The main advantage of the notification method is that fewer thread pool threads are used (1 thread per 64 concurrent operations, rather than 1 thread for each operation). The polling asynchronous method is not supported, but could be implemented. Synchronous versions of asychronous API calls are not yet implemented, but could also be done.\n\n### Documentation syntax\n\n * Most methods are asynchronous, the few that are synchronous are marked _(synchronous)_. Synchronous calls that raise errors will throw the error as a JavaScript exception.\n * Optional parameters are enclosed in square brackets, e.g.:\n   Environment.dataSources([type])\n * Callback parameters are declared as: Connection.connect(connectionString, callback([err], arg1, [arg2]))\n   A parenthesised argument list follows the callback name, with square brackets for optional arguments as usual. All callbacks in Eos take an _error_ parameter as the first argument, which will be undefined when there is no error. Many callbacks take only an _error_ parameter, in which case the argument list here is omitted and the _error_ parameter is implied.\n * ODBC API calls are referred to in bold, e.g. **SQLExecDirect**.\n\n### Error Handling\n\nErrors returned from the ODBC driver manager or the ODBC driver will be an instance of the `OdbcError` constructor. Asynchronous calls may still throw errors synchronously, in cases such as invalid arguments.\n\nODBC errors look something like this:\n\n```js\n{ message: '[Microsoft][ODBC Driver Manager] Data source name not found and no default driver specified',\n  state: 'IM002',\n  errors:\n   [ { message: '[Microsoft][ODBC Driver Manager] Data source name not found and no default driver specified',\n       state: 'IM002' },\n     { message: '[Microsoft][ODBC Driver Manager] Invalid connection string attribute',\n       state: '01S00' } ] }\n```\n\nODBC can return multiple errors for a single operation. In such cases, the first error is the main error returned, however the full list of errors is returned in the `errors` property.\n\n## Data types\n\nThe mapping between SQL data types and JavaScript data types is fairly simple. This table will help\nyou understand what SQL type to pass to `getData` to get back the correct data type, and what to pass to\n`bindParameter` to send/receive parameters.\n\n * The _SQL data type_ column refers to the type you pass to `getData` or `bindParameter`.\n * The _C type_ column is for informational purposes and specifies how the data is stored in the\nparameter/column's `buffer` and `bytesInBuffer` properties. The format of the buffer will be \ndriver and architecture-dependent, however.\n * The _SQL→JS_ column refers to the default conversion when returning results from\n`getData` (which you can work around by accessing the parameter's buffer directly) or receiving \nthe values of output parameters.\n * The _JS→SQL_ column specifies how JavaScript values are converted for storing into the\nparameter buffer _(see `FillInputBuffer` in buffer.cpp)_.\n\nSQL data type | C type | SQL→JS | JS→SQL\n--------------|--------|----------------------|---------------\n`SQL_INTEGER`, `SQL_SMALLINT`, `SQL_TINYINT` | `SQL_C_SLONG` | `Number` | Coerced to Int32\n`SQL_NUMERIC`, `SQL_DECIMAL`, `SQL_BIGINT`, `SQL_FLOAT`, `SQL_REAL`, `SQL_DOUBLE` | `SQL_C_DOUBLE` | `Number` | Coerced to Number\n`SQL_DATETIME`, `SQL_TIMESTAMP` | `SQL_C_TYPE_TIMESTAMP` | `Date` | Fails if the value is not a date (TODO: specify: in what way does it fail and how is null handled?)\n`SQL_BIT` | `SQL_C_BIT` | `true`/`false` | Coerced to boolean\n`SQL_BINARY`, `SQL_VARBINARY`, `SQL_LONGVARBINARY`¹ | `SQL_C_BINARY` | `Buffer` | None necessary\n`SQL_CHAR`, `SQL_VARCHAR`, `SQL_LONGVARCHAR`¹ | `SQL_C_WCHAR` | `String` | Coerced to a string and encoded in UTF-8\n`SQL_WCHAR`, `SQL_WVARCHAR`, `SQL_WLONGVARCHAR`¹, everything else | `SQL_C_WCHAR` | `String` | Coerced to a string and encoded in UTF-16\n\n¹ MSSQL has limitations binding `SQL_[W]LONGVARCHAR` and `SQL_LONGVARBINARY` columns, \nespecially with data-at-execution parameters. It is advised to use `SQL_[W]VARCHAR` and \n`SQL_VARBINARY` instead, with a `columnSize` of zero, because the long data types map\nto the deprecated `[n]text` and `image` data types. (Note: FreeTDS does not support zero\ncolumn sizes for `SQL_[W]VARCHAR` and `SQL_VARBINARY`, unfortunately.)\n\n## Environment\n\nAn `Environment` is a wrapper around a `SQLHENV` which is used to enumerate drivers and data \nsources, and to allocate new connections. There may be many environments allocated at any one\ntime. \n\nThe **SQLEndTran** operation is deliberately unimplemented, as it does not work when any connection has asynchronous execution enabled.\n\n### new Environment()\n\nWraps **SQLAllocHandle**. Creates a new ODBC environment handle and wraps it in a JavaScript object.\n\n### Environment.newConnection() _(synchronous)_\n\nWraps **SQLAllocHandle**. Creates a new `Connection` in the current environment. The new connection will initially be disconnected.\n\n### Environment.dataSources([type]) _(synchronous)_\n\nWrap **SQLDataSources**. Enumerates available data sources. `type` can be any of the following:\n\n * `\"user\"` lists all user DSNs.\n * `\"system\"` lists all system DSNs.\n * _(omitted)_: lists all user and system DSNs.\n\nThe data sources are returned as { server, description } pairs, e.g.\n```js\n[ { server: 'Products',\n    description: 'Microsoft ODBC for Oracle' },\n  { server: 'Customers',\n    description: 'ODBC Driver 11 for SQL Server' } ]\n```\n\nThe `server` property may be used as a DSN for `Connection.browseConnect`.\n\n### Environment.drivers()\n\nWraps **SQLDrivers**. Enumerates available ODBC drivers. These could be used to build a connection\nstring using **SQLBrowseConnect**. Example output:\n\n```js\n[ { description: 'Microsoft Access Text Driver (*.txt, *.csv)',\n    attributes:\n     [ 'UsageCount=3',\n       'APILevel=1',\n       'ConnectFunctions=YYN',\n       'DriverODBCVer=02.50',\n       'FileUsage=2',\n       'FileExtns=*.txt, *.csv',\n       'SQLLevel=0',\n       'CPTimeout=<not pooled>' ] },\n  { description: 'SQL Server Native Client 11.0',\n    attributes:\n     [ 'UsageCount=1',\n       'APILevel=2',\n       'ConnectFunctions=YYY',\n       'CPTimeout=60',\n       'DriverODBCVer=03.80',\n       'FileUsage=0',\n       'SQLLevel=1' ] },\n  { description: 'SQL Server Native Client 10.0',\n    attributes:\n     [ 'UsageCount=1',\n       'APILevel=2',\n       'ConnectFunctions=YYY',\n       'CPTimeout=60',\n       'DriverODBCVer=10.00',\n       'FileUsage=0',\n       'SQLLevel=1' ] },\n  { description: 'ODBC Driver 11 for SQL Server',\n    attributes:\n     [ 'UsageCount=1',\n       'APILevel=2',\n       'ConnectFunctions=YYY',\n       'CPTimeout=60',\n       'DriverODBCVer=03.80',\n       'FileUsage=0',\n       'SQLLevel=1' ] } ]\n```\n\nThe following information about data source names can be found on the MSDN page about [Driver Specification Subkeys](http://msdn.microsoft.com/en-us/library/ms714538%28v=vs.85%29.aspx).\n\n#### DriverODBCVer\n\nThe ODBC version of the driver. The ODBC version of the application and the driver need not match exactly &mdash; the Driver Manager will translate as necessary. See the [Compatibility Matrix](http://msdn.microsoft.com/en-us/library/ms709305%28v=vs.85%29.aspx) for more details.\n\n#### ConnectFunctions\n\nA string of three Ys or Ns. If not specified, NNN should be assumed.\n\n * The first Y or N declares support for **SQLConnect**.\n * The second Y or N declare support for **SQLDriverConnect**.\n * The third Y or N declares support for **SQLBrowseConnect**.\n \nE.g. the Microsoft Access Text Driver defined above does not support **SQLBrowseConnect**.\n\n#### FileUsage\n\nFileUsage | Means\n--- | ---\n0 | Not file based\n1 | Files are treated as tables\n2 | Files are treated as databases\n\n#### SQLLevel \n\nMy limited research has been able to determine that the following values for _SQLLevel_ are possible:\n\nSQLLevel | Means\n--- | --- \n0 | Basic SQL-92 Compliance\n1 | FIPS127-2 Transitional\n2 | SQL-92 Intermediate\n3 | SQL-92 Full\n\n### Environment.free() _(synchronous)_\n\nDestroys the environment handle.\n\n## Connection\n\nA `Connection` is a wrapper around a `SQLHDBC` which is used to connect to data sources and create\nstatements to execute. A connection may be in one of five states once allocated:\n\nState| Means\n--- | ---\nC2 | Allocated\nC3 | Connecting via `browseConnect` (need more data)\nC4 | Connected\nC5 | Connected, allocated statement\nC6 | Connected, in transaction\n\n### Connection.connect(connectionString, callback)\n\nWraps **SQLDriverConnect**. Takes a complete connection string and connects to it. If any required\nconnection string parameters are missing, the operation will fail.\n\n### Connection.browseConnect(inConnectionString, callback([err], more, outConnectionString))\n\nWraps **SQLBrowseConnect**. Iteratively connects to a data source, requesting more and more \ninformation until the connection string is complete. The ODBC driver requests more information\nby returning a new connection string, _outConnectionString_ (also referred to as the _browse \nresult connection string_) which contains information about which parameters (_keywords_) can\nbe supplied, which are required and optional, possible values (if there is a restricted choice),\nand user-friendly keyword labels.\n\n_inConnectionString_ should initially be a connection string with only the *DRIVER* or *DSN* \nkeyword set.\n\nWhen the callback is called with _more_ is set to `true`, more data is required to complete \nthe connection. There two cases: either further information is needed, or the data filled in\nin the last call was invalid (e.g. an incorrect password). The browse result connection string\nshould be parsed, and the required missing values filled in. Once the values are filled in,\n`browseConnect` should be called again with the new connection string as the _inConnectionString_\nparameter.\n\nWhen the callback is called with _more_ set to `false`, the connection is connected. The\nconnection string _outConnectionString_ is complete and can be used as a parameter to a future\ncall to `connect()`, bypassing the `browseConnect` process.\n\nIf an error (_err_) occurs, the connection is reset to the disconnected state. \n\nTo cancel a `browseConnect` operation, call `disconnect()`.\n\nThis function is not supported when connection pooling is enabled.\n\n### Connection.newStatement() _(synchronous)_\n\nCreates a new `Statement` object, which can be used for preparing statements and executing SQL directly.\n\n### Connection.disconnect(callback)\n\nDisconnects from the data source. After a successful disconnect operation, the connection handle may be used again to connect to another data source.\n\n### Connection.free() _(synchronous)_\n\nDestroys the connection handle.\n\n## Statement \n\nA `Statement` is a wrapper around a `SQLHSTMT` and can be obtained via `conn.newStatement()`. Statements represent SQL statements which can be prepared and executed with bound parameters, and can return any number of record sets (including none).\n\n### Statement.prepare(sql, callback)\n\nWraps **SQLPrepare**. Prepare the statement using given SQL, which may contain wildcards to be replaced by [bound parameters](http://msdn.microsoft.com/en-us/library/ms712522%28v=vs.85%29.aspx). If successful, the prepared statement can be executed using `Statement.execute()`.\n\n### Statement.execute(callback [err, needData, dataAvailable]) \n\nExecutes the prepared statement. \nIf there are data-at-execution parameters whose values have not yet been specified, the callback will be called \nwith _needData_ set to true. In this case, call `Statement.paramData()` to determine which input parameter is\nrequired (the order which data-at-execution parameters are requested is defined by the driver).\n\nAfter successful execution, the cursor will be positioned before the first result set. \nTo start reading the first result set (if there is any), call `Statement.fetch()`.\n\nIf there are streamed output or input/output parameters, _hasData_ may be true (provided that there are no \nwarning messages, result sets, or input parameters. If so, those must be dealt with first). In this case, call\n`Statement.paramData()` to determine which output parameter has data available (as with input parameters, the order \nin which output parameters become available is defined by the driver). If there are result sets or warning messages,\nuse `Statement.moreResults()` to retrieve streamed output parameters.\n\n### Statement.execDirect(sql, callback [err, needData, dataAvailable])\n\nWraps **SQLExecDirect**, used to execute SQL without preparing. The same as `Statement.execute()`, except there is no need to call `Statement.prepare()`. Generally, this is preferable to using `prepare` then `execute`, [unless the same statement is likely to be executed more than 3 to 5 times](http://msdn.microsoft.com/en-us/library/ms811006.aspx#code-snippet-35), in which case preparing the statement may perform better. `execDirect` accepts bound parameters.\n\nIf _dataAvailable_ is true, there are output parameters whose value is now available to read using `Statement.getData()`.\n\n### Statement.fetch(callback [err, hasData])\n\nWraps **SQLFetch**, used to fetch the next row of a result set. If successful, _hasData_ indicates whether or not the cursor is positioned on a result set.\n\n### Statement.moreResults(callback [err, hasData, hasParamData])\n\nWraps **SQLMoreResults**, used to move to the next result set. If _hasData_ is true, the cursor is positioned on a result set, and `Statement.fetch()` can be used. If _hasParamData_ is true, the last result set has been read and there are output parameters available to read using `Statement.getData()`.\n\n### Statement.paramData(callback [err, param, needData, dataAvailable])\n\nWraps **SQLParamData**, used in two circumstances.\n * When `Statement.execute()` or `Statement.execDirect()` returns _needData_ as true, the driver is requesting data for a bound parameter of type `SQL_PARAM_INPUT_STREAM` or `SQL_PARAM_INPUT_OUTPUT_STREAM`. _param_ is a `Parameter` object representing the parameter requested, and can be passed to `Statement.putData` to send the parameter in chunks. Parameters are generally not guaranteed to be requested sequentially.\n * When `Statement.execute()`, `Statement.execDirect()`, or `Statement.moreResults()` returns _dataAvailable_ as true, _param_ will be a `Parameter` representing the parameter whose data is available to read using `Statement.getData()`. Parameters are generally not guaranteed to become available sequentially.\n\n### Statement.numResultCols(callback [err, count]) \n\nWraps **SQLNumResultCols**. Calls the callback with _count_ as the number of result columns. Only valid if the cursor is positioned on a result set.\n\n### Statement.describeCol(columnNumber, callback [err, name, dataType, columnSize, decimalDigits, nullable)\n\nWraps **SQLDescribeCol**. Returns information about the column at index `columnNumber`, where 1 is the first column and 0 is the bookmark column (if bookmark columns are enabled). \n * _name_ is the name of the column.\n * _dataType_ is a numeric value representing the SQL data type of the column (e.g. `SQL_VARCHAR`, `SQL_INTEGER`, `SQL_BINARY`)\n * _columnSize_ is an integer representing the number of bytes required to store the column value. _(Note: This may not be accurate, e.g. SQL Server may return 0 for `varchar(max)` columns.)_\n * _decimalDigits_ is the number of digits after the decimal point supported by the column data type, for integral values.\n * _nullable_ is either _true_ (if the column value may be null), _false_ (if the column value cannot be null), or _undefined_ (if the nullability of the column is unknown).\n \n### Statement.getData(columnNumber, dataType, [buffer], raw, callback [err, result, totalBytes, more])\n\nWraps **SQLGetData**. Retrieves the value of a column, coerced to the value specified by \n_dataType_ (e.g. `SQL_INTEGER`). Most SQL data types can be represented as JavaScript values.\nIf the column has a long value, only a portion of the value will be fetched. \nThe size of this portion depends on the size of the _buffer_ passed in (if no buffer is \npassed in, a 64KiB buffer is created).\nTo aid in figuring out whether more data exists to retrieve, the _more_ callback parameter\nis true when there is more data to get (or when the entire length of the column is unknown,\nin which case it is assumed that there is more data to retrieve).\n\nSuccessive `getData` calls will retrieve successive chunks of the column value, \nuntil _result_ is `undefined` (if `getData` is called after the callback is called with `more`\nset to _false_).\n\nIf _dataType_ is `SQL_BINARY`, the results (or a portion of) will be placed into _buffer_.\n_buffer_ may be a `Buffer` or a `SlowBuffer`.\nIf none is passed, a new 64KiB `Buffer` is allocated. \nIf the call to `getData` does not use the entire buffer, a slice of the input buffer is returned,\notherwise the buffer itself is returned.\n\nIf _dataType_ is a character type, the results will also be placed into _buffer_ (creating a 64KiB\n`Buffer` if none is given), however the results will be converted to a `String` \n(unless _raw_ is true, see below). \n`SQL_WCHAR` and such will be treated as UTF-16, and normal character data will be treated as UTF-8.\nIf using raw mode, be aware that ODBC always writes a null terminator after character \ndata in a buffer. \nIf `totalBytes` is less than the length of the buffer passed in, the first _totalLength_ bytes \nare all character data (i.e. `buf.toString(encoding, 0, totalBytes)` is valid). \nIf `totalBytes` is greater than or equal to the length of the buffer, or undefined,\nyou should subtract the length of the null terminator (1 byte for SQL_CHAR, 2 bytes for SQL_WCHAR)\nfrom the number of bytes (or from the length of the buffer, if `totalBytes` is undefined). \n\nIf _raw_ is true, _result_ will simply be the _buffer_ which was passed in\n(or an automatically-allocated buffer, if none was given). The buffer will \nnot be sliced; it is up to the caller to use _totalBytes_ to determine what \nto do and to read the data in the correct format. (Note: _totalBytes_ may be \n`undefined` if the total length of the value is unknown. In this case the buffer will be full.)\n\n### Statement.bindParameter(index, kind, type, columnSize, decimalDigits, [value], [buffer]) _(synchronous)_\n\nWraps **SQLBindParameter**. This function binds a parameter and returns a `Parameter` object.\n\n * `index` specifies which parameter number to bind, starting from 1.\n * `kind` specifies whether the parameter is an input parameter, output parameter, or both. In fact\n it is more complex than this, which will be explained below.\n * `type` refers to the SQL type of the parameter (e.g. `SQL_VARCHAR`, `SQL_INTEGER`, `SQL_VARBINARY`)\n * `columnSize` depends on the type of parameter. For variable length types (string, buffer) it refers\n to the length of the data. For non-integral numbers, it refers to the precision. \n * `decimalDigits` usually refers to the number of decimal digits for fractional seconds in date/time\n data types, however it can also refer to the _scale_ of `SQL_NUMERIC` or `SQL_DECIMAL` data types.\n * `value`, if passed, binds the parameter with the specified value. If `null` is passed, the parameter's\n value is null, but if `undefined` is passed, it will mark the parameter as a Data At Execution parameter.\n * `buffer`, if passed, will specify the `Buffer` used to store the parameter's data. If none is passed, \n a buffer will automatically be allocated when the value is set (either by passed to `bindParameter`, or\n later calling `Parameter.set`.\n\n#### Kinds of parameters\n\nParameters can be input parameters, output parameters, or both. Output parameters can be either streamed \n(the value is retrieved in parts using `getData`) or bound (the value is automatically set when the statement\nis executed), and similarly input parameters can be streamed (sent in parts with `putData`, known as Data At \nExecution) or bound (sent as part of `execute` or `execDirect`). To specify a Data At Execution parameter, \npass `undefined` for the `value` argument of `bindParameter`.\n\n|`kind`|value|Input|Output|\n|------|-----|-----|------|\n|`SQL_PARAM_INPUT`|`undefined`|DAE||\n|`SQL_PARAM_INPUT`|a value|Bound||\n|`SQL_PARAM_INPUT_OUTPUT`|`undefined`|DAE|Bound|\n|`SQL_PARAM_INPUT_OUTPUT`|a value|Bound|Bound|\n|`SQL_PARAM_INPUT_OUTPUT_STREAM`|`undefined`|DAE|Streamed|\n|`SQL_PARAM_INPUT_OUTPUT_STREAM`|a value|Bound|Streamed|\n|`SQL_PARAM_OUTPUT`|||Bound|\n|`SQL_PARAM_OUTPUT_STREAM`|||Streamed|\n\n### Statement.setParameterName(parameterNumber, name) _(synchronous)_\n\nSets the name for a bound parameter, using **SQLSetDescField** to set the `SQL_DESC_NAME` on the input \nparameter descriptor. You might want to use this to call stored procedures with named parameters, e.g.:\n\n```js\n    var x = stmt.bindParameter(2, eos.SQL_PARAM_INPUT, eos.SQL_INTEGER, 0, 0, 27),\n\t    y = stmt.bindParameter(3, eos.SQL_PARAM_INPUT, eos.SQL_INTEGER, 0, 0, 42),\n\t    z = stmt.bindParameter(1, eos.SQL_PARAM_OUTPUT, eos.SQL_INTEGER, 0, 0)\n\n\tstmt.setParameterName(2, \"x\");\n\tstmt.setParameterName(3, \"y\");\n\tstmt.execDirect(\"{call ? = add(?, ?)}\", function(err) {\n\t\t// Use z.value if the function succeeded.\n\t});\n```\n\n### Statement.unbindParameters() _(synchronous)_\n\nUnbinds all bound parameters. (Using **SQLFreeStmt** with `SQL_RESET_PARAMS`).\n\n### Statement.putData(parameter, [buffer], [bytes], callback [err, needData, dataAvailable])\n\nWraps **SQLPutData**. Used for sending parameter values in chunks (known as _data at execution_). \n`parameter` should the `Parameter` object returned by `paramData` when another ODBC call returns\n`needData` as true.\n\nWhen writing binary columns, simply fill `parameter.buffer` with the data to send before calling\n`putData` (e.g. by calling `fs.read` and passing it the buffer).\n\nIf `buffer` is passed, it will be used instead of the `parameter.buffer`. If `bytes` is a number, it \nspecifies how many bytes of data are in the buffer; if `bytes` is null then `null` will be sent (this\nis only valid for the first chunk); if `bytes` is anything else, buffer will be assumed to be full.\n\n*TODO*: Figure out the precise semantics when **SQLPutData** returns `SQL_NEED_DATA` and when it doesn't,\nand if it's OK to send more data even if the server doesn't ask for it (I think it's OK).\n\n### Statement.bindCol(number, type, [buffer]) _(synchronous)_\n\nWraps **SQLBindCol**. Binds the parameter at index `number` (starting at 1) to an buffer of type `type`. This\nshould be an SQL type such as `SQL_INTEGER`. To see how SQL types are converted into JavaScript types, see\n[Data Types](#data-types).\n\nIf you do not pass a buffer, one will be allocated automatically. For fixed length data types such as \n`SQL_INTEGER`, it will be exactly large enough to contain the result. For variable length data types such as\n`SQL_VARCHAR`, it will be 65536 bytes. \n\nIf a Buffer is passed, and it is too small to contain a fixed-length result, an error will occur, rather than\ntruncating the value.\n\n### Statement.unbindColumn(number) _(synchronous)_\n\nUnbind the column number `number`. (Using **SQLBindCol** with a null buffer).\n\n### Statement.unbindColumns() _(synchronous)_\n\nUnbinds all bound columns. (Using **SQLFreeStmt** with `SQL_UNBIND`).\n\n### Statement.closeCursor([throwOnNoCursor = false]) _(synchronous)_\n\nWraps **SQLCloseCursor**. Closes the current cursor associated with a statement (i.e. makes the statement\nready for another `execute` call). If `throwOnNoCursor` is true (which it isn't by default), the call will\nthrow an exception if there is not currently an active result set.\n\nEven if `throwOnNoCursor` is not set, `closeCursor` can still throw an exception, so be careful. An examples\nof this are the `08S01` SQLSTATE (Communication link failure). If this error is thrown, the only option is\nto free the `Statement` and disconnect the `Connection`.\n\n### Statement.free() _(synchronous)_\n\nDestroys the statement handle.\n","starsCount":3,"created":"2014-04-09T19:27:44.671Z","modified":"2015-01-16T16:40:20.250Z","lastPublisher":{"name":"lee-houghton","email":"lee@theconnectgroup.net"},"owners":[{"name":"lee-houghton","email":"lee@theconnectgroup.net"}],"other":{"_attachments":{},"_from":".","_id":"eos","_npmUser":{"name":"lee-houghton","email":"lee@theconnectgroup.net"},"_npmVersion":"1.4.23","_rev":"1-4588421953c45d8a31831b12a65e24de","_shasum":"af531a6feaa6c952f403e72e5defd54e00f6e6e4","author":{"name":"lee@asztal.net"},"directories":{},"dist-tags":{"latest":"0.4.1"},"dist":{"shasum":"af531a6feaa6c952f403e72e5defd54e00f6e6e4","tarball":"http://registry.npmjs.org/eos/-/eos-0.4.1.tgz"},"maintainers":[{"name":"lee-houghton","email":"lee@theconnectgroup.net"}],"readmeFilename":"README.md","time":{"modified":"2015-01-16T16:40:20.250Z","created":"2014-04-09T19:27:44.671Z","0.1.0":"2014-04-09T19:27:46.912Z","0.2.0":"2014-06-20T21:57:12.985Z","0.3.0":"2014-09-08T13:25:44.840Z","0.3.1":"2014-09-10T11:32:11.440Z","0.3.2":"2014-10-24T22:35:36.860Z","0.4.0":"2014-12-04T21:37:22.360Z","0.4.1":"2015-01-16T16:40:20.250Z"},"users":{"lee-houghton":true,"goliatone":true,"marciojbraga":true}}}