{"name":"ldap-client","description":"LDAP Binding for node.js","homepage":"https://github.com/jeremycx/node-LDAP","repository":"https://github.com/jeremycx/node-LDAP","main":"index.js","license":"MIT","scripts":{"configure":"node-gyp configure","build":"node-gyp rebuild","test":"mocha","install":"node-gyp rebuild"},"devDependencies":{"jshint":"^2.8.0","mocha":"^2.2.5"},"dependencies":{"bindings":"^1.2.1","lodash":"^3.10.1","nan":"^2.0.5","node-gyp":""},"engines":{"node":">= 0.8.0"},"version":"3.1.3","gypfile":true,"gitHead":"49bf1930378063e295ba799bf2a729c74ba4211c","versions":[{"number":"2.0.4","date":"2015-10-20T23:43:23.736Z"},{"number":"2.0.5","date":"2015-10-20T23:52:43.935Z"},{"number":"2.0.6","date":"2015-10-21T00:05:21.921Z"},{"number":"2.0.7","date":"2015-10-21T23:52:14.881Z"},{"number":"3.0.0","date":"2015-11-05T18:49:59.317Z"},{"number":"3.0.1","date":"2015-11-09T18:48:43.336Z"},{"number":"3.0.2","date":"2015-11-12T17:50:48.271Z"},{"number":"3.1.0","date":"2015-11-17T21:27:33.877Z"},{"number":"3.1.3","date":"2016-03-02T22:07:20.622Z"}],"readme":"ldap-client 3.X.X\n===============\n\nOpenLDAP client bindings for Node.js. Requires libraries from\nhttp://www.openldap.org installed.\n\nNow uses Nan to ensure it will build for all version of Node.js.\n\n***3.X is an API-breaking release***, but it should be easy to convert to the new API.\n\nNOTE: The module has been renamed to `ldap-client` as `npm` no longer accepts capital letters.\n\nContributing\n===\n\nAny and all patches and pull requests are certainly welcome.\n\nThanks to:\n===\n* Petr BÄ›han\n* YANG Xudong\n* Victor Powell\n* Many other contributors\n\nDependencies\n===\n\nNode >= 0.8\n\nInstall\n=======\n\nYou must ensure you have the latest OpenLDAP client libraries\ninstalled from http://www.openldap.org\n\nTo install the latest release from npm:\n\n    npm install --save ldap-client\n\nYou will also require the LDAP Development Libraries (on Ubuntu, `sudo apt-get install libldap2-dev`)\n\nReconnection\n==========\nIf the connection fails during operation, the client library will handle the reconnection, calling the function specified in the connect option. This callback is a good place to put bind()s and other things you want to always be in place.\n\nYou must close() the instance to stop the reconnect behavior.\n\nDuring long-running operation, you should be prepared to handle errors robustly - there is no telling when the underlying driver will be in the process of automatically reconnecting. `ldap.search()` and friends will happily return a `Timeout` or `Can't contact LDAP server` error if the server has temporarily gone away. So, though you **may** want to implement your app in the `new LDAP()` callback, it's perfectly acceptable (and maybe even recommended) to ignore the ready callback in `new LDAP()` and proceed anyway, knowing the library will eventually connect when it is able to.\n\nAPI\n===\n\n    new LDAP(options, readyCallback);\n\nOptions are provided as a JS object:\n\n```js\nvar LDAP = require('ldap-client');\n\nvar ldap = new LDAP({\n    uri:             'ldap://server',   // string\n    validatecert:    false,             // Verify server certificate\n    connecttimeout:  -1,                // seconds, default is -1 (infinite timeout), connect timeout\n    base:            'dc=com',          // default base for all future searches\n    attrs:           '*',               // default attribute list for future searches\n    filter:          '(objectClass=*)', // default filter for all future searches\n    scope:           LDAP.SUBTREE,      // default scope for all future searches\n    connect:         function(),        // optional function to call when connect/reconnect occurs\n    disconnect:      function(),        // optional function to call when disconnect occurs        \n}, function(err) {\n    // connected and ready    \n});\n\n```\n\nThe connect handler is called on initial connect as well as on reconnect, so this function is a really good place to do a bind() or any other things you want to set up for every connection.\n\n```js\nvar ldap = new LDAP({\n    uri: 'ldap://server',\n    connect: function() {\n        ldap.bind({\n            binddn: 'cn=admin,dc=com',\n            password: 'supersecret'\n        }, function(err) {\n           ...\n        });\n    }\n}\n```\n\nTLS\n===\nTLS can be used via the ldaps:// protocol string in the URI attribute on instantiation. If you want to eschew server certificate checking (if you have a self-signed cserver certificate, for example), you can set the `verifycert` attribute to `LDAP.LDAP_OPT_X_TLS_NEVER`, or one of the following values:\n\n```js\nvar LDAP=require('ldap-client');\n\nLDAP.LDAP_OPT_X_TLS_NEVER  = 0;\nLDAP.LDAP_OPT_X_TLS_HARD   = 1;\nLDAP.LDAP_OPT_X_TLS_DEMAND = 2;\nLDAP.LDAP_OPT_X_TLS_ALLOW  = 3;\nLDAP.LDAP_OPT_X_TLS_TRY    = 4;\n```\n\nldap.bind()\n===\nCalling open automatically does an anonymous bind to check to make\nsure the connection is actually open. If you call `bind()`, you\nwill upgrade the existing anonymous bind.\n\n    ldap.bind(bind_options, function(err));\n\nOptions are binddn and password:\n\n```js\nbind_options = {\n    binddn: '',\n    password: ''\n}\n```\nAliased to `ldap.simplebind()` for backward compatibility.\n\n\nldap.search()\n===\n    ldap.search(search_options, function(err, data));\n\nOptions are provided as a JS object:\n\n```js\nsearch_options = {\n    base: 'dc=com',\n    scope: LDAP.SUBTREE,\n    filter: '(objectClass=*)',\n    attrs: '*'\n}\n```\n\nIf one omits any of the above options, then sensible defaults will be used. One can also provide search defaults as part of instantiation.\n\nScopes are specified as one of the following integers:\n\n```js\nvar LDAP=require('ldap-client');\n\nLDAP.BASE = 0;\nLDAP.ONELEVEL = 1;\nLDAP.SUBTREE = 2;\nLDAP.SUBORDINATE = 3;\nLDAP.DEFAULT = -1;\n```\n\nList of attributes you want is passed as simple string - join their names\nwith space if you need more ('objectGUID sAMAccountName cname' is example of\nvalid attrs filter). '\\*' is also accepted.\n\nResults are returned as an array of zero or more objects. Each object\nhas attributes named after the LDAP attributes in the found\nrecord(s). Each attribute contains an array of values for that\nattribute (even if the attribute is single-valued - having to check typeof()\nbefore you can act on /anything/ is a pet peeve of\nmine). The exception to this rule is the 'dn' attribute - this is\nalways a single-valued string.\n\nExample of search result:\n\n```js\n[ { gidNumber: [ '2000' ],\n  objectClass: [ 'posixAccount', 'top', 'account' ],\n  uidNumber: [ '3214' ],\n  uid: [ 'fred' ],\n  homeDirectory: [ '/home/fred' ],\n  cn: [ 'fred' ],\n  dn: 'cn=fred,dc=ssimicro,dc=com' } ]\n```\n\nAttributes themselves are usually returned as strings. There is a list of known\nbinary attribute names hardcoded in C++ binding sources. Those are always\nreturned as Buffers, but the list is incomplete so far. \nPaged Search Results\n===\nNB: Paged search results are not currently implemented.\n\nLDAP servers are usually limited in how many items they are willing to return -\n1024 or 4096 are some typical values. For larger LDAP directories, you need to\neither partition your results with filter, or use paged search. To get\na paged search, add the following attributes to your search request:\n\n```js\nsearch_options = {\n    base: '',\n    scope: '',\n    filter: '',\n    attrs: '',\n    pagesize: n\n}\n```\n\nThe callback will be called with a new parameter: cookie. Pass this\ncookie back in subsequent searches to get the next page of results:\n\n```js\nsearch_options = {\n    base: '',\n    scope: '',\n    filter: '',\n    attrs: '',\n    pagesize: n,\n    cookie: cookie\n}\n```\n\nRootDSE\n===\n\nAs of version 1.2.0 you can also read the rootDSE entry of an ldap server.\nTo do so, simply issue a read request with base set to an empty string:\n\n```js\nsearch_options = {\n  base: '',\n  scope: Connection.BASE,\n  attrs: '+'\n  // ... other options as necessary\n}\n```\n\nldap.findandbind()\n===\n\n    ldap.findandbind(fb_options, function(err, data))\n\nOptions are exactly like the search options, with the addition of a\n\"password\" attribute:\n\n```js\nfb_options = {\n    base: '',\n    filter: '',\n    scope: '',\n    attrs: '',\n    password: ''\n}\n```\n\nCalls the callback with the record it authenticated against as the\n`data` argument.\n\n`findandbind()` does two convenient things: It searches LDAP for\na record that matches your search filter, and if one (and only one)\nresult is retured, it then uses a second connection with the same\noptions as the primary connection to attempt to authenticate to\nLDAP as the user found in the first step.\n\nThe idea here is to bind your main LDAP instance with an \"admin-like\"\naccount that has the permissions to search. Your (hidden) secondary\nconnection will be used only for authenticating users.\n\nIn contrast, the `bind()` method will, if successful, change the\nauthentication on the primary connection.\n\n```js\nldap.bind({\n    binddn: 'cn=admin,dc=com',\n    password: 'supersecret'\n}, function(err, data) {\n   if (err) {\n       ...\n   }\n   // now we're authenticated as admin on the main connection\n   // and thus have the correct permissions for search\n   \n   ldap.findandbind({\n       filter: '(&(username=johndoe)(status=enabled))',\n       attrs: 'username homeDirectory'\n   }, function(err, data) {\n      if (err) {\n          ...\n      }\n      // our main connection is still cn=admin\n      // but there's a hidden connection bound\n      // as \"johndoe\"\n      console.log(data[0].homeDirectory[0]);\n   }\n}\n\n```\n\nIf you ensure that the \"admin\" user (or whatever you bind as for\nthe main connection) can not READ the password field, then\npasswords will never leave the LDAP server -- all authentication\nis done my the LDAP server itself.\n\n\nldap.add()\n===\n\n    ldap.add(dn, [attrs], function(err))\n\ndn is the full DN of the record you want to add, attrs to be provided\nas follows:\n\n```js\nvar attrs = [\n    { attr: 'objectClass',  vals: [ 'organizationalPerson', 'person', 'top' ] },\n    { attr: 'sn',           vals: [ 'Smith' ] },\n    { attr: 'badattr',      vals: [ 'Fried' ] }\n]\n```\n\nldap.modify()\n===\n\n    ldap.modify(dn, [ changes ], function(err))\n\nModifies the provided dn as per the changes array provided. Ops are\none of \"add\", \"delete\" or \"replace\".\n\n```js\nvar changes = [\n    { op: 'add',\n      attr: 'title',\n      vals: [ 'King of Callbacks' ]\n    }\n]\n```\n\nldap.rename()\n===\n\n    ldap.rename(dn, newrdn, function(err))\n\nWill rename the entry to the new RDN provided.\n\nExample:\n\n```js\nldap.rename('cn=name,dc=example,dc=com', 'cn=newname')\n```\n\nldap.remove()\n===\n\n    ldap.remove(dn, function(err))\n\nDeletes an entry.\n\nExample:\n\n```js\nldap.remove('cn=name,dc=example,dc=com', function(err) {\n  if (err) {\n    // Could not delete entry\n  }\n});\n```\n\nEscaping\n===\nYes, Virginia, there's such a thing as LDAP injection attacks.\n\nThere are a few helper functions to ensure you are escaping your input properly.\n\n**escapefn(type, template)**\nReturns a function that escapes the provided parameters and inserts them into the provided template:\n\n```js\nvar LDAP = require('ldap-client');\nvar userSearch = LDAP.escapefn('filter', \n    '(&(objectClass=%s)(cn=%s))');\n\n...\nldap.search({\n    filter: userSearch('posixUser', username),\n    scope: LDAP.SUBTREE\n}, function(err, data) {\n    ...\n});\n```\nSince the escaping rules are different for DNs vs search filters, `type` should be one of `'filter'` or `'dn'`.\n\nTo escape a single string, `LDAP.stringEscapeFilter`:\n\n```js\nvar LDAP=require('ldap-client');\nvar user = \"John O'Doe\";\n\nLDAP.stringEscapeFilter('(username=' + user + ')');\n// ==> '(username=John O\\'Doe)'\n```\n\nNote there is no function for string escaping a DN - DN escaping has special rules for escaping the beginning and end of values in the DN, so the best way to safely escape DNs is to use the `escapefn` with a template:\n\n```js\nvar LDAP = require('ldap-client');\nvar escapeDN = LDAP.escapefn('dn', \n    'cn=%s,dc=sample,dc=com');\n\n...\nvar safeDN = escapeDN(\" O'Doe\");\n// => \"cn=\\ O\\'Doe,dc=sample,dc=com\"\n\n```\n\nBugs\n===\nDomain errors don't work properly. Domains are deprecated as of node 4,\nso I don't think I'm going to track it down. If you need domain handling,\nlet me know.\n\nTODO Items\n===\nBasically, these are features I don't really need myself.\n\n* Paged search results\n* Filter escaping\n\nNotes on Paged Results\n===\nTo properly implement paged search results, we need to create another C++ class that represents the page cookie. This class should be instantiated to store the pointer to the ber cookie, and properly destroy itself when it goes out of scope. This object should be returned as part of the search results. \n\n[myobject.cc](https://github.com/nodejs/node-addon-examples/blob/master/8_passing_wrapped/nan/myobject.cc) seems to be a pretty good template.\n","starsCount":1,"created":"2015-10-20T23:43:23.736Z","modified":"2017-04-10T20:34:07.871Z","lastPublisher":{"name":"jeremycx","email":"jeremyc@ssimicro.com"},"owners":[{"name":"jeremycx","email":"jeremyc@ssimicro.com"}],"other":{"_attachments":{},"_from":".","_id":"ldap-client","_nodeVersion":"0.10.36","_npmOperationalInternal":{"host":"packages-13-west.internal.npmjs.com","tmp":"tmp/ldap-client-3.1.3.tgz_1456956439811_0.09225471154786646"},"_npmUser":{"name":"jeremycx","email":"jeremyc@ssimicro.com"},"_npmVersion":"2.7.1","_rev":"2-ee83d11c5bd86b1fce0682764b2648b7","_shasum":"a2f9fd6971f8d79764138dc6b818e923ffa6595e","author":{"name":"Jeremy Childs","email":"jeremyc@ssimicro.com"},"bugs":{"url":"https://github.com/jeremycx/node-LDAP/issues"},"directories":{},"dist-tags":{"latest":"3.1.3"},"dist":{"shasum":"a2f9fd6971f8d79764138dc6b818e923ffa6595e","tarball":"http://registry.npmjs.org/ldap-client/-/ldap-client-3.1.3.tgz"},"maintainers":[{"name":"jeremycx","email":"jeremyc@ssimicro.com"}],"readmeFilename":"README.md","time":{"modified":"2017-04-10T20:34:07.871Z","created":"2015-10-20T23:43:23.736Z","2.0.4":"2015-10-20T23:43:23.736Z","2.0.5":"2015-10-20T23:52:43.935Z","2.0.6":"2015-10-21T00:05:21.921Z","2.0.7":"2015-10-21T23:52:14.881Z","3.0.0":"2015-11-05T18:49:59.317Z","3.0.1":"2015-11-09T18:48:43.336Z","3.0.2":"2015-11-12T17:50:48.271Z","3.1.0":"2015-11-17T21:27:33.877Z","3.1.3":"2016-03-02T22:07:20.622Z"},"users":{"claudio76":true}}}