{"name":"bbuf","description":"Dynamic bytes buffer for nodejs/iojs.","version":"0.0.4","engines":{"iojs":">= 1.0.4","node":">= 0.10.30"},"dependencies":{"bindings":"*","nan":"1.8.2"},"devDependencies":{"mocha":"*"},"repository":"https://github.com/hit9/bbuf","scripts":{"test":"mocha test.js","install":"node-gyp rebuild"},"licenses":"MIT","gypfile":true,"gitHead":"66054dd1a47f958a08242a16bc692b1e6187f934","homepage":"https://github.com/hit9/bbuf","versions":[{"number":"0.0.2","date":"2015-04-28T18:26:33.744Z"},{"number":"0.0.3","date":"2015-05-01T15:22:47.146Z"},{"number":"0.0.4","date":"2015-05-02T04:53:34.092Z"}],"readme":"bbuf\n====\n\nDynamic bytes buffer for nodejs/iojs, a bit like the `bytearray` in Python.\n\n[![Build Status](https://travis-ci.org/hit9/bbuf.svg)](https://travis-ci.org/hit9/bbuf)\n\n```\n+------- cap -------+\n+------- size --+   | => buf (uint8 array)\n|UNIT|UNIT|UNIT|UNIT|\n```\n\nReasons to start this project:\n\n* Want a dynamic bytes buffer, but node's Buffer requires fixed size.\n* Don't want to hold multiple copies in memory via `Buffer.concat`, `s + s` etc.\n\nExample\n-------\n\n```javascript\nvar Buf = require('bbuf').Buf;\n\nvar buf = new Buf(4); // created with buf unit <bbuf [0]>\n\nbuf.put('abc');      // 3    buf => <bbuf [3] 61 62 63>\nbuf.put('123');      // 3    buf => <bbuf [6] 61 62 63 31 32 33>\nbuf.pop(4);          // 4    buf => <bbuf [2] 61 62>\nbuf.length           // 2\nbuf.cap              // 8\nbuf.toString()       // 'ab'\nbuf.clear()          // 2    buf => <bbuf [0]>\nbuf.cap              // 0\n```\n\nAPI Refs\n--------\n\n### new Buf(BUF_UNIT)\n\nCreate a buf instance by buffer unit size.\n\n### Buf.isBuf(object)\n\nTest if an object is a Buf instance.\n\n### buf.put(string/buffer/buf/byte/array)\n\nPut string/buffer/buf/byte/bytes-array object to buf, return bytes put. O(k)\n\n```js\nbuf.put('abcd'); // 4\nbuf.put(buf);\nbuf.put(new Buffer('abcd'));\nbuf.put(97);\nbuf.put([98, 99, 100]);\n// buf.toString() => 'abcdabcdabcdabcd'\n```\n\n### buf.pop(size)\n\nPop buf on the right end, return bytes poped. O(1)\n\n### buf.length\n\nGet/Set buf size.\n\n```js\nbuf.put('abcd'); // buf => <bbuf [4] 61 62 63 64>\nbuf.length  // 4\nbuf.length = 5;  // buf => <bbuf [5] 61 62 63 64 20> , appended a ' '\nbuf.length = 2;  // buf => <bbuf [2] 61 62>  // truncate\n```\n\n### buf.cap\n\nGet buf capacity.\n\n### buf.grow(size)\n\nGrow buf capacity to given size.\n\n(We dont need to grow size manually to put data onto buf,\n but this method can reduce the memory allocation times if the\n result's bytes size is known to us).\n\n### buf.toString()\n\nReturn string from buf.\n\n```js\nbuf.put('abcd');\nbuf.toString();  // 'abcd'\n```\n\n### buf.clear()\n\nClear buf. O(!)\n\n```js\nbuf.put('abcd');\nbuf.clear();\nbuf.length   // 0\nbuf.cap      // 0\n```\n\n### buf.copy()\n\nCopy buf into a new buf instance. O(n)\n\n```js\nbuf.put('abcd');  // buf => <bbuf [4] 61 62 63 64>\nbuf.copy();  // <bbuf [4] 61 62 63 64>\n```\n\n### buf[idx], buf.charAt(idx)\n\nIndex accessors for a buf instance. all O(1)\n\n- buf[idx] - Get byte (uint8 value) at index.\n- buf[idx] = 'c' - Set byte at index by a single byte char, or by a byte.\n- buf.charAt(idx) - Get byte as string at index.\n\n```js\nbuf.put('abced');\nbuf[0];   // 97\nbuf[0] = 'c';  // 'c'\nbuf[2] = 97;  // 97\nbuf.toString(); // 'cbaed'\nbuf.charAt(0); // 'c'\n```\n\n### buf.slice(begin[, end])\n\nSlice buf into a new buf instance. O(k)\n\n```js\nbuf.put('abcd');  // 4. buf => <bbuf [4] 61 62 63 64>\nbuf.slice(0)  // <bbuf [4] 61 62 63 64>\nbuf.slice(-1)  // <bbuf [1] 64>\nbuf.slice(1, 3)  // <bbuf [2] 62 63>\n```\n\nDon't use `String.prototype.slice.apply(buf, [begin, end])`,\nbecause we are playing with `bytes` but not `chars`:\n\n```js\nbuf.put('你好');\nString.prototype.slice.apply(buf, [0, 1]);  // '你'\nbuf.charAt(0) !== '你';  // true\n```\n\nBut you can use `Array.prototype.slice` to slice bytes\nfrom `buf`:\n\n```js\nbuf.slice(0, 1).bytes();  // [ 228 ]\n[].slice.apply(buf, [0, 1]);  // [ 228 ]\n```\n\n### buf.bytes()\n\nGet bytes array. O(n)\n\n```js\nbuf.put('abcd');  // 4\nbuf.bytes();  // [ 97, 98, 99, 100  ]\n```\n\n### buf.cmp/equals(string/buffer/buf)\n\nCompare string/buffer/buf with this buf, similar to C's `strcmp`. O(min(m, n))\n\n```js\nbuf.put('cde');\nbuf.cmp('abc');  // 2\nbuf.cmp('cde');  // 0\nbuf.cmp('mnp');  // -10\nbuf.equals('cde');  // true\nbuf.equals(buf.copy());  // true\n```\n\n### buf.indexOf(string/buffer/buf[, startIndex])\n\nFind the first index of string/buffer/buf in this buf. (Boyer-Moore algorithm)\n\n```js\nbuf.put('abcde');\nbuf.indexOf('ab');  // 0\nbuf.indexOf('what');  // -1\nbuf.indexOf('d', 1);  // 3\nbuf.indexOf(98);  // 1\n```\n\nDon't use `String.prototype.indexOf` for `buf`, if you are trying to find the `byte index`\ninstead of the `char index` (e.g. to parse bytes from a socket):\n\n```js\nbuf.put('你好');\nbuf.indexOf('好');  // 3\nString.prototype.indexOf.call(buf, '好');  // 1\n```\n\nBut you can use `Array.prototype.indexOf` to search a single byte:\n\n```js\n[].indexOf.apply(buf, [228])  // 0\n```\n\n### buf.isSpace()\n\nTest if the buf is only maked up of spaces . (`' \\t\\n\\r\\v\\f'`) O(n)\n\n### buf.startsWith/endsWith(string/buffer/buf)\n\nTest if the buf starts/ends with `string/buffer/buf`. (Note that we are talking about bytes, not chars). O(min(n, k))\n\n```js\nbuf.put('abcde');\nbuf.startsWith('ab');  // true\nbuf.endsWith('de');   // true\n```\n\nBenchmark\n---------\n\nSimple [benchmark](bench.js) between `v8 string + operator`, `v8 array join`,\n`node buffer.write` and `bbuf.put`:\n\n```\nv8 string + operator:    1000000 op in 202 ms   => 4950495ops heapUsed: 76034848\nv8 array join:           1000000 op in 379 ms   => 2638522.4ops heapUsed: 71710880\nnode buf fixed size:     1000000 op in 355 ms   => 2816901.4ops heapUsed: 14669800\nbbuf dynamic size:       1000000 op in 371 ms   => 2695417.8ops heapUsed: 36397128\n```\n\nLicense\n--------\n\nMIT. (c) Chao Wang <hit9@icloud.com>\n","created":"2015-04-28T18:26:33.744Z","modified":"2015-05-02T04:53:34.092Z","lastPublisher":{"name":"hit9","email":"hit9@icloud.com"},"owners":[{"name":"hit9","email":"hit9@icloud.com"}],"other":{"_attachments":{},"_from":".","_id":"bbuf","_nodeVersion":"0.12.2","_npmUser":{"name":"hit9","email":"hit9@icloud.com"},"_npmVersion":"2.7.4","_rev":"1-d0737923a70faab09aaed68d3da90e6d","_shasum":"9fae01d82bb43745c2e76780fec090085b93884c","author":{"name":"hit9","email":"hit9@icloud.com"},"bugs":{"url":"https://github.com/hit9/bbuf/issues"},"directories":{},"dist-tags":{"latest":"0.0.4"},"dist":{"shasum":"9fae01d82bb43745c2e76780fec090085b93884c","tarball":"http://registry.npmjs.org/bbuf/-/bbuf-0.0.4.tgz"},"maintainers":[{"name":"hit9","email":"hit9@icloud.com"}],"readmeFilename":"README.md","time":{"modified":"2015-05-02T04:53:34.092Z","created":"2015-04-28T18:26:33.744Z","0.0.2":"2015-04-28T18:26:33.744Z","0.0.3":"2015-05-01T15:22:47.146Z","0.0.4":"2015-05-02T04:53:34.092Z"}}}