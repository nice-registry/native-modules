{"name":"i2c-bus","version":"1.2.2","description":"I2C serial bus access with Node.js","main":"i2c-bus.js","scripts":{"test":"echo \"Tests can only be run manually from the command line.\" && exit 1","install":"node-gyp rebuild"},"repository":"https://github.com/fivdi/i2c-bus","engines":{"node":">=0.10.0"},"dependencies":{"bindings":"~1.2.1","nan":"~2.6.2"},"devDependencies":{"async":"~2.1.4","lodash":"~4.17.4"},"keywords":["i2c","raspberry","raspi","rpi","pi","edison","beaglebone","smbus","linux"],"license":"MIT","gypfile":true,"gitHead":"14f91322f43fedf30a869a09ec20e6c1a481e6b9","homepage":"https://github.com/fivdi/i2c-bus#readme","versions":[{"number":"0.1.0","date":"2014-12-09T22:30:31.772Z"},{"number":"0.2.0","date":"2014-12-13T07:01:19.310Z"},{"number":"0.3.0","date":"2014-12-13T07:15:47.945Z"},{"number":"0.4.0","date":"2014-12-13T11:27:20.428Z"},{"number":"0.5.0","date":"2014-12-14T00:50:47.193Z"},{"number":"0.6.0","date":"2014-12-15T18:22:48.218Z"},{"number":"0.7.0","date":"2014-12-16T12:48:01.403Z"},{"number":"0.8.0","date":"2014-12-19T22:21:24.523Z"},{"number":"0.9.0","date":"2014-12-22T11:07:56.086Z"},{"number":"0.10.0","date":"2015-01-24T10:17:33.564Z"},{"number":"0.11.0","date":"2015-02-01T13:29:52.660Z"},{"number":"0.11.1","date":"2015-03-28T00:36:40.541Z"},{"number":"0.11.2","date":"2015-05-07T19:34:44.288Z"},{"number":"0.11.3","date":"2015-09-02T20:38:42.428Z"},{"number":"0.12.0","date":"2015-10-06T21:06:45.811Z"},{"number":"1.0.0","date":"2015-10-10T15:39:39.656Z"},{"number":"1.0.1","date":"2015-12-05T09:24:32.247Z"},{"number":"1.0.2","date":"2016-01-29T20:16:45.419Z"},{"number":"1.0.3","date":"2016-04-27T21:33:44.596Z"},{"number":"1.1.0","date":"2016-05-23T17:57:34.341Z"},{"number":"1.1.1","date":"2016-07-22T20:17:59.687Z"},{"number":"1.1.2","date":"2016-10-05T20:27:56.564Z"},{"number":"1.2.0","date":"2017-01-06T18:01:09.455Z"},{"number":"1.2.1","date":"2017-02-12T17:01:05.321Z"},{"number":"1.2.2","date":"2017-05-01T06:53:39.046Z"}],"readme":"## i2c-bus\n\nI2C serial bus access with **Node.js** on Linux boards like the Raspberry Pi,\nC.H.I.P., BeagleBone or Intel Edison. All methods have asynchronous and\nsynchronous forms.\n\ni2c-bus supports Node.js v0.10, v0.12, v4, v5, v6 and v7.\n\n## Installation\n\n    $ npm install i2c-bus\n\nIf you're using Node.js v4 or higher and seeing lots of compile errors when\ninstalling i2c-bus, it's very likely that gcc/g++ 4.8 or higher are not\ninstalled. See\n[Node.js v4 and native addons](https://github.com/fivdi/onoff/wiki/Node.js-v4-and-native-addons)\nfor details.\n\nIf you're using Node.js v0.10.29 on the Raspberry Pi and seeing a compile\nerror saying that `‘REPLACE_INVALID_UTF8’ is not a member of ‘v8::String’`\nsee [Node.js v0.10.29 and native addons on the Raspberry Pi](https://github.com/fivdi/onoff/wiki/Node.js-v0.10.29-and-native-addons-on-the-Raspberry-Pi).\n\nIf you're using Node.js v0.10.29 on the BeagleBone Black and seeing a compile\nerror saying that `‘REPLACE_INVALID_UTF8’ is not a member of ‘v8::String’`\nsee [Node.js v0.10.29 and native addons on the BeagleBone Black](https://github.com/fivdi/onoff/wiki/Node.js-v0.10.29-and-native-addons-on-the-BeagleBone-Black).\n\nThe way in which I2C is configured varies from board to board. Sometimes no\nconfiguraton is required, but sometimes it is:\n\n* [Configuring I2C on the Raspberry Pi](https://github.com/fivdi/i2c-bus/blob/master/doc/raspberry-pi-i2c.md)\n* [Configuring I2C on the Intel Edison Arduino Base Board](https://github.com/fivdi/i2c-bus/blob/master/doc/edison-adruino-base-board-i2c.md)\n\n## Example Temperature Sensor Circuits\n\nSome of the examples programs use a\n[DS1621 temperature sensor](http://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/DS1621.html)\nto show how the i2c-bus package functions. \n\n**DS1621 temperature sensor connected to a Raspberry Pi**\n<img src=\"https://github.com/fivdi/i2c-bus/raw/master/example/ds1621-pi.png\">\n\n**DS1621 temperature sensor connected to a BeagleBone Black**\n<img src=\"https://github.com/fivdi/i2c-bus/raw/master/example/ds1621-bb.png\">\n\n## Example 1 - Determine Temperature Synchronously\n\nDetermine the temperature with a DS1621 temperature sensor Synchronously.\n\n```js\nvar i2c = require('i2c-bus'),\n  i2c1 = i2c.openSync(1);\n\nvar DS1621_ADDR = 0x48,\n  CMD_ACCESS_CONFIG = 0xac,\n  CMD_READ_TEMP = 0xaa,\n  CMD_START_CONVERT = 0xee;\n\nfunction toCelsius(rawTemp) {\n  var halfDegrees = ((rawTemp & 0xff) << 1) + (rawTemp >> 15);\n\n  if ((halfDegrees & 0x100) === 0) {\n    return halfDegrees / 2; // Temp +ve\n  }\n\n  return -((~halfDegrees & 0xff) / 2); // Temp -ve\n}\n\n(function () {\n  var rawTemp;\n\n  // Enter one shot mode (this is a non volatile setting)\n  i2c1.writeByteSync(DS1621_ADDR, CMD_ACCESS_CONFIG, 0x01);\n\n  // Wait while non volatile memory busy\n  while (i2c1.readByteSync(DS1621_ADDR, CMD_ACCESS_CONFIG) & 0x10) {\n  }\n\n  // Start temperature conversion\n  i2c1.sendByteSync(DS1621_ADDR, CMD_START_CONVERT);\n\n  // Wait for temperature conversion to complete\n  while ((i2c1.readByteSync(DS1621_ADDR, CMD_ACCESS_CONFIG) & 0x80) === 0) {\n  }\n\n  // Display temperature\n  rawTemp = i2c1.readWordSync(DS1621_ADDR, CMD_READ_TEMP);\n  console.log('temp: ' + toCelsius(rawTemp));\n\n  i2c1.closeSync();\n}());\n```\n\n## Example 2 - Determine Temperature Asynchronously\n\nDetermine the temperature with a DS1621 temperature sensor Asynchronously.\nExample 2 does exactly the same thing as example 1, but uses the asynchronous\nrather than the synchronous API.\n\n```js\nvar async = require('async'),\n  i2c = require('i2c-bus'),\n  i2c1;\n\nvar DS1621_ADDR = 0x48,\n  CMD_ACCESS_CONFIG = 0xac,\n  CMD_READ_TEMP = 0xaa,\n  CMD_START_CONVERT = 0xee;\n\nfunction toCelsius(rawTemp) {\n  var halfDegrees = ((rawTemp & 0xff) << 1) + (rawTemp >> 15);\n\n  if ((halfDegrees & 0x100) === 0) {\n    return halfDegrees / 2; // Temp +ve\n  }\n\n  return -((~halfDegrees & 0xff) / 2); // Temp -ve\n}\n\n(function () {\n  async.series([\n    function (cb) {\n      i2c1 = i2c.open(1, cb);\n    },\n    function (cb) {\n      // Enter one shot mode (this is a non volatile setting)\n      i2c1.writeByte(DS1621_ADDR, CMD_ACCESS_CONFIG, 0x01, cb);\n    },\n    function (cb) {\n      // Wait while non volatile memory busy\n      (function read() {\n        i2c1.readByte(DS1621_ADDR, CMD_ACCESS_CONFIG, function (err, config) {\n          if (err) return cb(err);\n          if (config & 0x10) return read();\n          cb(null);\n        });\n      }());\n    },\n    function (cb) {\n      // Start temperature conversion\n      i2c1.sendByte(DS1621_ADDR, CMD_START_CONVERT, cb);\n    },\n    function (cb) {\n      // Wait for temperature conversion to complete\n      (function read() {\n        i2c1.readByte(DS1621_ADDR, CMD_ACCESS_CONFIG, function (err, config) {\n          if (err) return cb(err);\n          if ((config & 0x80) === 0) return read();\n          cb(null);\n        });\n      }());\n    },\n    function (cb) {\n      // Display temperature\n      i2c1.readWord(DS1621_ADDR, CMD_READ_TEMP, function (err, rawTemp) {\n        if (err) return cb(err);\n        console.log('temp: ' + toCelsius(rawTemp));\n        cb(null);\n      });\n    },\n    function (cb) {\n      i2c1.close(cb);\n    }\n  ], function (err) {\n    if (err) throw err;\n  });\n}());\n```\n\n## Example 3 - Accessing Multiple Devices Asynchronously and Concurrently\n\nThis example demonstrates concurrent asynchronous access to two devices on the\nsame bus, a DS1621 temperature sensor and an\n[Adafruit TSL2561 digital luminosity/lux/light sensor](http://www.adafruit.com/products/439).\n\n```js\nvar i2c = require('i2c-bus'),\n  i2c1;\n\nvar DS1621_ADDR = 0x48,\n  DS1621_CMD_ACCESS_TH = 0xa1;\n\nvar TSL2561_ADDR = 0x39,\n  TSL2561_CMD = 0x80,\n  TSL2561_REG_ID = 0x0a;\n\ni2c1 = i2c.open(1, function (err) {\n  if (err) throw err;\n\n  (function readTempHigh() {\n    i2c1.readWord(DS1621_ADDR, DS1621_CMD_ACCESS_TH, function (err, tempHigh) {\n      if (err) throw err;\n      console.log(tempHigh);\n      readTempHigh();\n    });\n  }());\n\n  (function readId() {\n    i2c1.readByte(TSL2561_ADDR, TSL2561_CMD | TSL2561_REG_ID, function (err, id) {\n      if (err) throw err;\n      console.log(id);\n      readId();\n    });\n  }());\n});\n```\n\n## API\n\nAll methods have asynchronous and synchronous forms.\n\nThe asynchronous form always take a completion callback as its last argument.\nThe arguments passed to the completion callback depend on the method, but the\nfirst argument is always reserved for an exception. If the operation was\ncompleted successfully, then the first argument will be null or undefined.\n\nWhen using the synchronous form any exceptions are immediately thrown. You can\nuse try/catch to handle exceptions or allow them to bubble up. \n\n### Methods\n\n- [open(busNumber [, options], cb)](https://github.com/fivdi/i2c-bus#openbusnumber--options-cb)\n- [openSync(busNumber [, options])](https://github.com/fivdi/i2c-bus#opensyncbusnumber--options)\n\n### Class Bus\n\n- Free resources\n  - [bus.close(cb)](https://github.com/fivdi/i2c-bus#busclosecb)\n  - [bus.closeSync()](https://github.com/fivdi/i2c-bus#busclosesync)\n\n- Information\n  - [bus.i2cFuncs(cb)](https://github.com/fivdi/i2c-bus#busi2cfuncscb)\n  - [bus.i2cFuncsSync()](https://github.com/fivdi/i2c-bus#busi2cfuncssync)\n  - [bus.scan(cb)](https://github.com/fivdi/i2c-bus#busscancb)\n  - [bus.scanSync()](https://github.com/fivdi/i2c-bus#busscansync)\n\n- Plain I2C\n  - [bus.i2cRead(addr, length, buffer, cb)](https://github.com/fivdi/i2c-bus#busi2creadaddr-length-buffer-cb)\n  - [bus.i2cReadSync(addr, length, buffer)](https://github.com/fivdi/i2c-bus#busi2creadsyncaddr-length-buffer)\n  - [bus.i2cWrite(addr, length, buffer, cb)](https://github.com/fivdi/i2c-bus#busi2cwriteaddr-length-buffer-cb)\n  - [bus.i2cWriteSync(addr, length, buffer)](https://github.com/fivdi/i2c-bus#busi2cwritesyncaddr-length-buffer)\n\n- SMBus\n  - [bus.readByte(addr, cmd, cb)](https://github.com/fivdi/i2c-bus#busreadbyteaddr-cmd-cb)\n  - [bus.readByteSync(addr, cmd)](https://github.com/fivdi/i2c-bus#busreadbytesyncaddr-cmd)\n  - [bus.readWord(addr, cmd, cb)](https://github.com/fivdi/i2c-bus#busreadwordaddr-cmd-cb)\n  - [bus.readWordSync(addr, cmd)](https://github.com/fivdi/i2c-bus#busreadwordsyncaddr-cmd)\n  - [bus.readI2cBlock(addr, cmd, length, buffer, cb)](https://github.com/fivdi/i2c-bus#busreadi2cblockaddr-cmd-length-buffer-cb)\n  - [bus.readI2cBlockSync(addr, cmd, length, buffer)](https://github.com/fivdi/i2c-bus#busreadi2cblocksyncaddr-cmd-length-buffer)\n  - [bus.receiveByte(addr, cb)](https://github.com/fivdi/i2c-bus#busreceivebyteaddr-cb)\n  - [bus.receiveByteSync(addr)](https://github.com/fivdi/i2c-bus#busreceivebytesyncaddr)\n  - [bus.sendByte(addr, byte, cb)](https://github.com/fivdi/i2c-bus#bussendbyteaddr-byte-cb)\n  - [bus.sendByteSync(addr, byte)](https://github.com/fivdi/i2c-bus#bussendbytesyncaddr-byte)\n  - [bus.writeByte(addr, cmd, byte, cb)](https://github.com/fivdi/i2c-bus#buswritebyteaddr-cmd-byte-cb)\n  - [bus.writeByteSync(addr, cmd, byte)](https://github.com/fivdi/i2c-bus#buswritebytesyncaddr-cmd-byte)\n  - [bus.writeWord(addr, cmd, word, cb)](https://github.com/fivdi/i2c-bus#buswritewordaddr-cmd-word-cb)\n  - [bus.writeWordSync(addr, cmd, word)](https://github.com/fivdi/i2c-bus#buswritewordsyncaddr-cmd-word)\n  - [bus.writeQuick(addr, bit, cb)](https://github.com/fivdi/i2c-bus#buswritequickaddr-bit-cb)\n  - [bus.writeQuickSync(addr, bit)](https://github.com/fivdi/i2c-bus#buswritequicksyncaddr-bit)\n  - [bus.writeI2cBlock(addr, cmd, length, buffer, cb)](https://github.com/fivdi/i2c-bus#buswritei2cblockaddr-cmd-length-buffer-cb)\n  - [bus.writeI2cBlockSync(addr, cmd, length, buffer)](https://github.com/fivdi/i2c-bus#buswritei2cblocksyncaddr-cmd-length-buffer)\n\n### Class I2cFuncs\n\n- [funcs.i2c](https://github.com/fivdi/i2c-bus#funcsi2c---boolean)\n- [funcs.tenBitAddr](https://github.com/fivdi/i2c-bus#funcstenbitaddr---boolean)\n- [funcs.protocolMangling](https://github.com/fivdi/i2c-bus#funcsprotocolmangling---boolean)\n- [funcs.smbusPec](https://github.com/fivdi/i2c-bus#funcssmbuspec---boolean)\n- [funcs.smbusBlockProcCall](https://github.com/fivdi/i2c-bus#funcssmbusblockproccall---boolean)\n- [funcs.smbusQuick](https://github.com/fivdi/i2c-bus#funcssmbusquick---boolean)\n- [funcs.smbusReceiveByte](https://github.com/fivdi/i2c-bus#funcssmbusreceivebyte---boolean)\n- [funcs.smbusSendByte](https://github.com/fivdi/i2c-bus#funcssmbussendbyte---boolean)\n- [funcs.smbusReadByte](https://github.com/fivdi/i2c-bus#funcssmbusreadbyte---boolean)\n- [funcs.smbusWriteByte](https://github.com/fivdi/i2c-bus#funcssmbuswritebyte---boolean)\n- [funcs.smbusReadWord](https://github.com/fivdi/i2c-bus#funcssmbusreadword---boolean)\n- [funcs.smbusWriteWord](https://github.com/fivdi/i2c-bus#funcssmbuswriteword---boolean)\n- [funcs.smbusProcCall](https://github.com/fivdi/i2c-bus#funcssmbusproccall---boolean)\n- [funcs.smbusReadBlock](https://github.com/fivdi/i2c-bus#funcssmbusreadblock---boolean)\n- [funcs.smbusWriteBlock](https://github.com/fivdi/i2c-bus#funcssmbuswriteblock---boolean)\n- [funcs.smbusReadI2cBlock](https://github.com/fivdi/i2c-bus#funcssmbusreadi2cblock---boolean)\n- [funcs.smbusWriteI2cBlock](https://github.com/fivdi/i2c-bus#funcssmbuswritei2cblock---boolean)\n\n### open(busNumber [, options], cb)\n- busNumber - the number of the I2C bus/adapter to open, 0 for /dev/i2c-0, 1 for /dev/i2c-1, ...\n- options - an optional options object\n- cb - completion callback\n\nAsynchronous open. Returns a new Bus object. The callback gets one argument (err).\n\nThe following options are supported:\n- forceAccess - A boolean value specifying whether access to devices on the\nI2C bus should be allowed even if they are already in use by a kernel\ndriver/module. Corresponds to I2C_SLAVE_FORCE on Linux. The valid values for\nforceAccess are true and false. Optional, the default value is false.\n\n### openSync(busNumber [, options])\n- busNumber - the number of the I2C bus/adapter to open, 0 for /dev/i2c-0, 1 for /dev/i2c-1, ...\n- options - an optional options object\n\nSynchronous open. Returns a new Bus object.\n\nThe following options are supported:\n- forceAccess - A boolean value specifying whether access to devices on the\nI2C bus should be allowed even if they are already in use by a kernel\ndriver/module. Corresponds to I2C_SLAVE_FORCE on Linux. The valid values for\nforceAccess are true and false. Optional, the default value is false.\n\n### bus.close(cb)\n- cb - completion callback\n\nAsynchronous close. The callback gets one argument (err).\n\n### bus.closeSync()\n\nSynchronous close.\n\n### bus.i2cFuncs(cb)\n- cb - completion callback\n\nDetermine functionality of the bus/adapter asynchronously. The callback gets\ntwo argument (err, funcs). funcs is a frozen\n[I2cFuncs](https://github.com/fivdi/i2c-bus#class-i2cfuncs)\nobject describing the functionality available.\nSee also [I2C functionality](https://www.kernel.org/doc/Documentation/i2c/functionality).\n\n### bus.i2cFuncsSync()\n\nDetermine functionality of the bus/adapter Synchronously. Returns a frozen\n[I2cFuncs](https://github.com/fivdi/i2c-bus#class-i2cfuncs)\nobject describing the functionality available.\nSee also [I2C functionality](https://www.kernel.org/doc/Documentation/i2c/functionality).\n\n### bus.scan(cb)\n- cb - completion callback\n\nScans the I2C bus asynchronously for devices the same way `i2cdetect -y -r`\nwould. The callback gets two arguments (err, devices). devices is an array of\nnumbers where each number represents the I2C address of a device which was\ndetected.\n\n### bus.scanSync()\n\nScans the I2C bus synchronously for devices the same way `i2cdetect -y -r`\nwould. Returns an array of numbers where each number represents the I2C address\nof a device which was detected.\n\n### bus.i2cRead(addr, length, buffer, cb)\n- addr - I2C device address\n- length - an integer specifying the number of bytes to read\n- buffer - the buffer that the data will be written to (must conatin at least length bytes)\n- cb - completion callback\n\nAsynchronous plain I2C read. The callback gets three argument (err, bytesRead, buffer).\nbytesRead is the number of bytes read.\n\n### bus.i2cReadSync(addr, length, buffer)\n- addr - I2C device address\n- length - an integer specifying the number of bytes to read\n- buffer - the buffer that the data will be written to (must conatin at least length bytes)\n\nSynchronous plain I2C read. Returns the number of bytes read.\n\n### bus.i2cWrite(addr, length, buffer, cb)\n- addr - I2C device address\n- length - an integer specifying the number of bytes to write\n- buffer - the buffer containing the data to write (must conatin at least length bytes)\n- cb - completion callback\n\nAsynchronous plain I2C write. The callback gets three argument (err, bytesWritten, buffer).\nbytesWritten is the number of bytes written.\n\n### bus.i2cWriteSync(addr, length, buffer)\n- addr - I2C device address\n- length - an integer specifying the number of bytes to write\n- buffer - the buffer containing the data to write (must conatin at least length bytes)\n\nSynchronous plain I2C write. Returns the number of bytes written.\n\n### bus.readByte(addr, cmd, cb)\n- addr - I2C device address\n- cmd - command code\n- cb - completion callback\n\nAsynchronous SMBus read byte. The callback gets two arguments (err, byte).\n\n### bus.readByteSync(addr, cmd)\n- addr - I2C device address\n- cmd - command code\n\nSynchronous SMBus read byte. Returns the byte read.\n\n### bus.readWord(addr, cmd, cb)\n- addr - I2C device address\n- cmd - command code\n- cb - completion callback\n\nAsynchronous SMBus read word. The callback gets two arguments (err, word).\n\n### bus.readWordSync(addr, cmd)\n- addr - I2C device address\n- cmd - command code\n\nSynchronous SMBus read word. Returns the word read.\n\n### bus.readI2cBlock(addr, cmd, length, buffer, cb)\n- addr - I2C device address\n- cmd - command code\n- length - an integer specifying the number of bytes to read (max 32)\n- buffer - the buffer that the data will be written to (must conatin at least length bytes)\n- cb - completion callback\n\nAsynchronous I2C block read (not defined by the SMBus specification). Reads a\nblock of bytes from a device, from a designated register that is specified by\ncmd. The callback gets three arguments (err, bytesRead, buffer). bytesRead is\nthe number of bytes read.\n\n### bus.readI2cBlockSync(addr, cmd, length, buffer)\n- addr - I2C device address\n- cmd - command code\n- length - an integer specifying the number of bytes to read (max 32)\n- buffer - the buffer that the data will be written to (must conatin at least length bytes)\n\nSynchronous I2C block read (not defined by the SMBus specification). Reads a\nblock of bytes from a device, from a designated register that is specified by\ncmd. Returns the number of bytes read.\n\n### bus.receiveByte(addr, cb)\n- addr - I2C device address\n- cb - completion callback\n\nAsynchronous SMBus receive byte. The callback gets two arguments (err, byte).\n\n### bus.receiveByteSync(addr)\n- addr - I2C device address\n\nSynchronous SMBus receive byte. Returns the byte received.\n\n### bus.sendByte(addr, byte, cb)\n- addr - I2C device address\n- byte - data byte\n- cb - completion callback\n\nAsynchronous SMBus send byte. The callback gets one argument (err).\n\n### bus.sendByteSync(addr, byte)\n- addr - I2C device address\n- byte - data byte\n\nSynchronous SMBus send byte.\n\n### bus.writeByte(addr, cmd, byte, cb)\n- addr - I2C device address\n- cmd - command code\n- byte - data byte\n- cb - completion callback\n\nAsynchronous SMBus write byte. The callback gets one argument (err).\n\n### bus.writeByteSync(addr, cmd, byte)\n- addr - I2C device address\n- cmd - command code\n- byte - data byte\n\nSynchronous SMBus write byte.\n\n### bus.writeWord(addr, cmd, word, cb)\n- addr - I2C device address\n- cmd - command code\n- word - data word\n- cb - completion callback\n\nAsynchronous SMBus write word. The callback gets one argument (err).\n\n### bus.writeWordSync(addr, cmd, word)\n- addr - I2C device address\n- cmd - command code\n- word - data word\n\nSynchronous SMBus write word.\n\n### bus.writeQuick(addr, bit, cb)\n- addr - I2C device address\n- bit - bit to write (0 or 1)\n- cb - completion callback\n\nAsynchronous SMBus quick command. Writes a single bit to the device.\nThe callback gets one argument (err).\n\n### bus.writeQuickSync(addr, bit)\n- addr - I2C device address\n- bit - bit to write (0 or 1)\n\nSynchronous SMBus quick command. Writes a single bit to the device.\n\n### bus.writeI2cBlock(addr, cmd, length, buffer, cb)\n- addr - I2C device address\n- cmd - command code\n- length - an integer specifying the number of bytes to write (max 32)\n- buffer - the buffer containing the data to write (must conatin at least length bytes)\n- cb - completion callback\n\nAsynchronous I2C block write (not defined by the SMBus specification). Writes a\nblock of bytes to a device, to a designated register that is specified by cmd.\nThe callback gets three argument (err, bytesWritten, buffer). bytesWritten is\nthe number of bytes written.\n\n### bus.writeI2cBlockSync(addr, cmd, length, buffer)\n- addr - I2C device address\n- cmd - command code\n- length - an integer specifying the number of bytes to write (max 32)\n- buffer - the buffer containing the data to write (must conatin at least length bytes)\n\nSynchronous I2C block write (not defined by the SMBus specification). Writes a\nblock of bytes to a device, to a designated register that is specified by cmd.\n\n### funcs.i2c - boolean\nSpecifies whether or not the adapter handles plain I2C-level commands (Pure\nSMBus adapters typically can not do these,\nI2C_FUNC_I2C).\n\n### funcs.tenBitAddr - boolean\nSpecifies whether or not the adapter handles the 10-bit address extensions\n(I2C_FUNC_10BIT_ADDR).\n\n### funcs.protocolMangling - boolean\nSpecifies whether or not the adapter knows about the I2C_M_IGNORE_NAK,\nI2C_M_REV_DIR_ADDR and I2C_M_NO_RD_ACK flags (which modify the I2C protocol!\nI2C_FUNC_PROTOCOL_MANGLING).\n\n### funcs.smbusPec - boolean\nSpecifies whether or not the adapter handles packet error checking\n(I2C_FUNC_SMBUS_PEC).\n\n### funcs.smbusBlockProcCall - boolean\nSpecifies whether or not the adapter handles the SMBus block process call\ncommand\n(I2C_FUNC_SMBUS_BLOCK_PROC_CALL).\n\n### funcs.smbusQuick - boolean\nSpecifies whether or not the adapter handles the SMBus quick command\n(I2C_FUNC_SMBUS_QUICK).\n\n### funcs.smbusReceiveByte - boolean\nSpecifies whether or not the adapter handles the SMBus receive byte command\n(I2C_FUNC_SMBUS_READ_BYTE).\n\n### funcs.smbusSendByte - boolean\nSpecifies whether or not the adapter handles the SMBus send byte command\n(I2C_FUNC_SMBUS_WRITE_BYTE).\n\n### funcs.smbusReadByte - boolean\nSpecifies whether or not the adapter handles the SMBus read byte command\n(I2C_FUNC_SMBUS_READ_BYTE_DATA).\n\n### funcs.smbusWriteByte - boolean\nSpecifies whether or not the adapter handles the SMBus write byte command\n(I2C_FUNC_SMBUS_WRITE_BYTE_DATA).\n\n### funcs.smbusReadWord - boolean\nSpecifies whether or not the adapter handles the SMBus read word command\n(I2C_FUNC_SMBUS_READ_WORD_DATA).\n\n### funcs.smbusWriteWord - boolean\nSpecifies whether or not the adapter handles the SMBus write word command\n(I2C_FUNC_SMBUS_WRITE_WORD_DATA).\n\n### funcs.smbusProcCall - boolean\nSpecifies whether or not the adapter handles the SMBus process call command\n(I2C_FUNC_SMBUS_PROC_CALL).\n\n### funcs.smbusReadBlock - boolean\nSpecifies whether or not the adapter handles the SMBus read block command\n(I2C_FUNC_SMBUS_READ_BLOCK_DATA).\n\n### funcs.smbusWriteBlock - boolean\nSpecifies whether or not the adapter handles the SMBus write block command\n(I2C_FUNC_SMBUS_WRITE_BLOCK_DATA).\n\n### funcs.smbusReadI2cBlock - boolean\nSpecifies whether or not the adapter handles the SMBus read I2C block command\n(I2C_FUNC_SMBUS_READ_I2C_BLOCK).\n\n### funcs.smbusWriteI2cBlock - boolean\nSpecifies whether or not the adapter handles the SMBus write i2c block command\n(I2C_FUNC_SMBUS_WRITE_I2C_BLOCK).\n\n","starsCount":5,"created":"2014-12-09T22:30:31.772Z","modified":"2017-08-27T05:22:40.112Z","lastPublisher":{"name":"fivdi","email":"fivdiweb@gmail.com"},"owners":[{"name":"fivdi","email":"fivdiweb@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"i2c-bus","_nodeVersion":"6.2.2","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/i2c-bus-1.2.2.tgz_1493621616475_0.062456335639581084"},"_npmUser":{"name":"fivdi","email":"fivdiweb@gmail.com"},"_npmVersion":"3.9.5","_rev":"8-e58a54e958e797ef11ef910d4495e226","_shasum":"afb9c145a1bea3bd5443d79de2152c360b94ca32","author":{"name":"fivdi"},"bugs":{"url":"https://github.com/fivdi/i2c-bus/issues"},"directories":{"example":"example","test":"test"},"dist-tags":{"latest":"1.2.2"},"dist":{"shasum":"afb9c145a1bea3bd5443d79de2152c360b94ca32","tarball":"https://registry.npmjs.org/i2c-bus/-/i2c-bus-1.2.2.tgz"},"maintainers":[{"name":"fivdi","email":"fivdiweb@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-08-27T05:22:40.112Z","created":"2014-12-09T22:30:31.772Z","0.1.0":"2014-12-09T22:30:31.772Z","0.2.0":"2014-12-13T07:01:19.310Z","0.3.0":"2014-12-13T07:15:47.945Z","0.4.0":"2014-12-13T11:27:20.428Z","0.5.0":"2014-12-14T00:50:47.193Z","0.6.0":"2014-12-15T18:22:48.218Z","0.7.0":"2014-12-16T12:48:01.403Z","0.8.0":"2014-12-19T22:21:24.523Z","0.9.0":"2014-12-22T11:07:56.086Z","0.10.0":"2015-01-24T10:17:33.564Z","0.11.0":"2015-02-01T13:29:52.660Z","0.11.1":"2015-03-28T00:36:40.541Z","0.11.2":"2015-05-07T19:34:44.288Z","0.11.3":"2015-09-02T20:38:42.428Z","0.12.0":"2015-10-06T21:06:45.811Z","1.0.0":"2015-10-10T15:39:39.656Z","1.0.1":"2015-12-05T09:24:32.247Z","1.0.2":"2016-01-29T20:16:45.419Z","1.0.3":"2016-04-27T21:33:44.596Z","1.1.0":"2016-05-23T17:57:34.341Z","1.1.1":"2016-07-22T20:17:59.687Z","1.1.2":"2016-10-05T20:27:56.564Z","1.2.0":"2017-01-06T18:01:09.455Z","1.2.1":"2017-02-12T17:01:05.321Z","1.2.2":"2017-05-01T06:53:39.046Z"},"users":{"manewu":true,"skylarstein":true,"crycode":true,"georgesapkin":true,"mstylesms":true}}}