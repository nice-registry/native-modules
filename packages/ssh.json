{"name":"ssh","description":"A Node.js binding for libssh","keywords":["ssh","libssh"],"version":"1.8.0","main":"index.js","dependencies":{"bindings":"*","nan":"^1.8.4"},"devDependencies":{"tap":"*","ssh2":"*","bl":"*","node-gyp":"~1.0.1","pty.js":"git://github.com/chjj/pty.js.git"},"repository":"https://github.com/rvagg/node-libssh","scripts":{"test":"tap test/*-test.js --stderr","install":"node-gyp rebuild"},"license":"MIT","gypfile":true,"gitHead":"0c6c00c5796ba0cbd0964ba662d1c6d544abc18d","homepage":"https://github.com/rvagg/node-libssh#readme","versions":[{"number":"0.0.1","date":"2011-03-20T10:15:32.857Z"},{"number":"1.0.0","date":"2013-07-13T10:44:28.806Z"},{"number":"1.0.1","date":"2013-07-14T00:32:28.630Z"},{"number":"1.0.2","date":"2013-07-14T00:39:41.374Z"},{"number":"1.1.0","date":"2013-07-14T07:45:11.906Z"},{"number":"1.1.1","date":"2013-07-17T00:46:19.836Z"},{"number":"1.2.0","date":"2013-07-17T02:34:18.505Z"},{"number":"1.2.1","date":"2013-07-18T04:01:40.475Z"},{"number":"1.2.2","date":"2013-07-19T04:15:22.411Z"},{"number":"1.3.0","date":"2013-07-21T09:19:17.946Z"},{"number":"1.4.0","date":"2013-07-25T05:20:11.917Z"},{"number":"1.4.1","date":"2013-08-11T05:52:57.808Z"},{"number":"1.5.0","date":"2013-08-28T01:45:56.355Z"},{"number":"1.5.1","date":"2013-10-14T05:41:55.917Z"},{"number":"1.6.0","date":"2013-11-25T05:27:27.451Z"},{"number":"1.7.0","date":"2014-01-23T06:02:02.146Z"},{"number":"1.7.1","date":"2014-01-23T06:15:11.948Z"},{"number":"1.7.2","date":"2014-03-22T00:44:24.971Z"},{"number":"1.7.3","date":"2014-05-12T02:59:23.617Z"},{"number":"1.8.0","date":"2015-05-08T20:32:44.615Z"}],"readme":"node-libssh\n===========\n\nA Low-level Node.js binding for [libssh](http://www.libssh.org/)\n----------------------------------------------------------------\n\n[![Build Status](https://secure.travis-ci.org/rvagg/node-libssh.png)](http://travis-ci.org/rvagg/node-libssh)\n\nCurrently this project is only concerned with a subset of the **server** functionality provided by libssh. The client functionality may be added at a future date (and you're invited to contribute if you want it!).\n\nYou can find it in npm as **ssh**, (version 0.0.1 of which is [substack's version](https://github.com/substack/node-ssh) with an older libssh).\n\n[![NPM](https://nodei.co/npm/ssh.png?downloads)](https://nodei.co/npm/ssh/)\n\n### Installing\n\nTo compile, you'll need to have libkrb5-dev (kerberos development files) and libssl-dev (openssl development files) installed on your system. `npm install ssh` should do the rest.\n\n### Lets make a Node.js SSH server!\n\n```js\nvar server = libssh.createServer({\n    hostRsaKeyFile : '/path/to/host_rsa'\n  , hostDsaKeyFile : '/path/to/host_dsa'\n})\n\nserver.on('connection', function (session) {\n  session.on('auth', function (message) {\n    if (message.subtype == 'publickey'\n        && message.authUser == '$ecretb@ckdoor'\n        && message.comparePublicKey(\n            fs.readFileSync('/path/to/id_rsa.pub'))) {\n      // matching keypair, correct user\n      return message.replyAuthSuccess()\n    }\n\n    if (message.subtype == 'password'\n        && message.authUser == '$ecretb@ckdoor'\n        && message.authPassword == 'nsa') {\n      // correct user, matching password\n      return message.replyAuthSuccess()\n    }\n    message.replyDefault() // auth failed\n  })\n\n  session.on('channel', function (channel) {\n    channel.on('end', function () {\n      // current channel ended\n    })\n    channel.on('exec', function (message) {\n      // execute `message.execCommand`\n    })\n    channel.on('subsystem', function (message) {\n      // `message.subsystem` tells you what's requested\n      // could be 'sftp'\n    })\n    channel.on('pty', function (message) {\n      // `message` contains relevant terminal properties\n      message.replySuccess()\n    })\n    channel.on('shell', function (message) {\n      // enter a shell mode, interact directly with the client\n      message.replySuccess()\n      // `channel` is a duplex stream allowing you to interact with\n      // the client\n\n      channel.write('Welcome to my party!\\n')\n      // lets do a console chat via ssh!\n      process.stdin                  // take stdin and pipe it to the channel\n        .pipe(channel.pipe(channel)) // pipe the channel to itself for an echo\n        .pipe(process.stdout)        // pipe the channel to stdout\n    })\n  })\n})\n\nserver.listen(3333, '127.0.0.1')\t\t// required port and optional ipv4 address interface defaults to 0.0.0.0\nconsole.log('Listening on port 127.0.0.1:3333')\n```\n\nSee *[stdiopipe.js](https://github.com/rvagg/node-libssh/blob/master/examples/stdiopipe.js)* in the examples directory if you want to try this out.\n\n### Remote exec!\n\nWe can receive **exec** requests and send the results back to the client. In this example we'll allow *any* exec if you have the right publickey.\n\n```js\n// a simple exec utility that spawns a process and pipes stdio to\n// back to the channel\nfunction exec (channel, cmd) {\n  var cmdarr = cmd.split(' ')\n    , child  = spawn(cmdarr.shift(), cmdarr)\n\n  child.stdout.pipe(channel)\n\n  child.on('close', function (code) {\n    // explicitly end the command with an EOF and send the exit status\n    channel.sendEof()\n    channel.sendExitStatus(code)\n    channel.close()\n  })\n}\n\nserver.on('connection', function (session) {\n  session.on('auth', function (message) {\n    if (message.subtype == 'publickey'\n        && message.comparePublicKey(\n            fs.readFileSync(__dirname + '/path/to/id_rsa.pub'))) {\n      // could check message.authUser if we cared about the username\n      return message.replyAuthSuccess()\n    }\n    message.replyDefault() // auth failed\n  })\n\n  session.on('channel', function (channel) {\n    channel.on('exec', function (message) {\n      message.replySuccess() // a success reply is needed before we send output\n      exec(channel, message.execCommand)\n    })\n  })\n})\n```\n\nSee *[exec.js](https://github.com/rvagg/node-libssh/blob/master/examples/exec.js)* in the examples directory if you want to try this out.\n\n### How about some SFTP goodness?\n\n```js\nserver.on('connection', function (session) {\n  session.on('auth', function (message) {\n    // we're just going to let everyone in to this party!\n    return message.replyAuthSuccess()\n  })\n\n  // authenticated sessions can open channels, you need to react to\n  // events for each channel\n  session.on('channel', function (channel) {\n    channel.on('subsystem', function (message) {\n      if (message.subsystem == 'sftp') {\n        // we have to indicate success and also accept a switch to\n        // SFTP mode\n        message.replySuccess()\n        message.sftpAccept()\n      }\n    })\n\n    // after switching in to sftp mode with `message.sftpAccept()` we will\n    // now be receiving 'sftp:X' messages, where *X* is an SFTP command\n    // the messages are also emitted on the 'sftpmessage' event, for convenience\n\n    channel.on('sftp:realpath', function (message) {\n      // client wants to know the real path to the given file/directory\n      // provided in `message.filename`, we respond with a `message.replyName()`\n      // we don't have to be truthful...\n      if (message.filename == '.' || (/\\/$/).test(message.filename)) {\n        message.replyName('/foo/bar/', {\n           permissions: +libssh.Stat('755').dir() // see below for info about Stat\n        })\n      } else {\n        message.replyName('fileforyou.txt', {\n           permissions: +libssh.Stat('644').reg()\n        })\n      }\n    })\n\n    channel.on('sftp:stat', statHandle)\n\n    function statHandle (message) {\n      // `message.filename` contains the path the client wants to stat\n\n      // let's play a game of \"pretend\":\n      var attrs = {\n          permissions: +libssh.Stat(644).reg()\n        , uid: 101\n        , gid: 202\n        , size: fs.statSync('fileforyou.txt').size // must be accurate\n        , atime: Date.now()\n        , mtime: Date.now()\n      }\n\n      message.replyAttr(attrs)\n    }\n\n    // can be handled the same way as 'stat' if you like\n    channel.on('sftp:lstat', statHandle)\n\n    channel.on('sftp:opendir', function (message) {\n      // client wants to move to a given directory, you must return a 'handle'\n      // that represents that directory, it can just be the directory name\n      message.replyHandle(message.filename)\n    })\n\n    // see sftp:readdir to know why we're doing this\n    var lastmsg\n    channel.on('sftpmessage', function (message) {\n      lastmsg = message\n    })\n\n    channel.on('sftp:readdir', function (message) {\n      // client wants to read the directory, you must respond using\n      // `message.replyNames()` with an array of files and their attributes\n\n      // the client will keep sending a 'readdir' until you give it an\n      // OK, so you have to keep track of state. 'sftpmessage' is emitted after\n      // sftp:* so you can easily use it for this purpose\n\n      // you probably should be more intelligent than this which will return\n      // the same list for each readdir:\n\n      if (lastmsg.type == 'readdir')\n        return message.replyStatus('ok')\n\n      message.replyNames([\n          { filename: 'foo', longname: 'foo'\n              , attrs: { permissions: +libssh.Stat(644).reg() } }\n        , { filename: 'bar', longname: 'bar'\n              , attrs: { permissions: +libssh.Stat(750).dir() } }\n        , { filename: 'baz', longname: 'baz'\n              , attrs: { permissions: +libssh.Stat(600).reg() } }\n      ])\n    })\n\n    var openHandles = {}\n\n    channel.on('sftp:open', function (message) {\n      // client wants to open `message.filename`, you must return a 'handle'\n      // that represents that file, it can just be the filename\n      // we're just going to give them the same file no matter what they\n      // request\n      openHandles['@' + message.filename] = fs.openSync('fileforyou.txt', 'r')\n      message.replyHandle('@' + message.filename)\n    })\n\n    channel.on('sftp:read', function (message) {\n      // client wants to read a chunk of the given handle that represents\n      // an open file\n      // sadly there is no easy streaming here, that's left up to you to\n      // implement\n\n      var buf = new Buffer(message.length) // message.length the reqeusted amount\n      var length = fs.readSync(\n            openHandles[message.handle]\n          , buf\n          , 0\n          , message.length\n          , message.offset // the requested start offset for a read\n        )\n\n      if (!length) // no more data left to read, send an EOF\n        message.replyStatus('eof')\n      else // `message.replyData()` needs a buffer and the length to send\n        message.replyData(buf, length)\n    })\n\n    channel.on('sftp:close', function (message) {\n      // client wants to close `message.handle`, tell it that it's done\n      if (openHandles[message.handle]) {\n        fs.closeSync(openHandles[message.handle])\n        openHandles[message.handle] = undefined\n      }\n      message.replyStatus('ok')\n    })\n  })\n})\n```\n\nSee *[trickysftp.js](https://github.com/rvagg/node-libssh/blob/master/examples/trickysftp.js)* in the examples directory if you want to try this out.\n\nSFTP events include:\n\n * sftp:open\n * sftp:close\n * sftp:read\n * sftp:write\n * sftp:lstat\n * sftp:fstat\n * sftp:setstat\n * sftp:fsetstat\n * sftp:opendir\n * sftp:readdir\n * sftp:remove\n * sftp:mkdir\n * sftp:rmdir\n * sftp:realpath\n * sftp:stat\n * sftp:rename\n * sftp:readlink\n * sftp:symlink\n\nSee the test files for more usage examples.\n\n\n### `Stat`\n\n*TODO: document this...*\n\n## Important project notes\n\nThis project is very new and immature and is bound to have some warts. There are a few known, minor memory leaks that need to be addressed. While node-libssh makes use of both libssh's nonblocking I/O facilities and libuv's socket polling, it's likely that there could be more performance gained from some more async work within the binding code.\n\nThe streams do not implement back-pressure very well, particularly the read component of channel stream which will just keep on filling up its buffer.\n\nPlease file issues if you have any questions or concerns or want to see a particular area focused on for development&mdash;just don't expect me to be able to justify time developing or fixing your own pet features, contributions would be greatly appreciated no matter how much of a n00b you feel.\n\nIf you want to see more of what's going on, you can send a `debug:true` option when you make a new `Server` instance, it'll print out some message details. There's additional debug cruft you can enable in the source but you'll have to dig to find that and it's very noisy.\n\n<a name=\"contributing\"></a>\nContributing\n------------\n\nnode-libssh is an **OPEN Open Source Project**. This means that:\n\n> Individuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.\n\nSee the [CONTRIBUTING.md](https://github.com/rvagg/node-libssh/blob/master/CONTRIBUTING.md) file for more details.\n\n<a name=\"maintainers\"></a>\nMaintainers\n-----------\n * Rod Vagg [@rvagg](https://github.com/rvagg)\n * Brian White [@mscdex](https://github.com/mscdex)\n * Audrius Butkevicius\n   [@AudriusButkevicius](https://github.com/AudriusButkevicius)\n * Darius Clark [@dariusc93](https://github.com/dariusc93)\n\n\n<a name=\"licence\"></a>\nLicence &amp; copyright\n-------------------\n\nCopyright (c) 2013-2014 Rod Vagg and Maintainers (above)\n\nnode-libssh is licensed under an MIT +no-false-attribs license. All rights not explicitly granted in the MIT license are reserved. See the included LICENSE file for more details.\n\n*node-libssh builds on the excellent work of the [libssh](http://www.libssh.org/) team. **libssh** is licensed under the LGPLv2.\n","starsCount":6,"created":"2011-03-20T10:15:32.260Z","modified":"2015-05-08T20:32:44.615Z","lastPublisher":{"name":"kenansulayman","email":"kenan@sly.mn"},"owners":[{"name":"substack","email":"substack@gmail.com"},{"name":"dominictarr","email":"dominic.tarr@gmail.com"},{"name":"rvagg","email":"rod@vagg.org"},{"name":"kenansulayman","email":"kenan@sly.mn"}],"other":{"_attachments":{},"_from":".","_id":"ssh","_nodeVersion":"1.8.1","_npmUser":{"name":"kenansulayman","email":"kenan@sly.mn"},"_npmVersion":"2.8.3","_rev":"1-3ab81fb94a59342b9c7984ac220717e6","_shasum":"d959af33f75efaf908713c1c328c485692a9635a","bugs":{"url":"https://github.com/rvagg/node-libssh/issues"},"directories":{},"dist-tags":{"latest":"1.8.0"},"dist":{"shasum":"d959af33f75efaf908713c1c328c485692a9635a","tarball":"http://registry.npmjs.org/ssh/-/ssh-1.8.0.tgz"},"maintainers":[{"name":"substack","email":"substack@gmail.com"},{"name":"dominictarr","email":"dominic.tarr@gmail.com"},{"name":"rvagg","email":"rod@vagg.org"},{"name":"kenansulayman","email":"kenan@sly.mn"}],"readmeFilename":"README.md","time":{"modified":"2015-05-08T20:32:44.615Z","created":"2011-03-20T10:15:32.260Z","0.0.1":"2011-03-20T10:15:32.857Z","1.0.0":"2013-07-13T10:44:28.806Z","1.0.1":"2013-07-14T00:32:28.630Z","1.0.2":"2013-07-14T00:39:41.374Z","1.1.0":"2013-07-14T07:45:11.906Z","1.1.1":"2013-07-17T00:46:19.836Z","1.2.0":"2013-07-17T02:34:18.505Z","1.2.1":"2013-07-18T04:01:40.475Z","1.2.2":"2013-07-19T04:15:22.411Z","1.3.0":"2013-07-21T09:19:17.946Z","1.4.0":"2013-07-25T05:20:11.917Z","1.4.1":"2013-08-11T05:52:57.808Z","1.5.0":"2013-08-28T01:45:56.355Z","1.5.1":"2013-10-14T05:41:55.917Z","1.6.0":"2013-11-25T05:27:27.451Z","1.7.0":"2014-01-23T06:02:02.146Z","1.7.1":"2014-01-23T06:15:11.948Z","1.7.2":"2014-03-22T00:44:24.971Z","1.7.3":"2014-05-12T02:59:23.617Z","1.8.0":"2015-05-08T20:32:44.615Z"},"users":{"song940":true,"moimikey":true,"adamkdean":true,"mtrnord":true,"zhanghaili":true,"almccann":true}}}