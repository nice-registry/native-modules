{"name":"array-gpio","version":"1.1.55","main":"lib/array-gpio","scripts":{"test":"false","install":"node-gyp rebuild"},"dependencies":{"bindings":"*","nan":"*"},"description":"A node.js GPIO control for rapid prototyping and development using a simple modern API.","devDependencies":{"colors":"^1.1.2"},"license":"MIT","engines":{"node":">= 5.0.0"},"gypfile":true,"keywords":["bcm2835","gpio","pi","raspberry","raspberrypi","raspberry pi","raspberry pi 3","rpi","rpio","onoff","pwm","i2c","spi"],"versions":[{"number":"1.0.2","date":"2017-02-28T19:17:16.951Z"},{"number":"1.0.3","date":"2017-02-28T19:31:21.685Z"},{"number":"1.0.4","date":"2017-02-28T19:48:31.252Z"},{"number":"1.0.5","date":"2017-02-28T21:17:46.293Z"},{"number":"1.0.6","date":"2017-02-28T22:23:42.613Z"},{"number":"1.0.7","date":"2017-02-28T22:55:56.925Z"},{"number":"1.0.8","date":"2017-03-01T18:17:26.814Z"},{"number":"1.1.0","date":"2017-03-06T02:55:07.208Z"},{"number":"1.1.1","date":"2017-03-06T03:20:55.184Z"},{"number":"1.1.2","date":"2017-03-06T04:38:22.371Z"},{"number":"1.1.25","date":"2017-03-06T20:14:32.384Z"},{"number":"1.1.26","date":"2017-03-08T17:33:31.320Z"},{"number":"1.1.27","date":"2017-03-08T18:12:32.948Z"},{"number":"1.1.28","date":"2017-03-14T00:27:12.629Z"},{"number":"1.1.29","date":"2017-03-16T23:01:35.849Z"},{"number":"1.1.30","date":"2017-03-19T21:47:46.012Z"},{"number":"1.1.31","date":"2017-03-20T12:33:00.604Z"},{"number":"1.1.32","date":"2017-03-21T16:08:21.744Z"},{"number":"1.1.33","date":"2017-03-21T16:11:10.710Z"},{"number":"1.1.34","date":"2017-03-24T14:50:33.576Z"},{"number":"1.1.35","date":"2017-05-03T16:27:48.202Z"},{"number":"1.1.36","date":"2017-05-03T16:51:40.638Z"},{"number":"1.1.37","date":"2017-05-03T19:33:39.133Z"},{"number":"1.1.38","date":"2017-05-03T20:01:02.255Z"},{"number":"1.1.39","date":"2017-05-04T15:55:35.838Z"},{"number":"1.1.40","date":"2017-05-04T16:14:28.078Z"},{"number":"1.1.41","date":"2017-05-04T16:17:59.746Z"},{"number":"1.1.42","date":"2017-05-05T12:42:32.846Z"},{"number":"1.1.43","date":"2017-05-05T12:49:27.462Z"},{"number":"1.1.44","date":"2017-05-07T21:55:01.756Z"},{"number":"1.1.45","date":"2017-05-07T23:31:42.240Z"},{"number":"1.1.46","date":"2017-06-28T21:02:03.642Z"},{"number":"1.1.47","date":"2017-06-29T00:12:07.331Z"},{"number":"1.1.48","date":"2017-06-29T21:20:39.376Z"},{"number":"1.1.49","date":"2017-06-29T21:40:39.615Z"},{"number":"1.1.50","date":"2017-06-29T22:48:46.308Z"},{"number":"1.1.51","date":"2017-07-01T22:12:52.079Z"},{"number":"1.1.52","date":"2017-07-03T20:33:54.444Z"},{"number":"1.1.53","date":"2017-07-09T13:00:38.182Z"},{"number":"1.1.54","date":"2017-08-11T17:22:19.827Z"},{"number":"1.1.55","date":"2017-08-21T14:59:20.229Z"}],"readme":"array-gpio\n==========\n\nA node.js ARM peripherals control for rapid prototyping and development using a simple modern API.\n\n#### Supports the following ARM peripherals\n\n* GPIO \n* PWM  \n* I2C (master)  \n* SPI\n \nThis module uses a C/C++ addon to access the rpi library using dev/gpiomem & /dev/mem for direct register control.\nYou can check the library at https://github.com/EdAlegrid/rpi.\n\n## Compatibility\n\n* Raspberry Pi Models: B+, 2, 3, Zero & Zero W.\n* Node.js Versions: 6.x, 7.x, 8.x\n\nNote: This module uses the physical pin numbering (P01-P40) from the board header.\n\n## Installation\n```console\n$ npm install array-gpio\n```\n## Quick Start\n\n#### Creating an input/output object\n\nExample 1\n\nOne momentary switch button connected to pin 11 \nand one led connected to pin 33. \n\n\n```js\nconst GPIO = require('array-gpio');\n\n/* By default, each input object created will have an\n * input event detection enabled. \n * \n * For this example, we will disable any event detection\n * using a boolean false flag as a second parameter.\n */ \n\n/* Creating an input object w/ input event disabled */\nlet sw = GPIO.Input(11, false); \n\n/* Creating an output object */\nlet led = GPIO.Output(33); \n\n/* Press sw button and run your script to turn ON the led. */\nif(sw.isOn){\n   led.on();\n}\n/* Release sw button. Run again your script to turn OFF the led. */\nelse if(sw.isOff){\n   led.off();\n}\n\n```\n\n\nExample 2\n\nTwo momentary switch buttons connected to pin 11 and 13\nand one led connected to pin 33. \n\nUsing a shared common main function for pin event detection.\n```js\nconst GPIO = require('array-gpio');\n\nlet sw1 = GPIO.Input(11); \nlet sw2 = GPIO.Input(13);\nlet led = GPIO.Output(33);\n\n/*\n * By default, the main event function \n * will listen for all input events.\n */\nGPIO.main = () => {\n  /* Press sw1 to turn ON the led */    \n  if(sw1.isOn){\n    led.on();\n  }\n  /* Press sw2 to turn OFF the led */ \n  else if(sw2.isOn){\n    led.off();\n  }\n};\n```\n\nExample 3\n\nUsing local event for pin event detection.\n```js\nconst GPIO = require('array-gpio');\n\nlet sw1 = GPIO.Input(11); \nlet sw2 = GPIO.Input(13);\nlet led = GPIO.Output(33);\n\n/* Press sw1 to turn ON the led */     \nsw1.event( 1, () => led.on());\n\n/* Press sw2 to turn OFF the led */ \nsw2.event( 1, () => led.off());\n```\n#### Creating an input/output array object\n\nExample 1\n\nTwo momentary switch buttons connected to pin 11 and 13\nand two led's connected to pin 33 and 35.\n\n```js\nconst GPIO = require('array-gpio');\n\n/* Creating two input objects with pin event detection disabled. */ \nlet input  = GPIO.Input(11,13, false);\n\n/* Creating two output objects */\nlet output = GPIO.Output(33,35);\n\n/*\n * input[0]  - switch button connected to pin 11\n * input[1]  - switch button connected to pin 13\n * output[0] - led connected to pin 33  \n * output[1] - led connected to pin 35 \n *\n */\n\n/* Press input[0] switch button and run your script. */\nif(input[0].isOn){\n \n    /* turns ON output[0] */\t \n    output[0].on(); \n \n    /* turns ON output[1] after 500 ms and turns OFF output[0] */\n    output[1].delayOn(500, function(){\n        output[0].off();\n    });  \n\n    /* turns OFF output[1] after 1 sec */\n    output[1].delayOff(1000);\n}\n/* Press input[1] switch button and run again your script. */\nelse if(input[1].isOn){\n \n    /* turns ON output[0] after 200 ms and turns OFF output[1]. */\n    output[0].delayOn(200, function(){\n        output[1].off();\n    });  \n\n    /* turns OFF output[0] after 1.5 sec */\n    output[0].delayOff(1500);\n}\n```\n\n\nExample 2\n\nTwo momentary switch buttons connected to pin 11 and 13\nand six led's connected to pin 33, 35, 37, 36, 38 and 40.\n```js\nconst GPIO = require('array-gpio');\n\nlet input = GPIO.Input(11,13);\nlet output = GPIO.Output(33,35,37,36,38,40);\n\n/* turn ON led's sequentially */\nfunction LedOn(){\n  let t = 50; /* ON time delay in ms */\n  for (let x in output){\n    t += 50;\n    output[x].on(t); \n  }\n}\n/* turn OFF led's sequentially */\nfunction LedOff(){\n  let t = 50; /* OFF time delay in ms */\n  for (let x in output){\n    t += 50;\n    output[x].off(t);\n  }\n}\n\n/* Using main function for pin event detection */\nGPIO.main = function (){\n  /* press input[0] switch button to turn ON the led's sequentially */\n  if(input[0].isOn){\n    LedOn();\n  }\n  /* press input[1] switch button to turn OFF the led's sequentially */\n  else if(input[1].isOn){\n    LedOff();\n  }\n};\n```\n\n## API\n\n### Input(pin1, pin2, ... , pinN)\n\n`input object constructor`\n\nSets a GPIO pin or group of GPIO pins as input object.\n\nChoose your pin based on the physical pin numbering (P01-P40) from the board header.\n\nReturns an input object or an array object if more than one pin is used.\n\nFor array object, each pin will be assigned or indexed consecutively as element of the returned array object.  \n\nYou can set as many input pins as you can. You are only limited by how much GPIO pins are available on your Raspberry Pi.\n\nThis is a synchronous function.\n\n\n`Using object literal as pin argument`\n\nvar arg = {pin:[pin1, pin2, pin3 ... pinN]};\n\n#### Input(arg)\n\nExample\n```js\nlet arg = {pin: [11, 13, 15]};\n\nvar input = GPIO.Input(arg);\n```\n\n\n### state \n\n`input/output property`\n\nReads the current logical condition of any input/output object at any given point in your application during runtime.\n\nReturns `true` if the object is in `high` or `ON` state condition.\n\nOtherwise returns `false` for `low` or `OFF` state condition.\n\nExample 1\n```js\nconst GPIO = require('array-gpio');\n\nlet sensor  = GPIO.Input(11);\n\n/* returns the current state of sensor object */\nconsole.log(sensor.state); \n\n```\n\nExample 2\n```js\n\nlet input = GPIO.Input(11, 13);\nlet led = GPIO.Output(33, 35);\n\nif(input[0].state && led[1].state === false){\n\n  console.log(input[0].state); // true\n  console.log(led[1].state); // false\n\n  led[1].on();\n\n  console.log(input[0].state); // true\n  console.log(led[1].state); // true\n}\n```\n\n### isOn and isOff\n\n`input/output property`\n\nSimilar to `state` property but with explicit context.\n\n`isOn` returns `true` if `state` is `true`, otherwise it returns `false`.\n\n`isOff` returns `true` if `state` is `false`, otherwise it returns `false`.\n\n\nExample\n```js\nconst GPIO = require('array-gpio');\n \nlet sw = GPIO.Input(11, 13, 15);\nlet led = GPIO.Output(33);\n \nGPIO.main = () => {\n  // turns on led if sw[0] is ON and if led is OFF \n  if(sw[0].isOn && led.isOff){ \n    led.on();\n  }\n  // turns off led if sw[1] is ON and if led is ON \n  if(sw[1].isOn && led.isOn){\n    led.off();\n  }\n};\n```\n\n#### read([callback])\n\n\n`input/output method`\n\nThe conventional way of getting the current state of any input/output object.\n\nReturns **1** for `ON` or `high` state and **0** for `OFF` or `low` state.\n\n**callback** function will be executed asynchronously if provided.     \n```js\n/* r for raspberry */\nconst r = require('array-gpio');\n\nlet sw = r.Input(11);\nlet solenoid = r.Output(35);\n\nsw.event(function(){\n  let status = sw.read(() => {\n    if(status === 1)\n      solenoid.on(50);\n    else\n      solenoid.off();  \n  }); \n});\n```\n\n\n### event(edge, callback)\n\n`input method`\n\nUse it to listen for input events for a particular pin.\n\nYou can listen for rising or falling edge events or both.\n\n**edge** \n\n`'re'` or `1` - Enable rising edge (high transition) event detection.\n\n`'fe'` or `0` - Enable falling edge (low transition) event detection.\n\n```js\n// enable rising edge detection\ninput[0].event('re', callback);\n// or\ninput[0].event(1, callback);\n\n// Enable falling edge detection\ninput[0].event('fe', callback);\n// or\ninput[0].event(0, callback);\n```\n\nIf edge parameter is not provided, both rising and falling edge detection will be used.\n```js\n// enable both rising and falling edge detection\ninput[0].event(callback);\n```\n\n**callback** function will be executed asynchronously when input events are detected. \n\nExample 1\n```js\nconst GPIO = require('array-gpio');\n\nlet sw = GPIO.Input(11, 13);\nlet led = GPIO.Output(33, 35);\n\n// sw[0] will use a local event for pin event detection \nsw[0].event(function(){\n  if(sw[0].state){\n    console.log('sw[0] is listening to a local event');\n    if(led[0].isOff){\n      led[0].on();\n    }\n    if(led[1].isOn){\n      led[1].off();\n    }\n  }\n});\n\n// sw[1] will still use the main event for event detection \nGPIO.main = function () {\n  if(sw[1].state){\n    console.log('sw[1] is listening to main event');\n    if(led[0].isOn){\n      led[0].off();\n    }\n    if(led[1].isOff){\n      led[1].on();\n    }\n  }\n};\n```\nExample 2\n```js\nconst GPIO = require('array-gpio');\n\nlet sw = GPIO.Input(11, 13, false);\nlet led = GPIO.Output(33, 35);\n\n// this time, both sw[0] and sw[1] will use its own local event\n// there is no need to define a main event function\n\nsw[0].event(function(){\n  // detects only high state and ignores low state\n  if(sw[0].state){\n    console.log('sw[0] is listening to a local event using anynomous function');\n    if(led[0].isOff){\n      led[0].on();\n    }\n    if(led[1].isOn){\n      led[1].off();\n    }\n  }\n});\n\nfunction sw1Event(){\n    console.log('sw[1] is listening to a local event using sw1Event callback');\n    if(led[0].isOn){\n      led[0].off();\n    }\n    if(led[1].isOff){\n      led[1].on();\n    }\n}\n\nsw[1].event(1, sw1Event);\n```\n\n### clearEvent()\n\n`input method`\n\nInput stops listening to any input events (local or main event).\n\n```js\nconst r = require('array-gpio');\n\n/* using one button switch */\nlet sw = r.Input(11);\n\nsw.event(1, function(){\n  console.log(\"I'm only a one-time event\");\n  sw.clearEvent();\n});\n```\n\nUsing clearEvent() to debounce a switch.\n```js\nconst r = require('array-gpio');\n\nlet sw1 = r.Input(11);\nlet sw2 = r.Input(13);\nlet led = r.Output(33);\n\n/* debouncing sw1 only */\n\nfunction OnEvent(){\n  console.log('led is ON'); \n  led.on();\n  sw1.clearEvent();\n}\n\n/* ON switch */\nsw1.event(1, OnEvent);\n\n/* OFF switch */\nsw2.event(1, function(){\n  led.off()\n  sw1.event(1, OnEvent);\n});\n```\n\n### main\n\n`input object callback function`\n\nThe main function will serve as the default input event listener for all input objects created.\n\nIt will run in the background when you run your application.\n\nYou must define it inside your application to use it. It will listen both for rising and falling edge events.\n\nIt is shared by all input pins. To capture events from a particular pin, you can use a series of `if` and `else if` logic expressions.\n\nExample\n```js\nconst GPIO = require('array-gpio');\n\nlet sw = GPIO.Input(11, 13, 15);\nlet led = GPIO.Output(33, 35);\n\nGPIO.main = function (){\n\n if(sw[0].isOn){\n   led[0].on();\n }\n else if(sw[1].isOn){\n   led[1].on();\n }\n\n};\n```\n\n### Output(pin1, pin2, pin3 ... pinN)\n\n`output object constructor`\n\nSets a GPIO pin or group of GPIO pins as output object.\n\nChoose your pin based on the physical pin numbering (P01-P40) from the board header.\n\nReturns an output object using a single pin or an array object for more than one pin.\n\nFor array object, each pin will be assigned or indexed consecutively as element of the returned array object.  \nSimilar to Input(), you can set as many output pins as you can.\n\nThis is a synchronous function.\n\n`Using object literal as pin argument`\n\n#### Output(arg)\n\nvar arg = {pin:[pin1, pin2, pin3 ... pinN]};\n\n```js\nconst GPIO = require ('array-gpio');\n\nlet arg = {pin:[33,35,37,36,38,40]};\n\nvar actuator = GPIO.Output(arg);\n```\n\n\n### on([t]) and off([t])\n\n`output method`\n\nTurns ON and OFF an output object.\n\n**t** is an optional time delay in milliseconds. Output object will turn ON or OFF after the expiration of time delay.  \n\nExample\n```js\nconst GPIO = require('array-gpio');\n\nlet sw = GPIO.Input(11,13);\nlet actuator = GPIO.Output(33,35);\n\nGPIO.main = () => {\n  if(sw[0].isOn && actuator[0].isOff){\n    actuator[0].on(200); // turns ON after 200 ms delay\n    actuator[1].on(); // turns ON immediately\n  }\n  else if(sw[1].isOn && actuator[1].isOn){\n    actuator[0].off(50); // turns OFF after 50 ms delay\n    actuator[1].off(); // turns OFF immediately\n  }\n};\n```\n### write(value[ ,callback])\n\n`output method`\n\nThe conventional way of turning ON and OFF an output object.\n\n**value** - control bit number.\n\n`1` - `ON` or `high` state   \n\n`0` - `OFF` or `low` state\n\n**callback** function will be executed asynchronously if provided.     \n\nExample\n```js\nconst GPIO = require('array-gpio');\n\nconst sw = GPIO.Input(11,13);\nconst actuator = GPIO.Output(33,35);\n\nlet sw1 = sw[0];\nlet sw2 = sw[1];\n\nlet motorA = actuator[0];\nlet motorB = actuator[1];\n\nGPIO.main = () => {\n  if(sw1.read() === 1){\n    motorA.write(1, function(){\n      if(motorB.read() === 0)\n      motorB.write(1);\n    });\n  }\n  if(sw2.read() === 1){\n    motorA.write(0, function(){\n      if(motorB.read() === 1)\n      motorB.write(0);\n    });\n  }\n};\n```\n\n\n### delayON(t [,callback]) and delayOFF(t [,callback])\n\nor\n\n### delayOn(...) and delayOff(...)\n\n`output method`\n\nLets you turn ON and OFF an output object with a delay time.\n\n**t** is the required time delay in milliseconds. Output object will turn ON or OFF after the expiration of time delay.\n\nOptional **callback** function will be executed asynchronously when time delay expires.     \n\nExample\n```js\nif(sw[0].state && actuator[0].state === false){\n  // actuator5 will turn ON after 1 sec\n  actuator[0].delayON(1000, function(){\n    console.log('actuator is ON'); // outputs after 1 sec  \n  });\n  console.log('turning ON actuator ...'); // outputs immediately\n}\nelse if(sw[1].state && actuator[1].state){\n  actuator[0].delayOFF(1500, function(){\n    console.log('actuator is OFF'); // outputs after 1.5 sec  \n  }); \n  console.log('turning OFF actuator ...'); // outputs immediately\n}\n\n```\n### loop(cs, T, callback)\n\n`output method`\n\nThis is a utility function for general purpose looping operations.\n\nIt is attached to an output object as a property method but it is totaly independent from its GPIO operations.\nSo you can continue using the output object for other purposes while using the loop utility.\n\nIt is not very different from setInterval() function.\nHowever, it has some internal flags to prevent a race condition.       \n\n**cs** is a control flag.\n\nUse `1` to start the looping operation along with the other arguments.\n\nUse `0` or without any arguments to stop.\n\n**T** (ms) is the time interval of the looping operation. Minimum is 10 ms.\n\n**callback** function will be executed asynchronously at the end of time interval. This is the task or process you want to loop or cycle continously.\n\nThe total elapsed time of the process must be accounted for or determined if you are using a lot of time delays in your I/O operations.\n\nExample\n```js\nconst GPIO = require('array-gpio');\n\nconst input = GPIO.Input(11,13);\nconst led = GPIO.Output(33,35,37,36,38,40);\n\nlet start = input[0];\nlet stop = input[1];\n\n// using the loop utility from led[0]\n// without affecting its led ON/OFF operation\nlet ledSequence = led[0];\n\n// turn ON and OFF led's sequentially\n// total elapsed time is 700 ms \nlet ledOnOff = () => {\n  let t = 50; \n  for (let x in led){\n    t += 50;\n    led[x].delayOn(t, () => console.log('led[' + x + '] is ON')); \n    led[x].delayOff(t + 400, () => console.log('led[' + x + '] is OFF')); \n  }\n};\n\nGPIO.main = () => {\n  if(start.isOn){\n    // start the ledOnOff sequence  \n    ledSequence.loop(1, 1000, ledOnOff);\n  }\n  else if(stop.isOn){\n    // stop the ledOnOff sequence  \n    ledSequence.loop();\n  }\n};\n\nvar appExitProcess = () => {\n  console.log('closing all I/O objects');\n  for(let x in input){\n    input[x].close();      \n  }\n  for(let x in led){\n    led[x].close();\n  }\n}\n\n// using Ctrl-C for app exit\nprocess.on('SIGINT', () => {\n  appExitProcess();\n  process.exit(0);  \n});\n```\n\n### pin\n\n`input/output property`\n\nReturns the GPIO pin used from your input and output objects.\n\nExample\n```js\nconst r = require('array-gpio');\n\nlet sw = r.Input(11);\nlet led = r.Output(33);\n\nconsole.log(sw.pin); // 11\nconsole.log(led.pin); // 33\n```\n\n### close()\n\n`input/output method`\n\nCloses any input/output object.\n\nExample 1\n```js\nconst r = require('array-gpio');\n\nlet sw = r.Input(11);\nlet led = r.Output(33);\n\nsw.close();\nled.close();\n```\nExample 2\n```js\nconst r = require('array-gpio');\n\nlet input = r.Input(11, 13);\nlet output = r.Output(33, 35);\n\nfunction appExitProcess(){\n  console.log('closing all I/O objects');\n  for(let x in input){\n    input[x].close();      \n  }\n  for(let x in output){\n    output[x].close();\n  }\n}\n\n// using Ctrl-C for app exit\nprocess.on('SIGINT', function (){\n  appExitProcess();\n  process.exit(0);  \n});\n```\n\n### setR(intR)\n\n`input method`\n\nSets or changes input internal resistor using either pull up or pull down.\n\n**intR**\n\n`'pu'` or `1` - Enable pull up resistor.\n\n`'pd'` or `0` - Enable pull down resistor.\n\nIf no parameter is provided, no internal resistor will be used.\n\nExample\n```js\nconst r = require('array-gpio');\n\nlet sw = r.Input(11,13,15);\n\n// using pull up resistor\nsw[0].setR('pu'); \n// using pull down resistor\nsw[1].setR(0);\n// no internal resistor\nsw[2].setR();\n```\n\n***\n### PWM(pin)\n\n`PWM object constructor`\n\n**pin**\n\nUse PWM hardware peripherals to generate square-wave pulses for selected physical pin numbers 12, 32, 33 and 35 using its alternate function.\n\nChannel 1 - pins 12 and 32.\n\nChannel 2 - pins 33 and 35.\n\nYou can only control 2 peripherals independently, one from channel 1 and one from channel 2. If both peripherals are from the same channel, you can control both channels using only \nthe control values (setRange and setData) from one of the peripherals.\n\nCheck the available pins based on your Raspberry pi models.\n\nRequires root access to run your application. \n\n### setClockFreq(div)\n\n**div** The the divisor value to calculate the desired clock frequency from a fixed oscillator of 19.2 MHz.\n\n(0 to 4095)\n\nfreq = 19200000/div\n\n### setRange(range)\n\nSets the period T of the pulse.\n\n### setData(data)\n\nSets the pw (pulse width) of the pulse.\n\n### stop()\n\nStop the pulse generation of the system 19.2 MHz clock oscillator.\n\nYou can restart the pulse generation anytime using the pulse() or setData() function.\n\n### close() \n\nStop and disable PWM. Returns back the pin used for GPIO use.\n\n\nExample 1\n```js\n/* Connect an led to pin 12. */\n\nconst r = require('array-gpio');\n\n/* start PWM using pin 12 */\nvar pwm = r.PWM(12);\n\n/* set clock frequency using a div value of 1920 */\npwm.setClockFreq(1920); // sets clock freq to 10kHz or 0.1 ms time resolution for T and pw \n\n/* set period (T) of the pulse */\npwm.setRange(1000); // 1000 x 0.1 ms = 100 ms (actual period T)\n\n/*\n * set pw (pulse width) of the pulse and start the pulse generation for 2 seconds \n *\n * The led attached to pin 12 should blink for 2 seconds\n */\npwm.setData(100); // 100 x 0.1 ms = 10 ms (actual pw)\n\n/* stop PWM and return pin 12 to GPIO input mode */\nsetTimeout(function(){\n\n  pwm.stop();\n  pwm.close();\n\n}, 2000);\n\n\n```\n\n### PWM(pin, freq, T, pw)\n\n`PWM object constructor`\n\nA quick way to start PWM with predefined clock frequencies.\n\n**pin**\n\nChoose from channel 1 pins (12, 32) or channel 2 pins (33, 35).\n\n\n**freq** (kHz)\n\nChoose from 3 predefined clock oscillator frequency that will provide different time resolutions for your `T` (period) and `pw` (pulse width). \n\n**10**   kHz  -> `0.1` ms \n\n**100**  kHz  -> `0.01` ms\n\n**1000** kHz  -> `0.001` ms or `1` uS (microsecond) \n\n\n**T** (ms) is the initial cycle period T of the pulse. \n\n**pw** (ms) is the initial pulse width of the pulse. \n\nThe ratio of `pw` over `T` is the pulse **duty cycle** (pw/T) x 100%.\n\n### pulse([pw])\n\nStart the pulse generation or create a new pulse using the `pw` parameter provided.\nIf `pw` is not provided, it will use the initial `pw` from the PWM constructor and start the pulse generation.\n\n**pw** (ms) is the pulse width that will be used to generate a new pulse.\n\nYou can change the period `T` using `setRange()` and `pw` using `setData()` or `pulse()` function at anytime in your application.\nHowever, T is usually fixed while changes in pw controls the behaviour of your motor device. \n\nExample 2\n```js\n/* Using a generic micro servo motor (~4.8 to 6.0 V)\n *\n * T period = 20 ms\n *\n * pw (pulse width) needed for various servo positions\n *\n * pw = 1.0 ms - pos 1, home position\n * pw = 1.5 ms - pos 2, rotates 40  degrees cw (clockwise) from pos 1 \n * pw = 2.0 ms - pos 3, rotates 80  degress cw from pos 1\n * pw = 2.5 ms - pos 4, rotates 120 degress cw from pos 1\n *   \n */\n\nconst r = require('array-gpio');\n\nvar pin  = 33;    /* channel 2, alt-function 0 */\nvar freq = 10;    /* 10 kHz provides 0.1 ms time resolution */\nvar T    = 200;   /* 200 x 0.1 ms = 20 ms */\nvar pw   = 10;    /* 10  x 0.1 ms = 1.0 ms, home position */\n\n/* start PWM and initialize with above details */\nvar pwm = r.PWM(pin, freq, T, pw);\n\n/* create four push buttons sw[0], sw[1], sw[2] and sw[4] */\nconst sw = r.Input(11,13,15,19);\n\nr.main = () => {\n\n  /* Press sw[0] button to rotate the servo motor to pos 1 or home position */\n  if(sw[0].isOn){\n    pwm.pulse(10);    // 1.0 ms pw\n  }\n  /* Press sw[1] button to rotate to pos 2 */\n  else if(sw[1].isOn){\n    pwm.pulse(15);    // 1.5 ms pw\n  }\n  /* Press sw[2] button to rotate to pos 3 */\n  else if(sw[2].isOn){\n    pwm.pulse(20);    // 2.0 ms pw\n  }\n  /* Press sw[3] button to rotate to pos 4 */\n  else if(sw[3].isOn){\n    pwm.pulse(25);    // 2.5 ms pw\n  }\n\n};\n\nconst appExitProcess = () => {\n console.log('closing all sw and pwm objects');\n  for(let x in sw){\n    sw[x].close();\n  }\n  pwm.close();\n  process.exit(0);\n}\n\nprocess.on('SIGINT', () => {\n  console.log('\\napp terminated using Ctrl-C');\n  appExitProcess();\n});\n\n```\n\n\n***\n### I2C()\n\nStart I2C operations. Set pins 03 (SDA) and 05 (SCL) to alternate function 0 (ALT0) for I2C single master serial data transfer operations.\n\nRequires root access.\n\n### begin()\n\nEnable or restart I2C interface at anytime in your application. However, it is not necessary when using the I2C() constructor. \n\n### end()\n\t\nEnd I2C operations. I2C pins 03 (SDA) and 05 (SCL) are returned to GPIO input mode.\n\n\n### setTransferSpeed(baud)\n\nSets the I2C clock frequency by converting the **baud** parameter to the equivalent I2C clock divider value.\n\n### setClockFreq(div)\n\nSets the I2C clock speed based on the **div** divisor value. Check values below.\n```code\ndiv = 2500 => 10us \t=> 100 kHz\ndiv = 626  => 2.504us \t=> 399.3610 kHz\ndiv = 150  => 60ns \t=> 1.666 MHz (default at reset)\ndiv = 148  => 59ns \t=> 1.689 MHz\n```\n### selectSlave(addr)\n\nSets the I2C slave address.\n\n**addr** The I2C slave address.\n\n### write(wbuf, len)\n\nWrite a number of bytes to the currently selected I2C slave. \n\n**wbuf** Buffer of bytes to write/send.\n\n**len**\tNumber of bytes to write/send.\n\n### read(rbuf, len)\n\nRead a number of bytes from the currently selected I2C slave. \n\n**rbuf** Buffer of bytes to read/receive.\n\n**len**\tNumber of bytes to read/receive.\n\n\n```js\n/* Using MCP9808 Temperature Sensor */\n\nconst r = require('array-gpio');\n\nvar i2c = r.I2C();\n\n/* set data transfer speed to 400 kHz */\ni2c.setTransferSpeed(400000);\n \n/* MCP9808 device address */\nlet slave = 0x18;\n\n/* access MCP9808 device */\ni2c.selectSlave(slave);\n\n/* setup write and read data buffer */\nconst wbuf = Buffer.alloc(16); // write buffer\nconst rbuf = Buffer.alloc(16); // read buffer\n\n/* accessing the internal 16-bit manufacturer ID register within MCP9808 */\nwbuf[0] = 0x06; // address of manufacturer ID register\ni2c.write(wbuf, 1);\n\n/* \n * read content of 16-bit manufacturer ID register (should be 0x54 as per datasheet) \n * reads upper byte (rbuf[0]) and lower byte (rbuf[1]), ID value is on the lower byte\n */\ni2c.read(rbuf, 2); \n\nconsole.log('MCP9808 ID: ', rbuf[1].toString(16));  // convert ID to hex value\n\n/* Based on MCP9808 datasheet, compute the temperature data as follows */\nfunction getTemp(){\n\n  /* variable for temperature data */\n  let Temp;\n\t\n  let UpperByte = rbuf[0];\n  let LowerByte = rbuf[1];\n\n  UpperByte = UpperByte & 0x1F; // Clear flag bits\n\n  // Temp < 0°C\n  if ((UpperByte & 0x10) == 0x10){\n\tUpperByte = UpperByte & 0x0F; // Clear SIGN\n\tTemp = 256 - ((UpperByte * 16) + (LowerByte / 16));\n\n  // Temp > 0°C\n  }else { \n\tTemp = ((UpperByte * 16) + (LowerByte / 16));\n  }\n\n  /* Print out temperature data */\n  console.log('Temp: ', Temp);\n \n}\n\n/* get temperature readings every 2 seconds */\nsetInterval( function(){\n\n  /* \n   * accessing the internal 16-bit configuration register within MCP9808 \n   * You can skip accessing this register using default settings \n   */\n  wbuf[0] = 0x01; // address of configuration register\n  /* change content of configuration register */\n  wbuf[1] = 0x02; // register upper byte, THYST set with +1.5 C\n  wbuf[2] = 0x00; // register lower byte (power up defaults)\n  i2c.write(wbuf, 3);\n\n  /* accessing the internal 16-bit ambient temp register within MCP9808 */\n  wbuf[0] = 0x05; // address of ambient temperature register\n  i2c.write(wbuf, 1);\n\n  /* read content of ambient temp register */\n  i2c.read(rbuf, 2); // reads UpperByte and LowerByte\n  \n  /* get temperature data and print out the results */\n  getTemp();\n \n}, 2000);\n\nprocess.on('SIGINT', function (){\n  console.log('\\napp terminated using Ctrl-C');\n  i2c.end();\n  process.exit(0);\n});\n\n```\n\n\n***\n### SPI()\n\nSwitches RPi SPI0 pins 19 (MOSI), 21 (MISO), 23 (CLK), 24 (CE0) and 26 (CE1) to alternate function ALT0 for SPI interface use.\n\nRequires root access.\n\n### setClockFreq(div)\n\nSets SPI clock frequency using a divisor value.\n\nSpecifies the divisor used to generate the SPI clock frequency. Figures below show the div and clock frequency generated.\nClock is based on nominal core clock rate of 250MHz on RPi1 and RPi2, and 400MHz on RPi3.\n\n**div** The SPI divisor to generate the SPI clock frequency.\n\n```code\nSPI div  2048  = 122.0703125kHz on Rpi2, 195.3125kHz on RPI3\nSPI div  1024  = 244.140625kHz on Rpi2, 390.625kHz on RPI3\nSPI div  512   = 488.28125kHz on Rpi2, 781.25kHz on RPI3\nSPI div  256   = 976.5625kHz on Rpi2, 1.5625MHz on RPI3\nSPI div  128   = 1.953125MHz on Rpi2, 3.125MHz on RPI3 (default)\nSPI div  64    = 3.90625MHz on Rpi2, 6.250MHz on RPI3\nSPI div  32    = 7.8125MHz on Rpi2, 12.5MHz on RPI3\nSPI div  16    = 15.625MHz on Rpi2, 25MHz on RPI3\nSPI div  8     = 31.25MHz on Rpi2, 50MHz on RPI3\n```\n\n### chipSelect(cs)\n```code\ncs = 0,  Chip Select 0\ncs = 1,  Chip Select 1\ncs = 2,  Chip Select 2 \ncs = 3,  No Chip Select \n```\n**cs** Sets the chip select pin(s).\nWhen a data transfer is made, the selected pin(s) will be asserted or held in active state (usually active **low**) during the transfer.\n\n### setCSPolarity(cs, active)\n\n**cs**\tThe chip select pin you want to change the active state.\n\n**active** Change the active state of the pin either active low **0** or high **1**.\n\n### setDataMode(mode)\n\nSets the SPI data mode. Sets the clock polariy and phase.\n```code\nmode = 0,  CPOL = 0, CPHA = 0\nmode = 1,  CPOL = 0, CPHA = 1\nmode = 2,  CPOL = 1, CPHA = 0\nmode = 3,  CPOL = 1, CPHA = 1\n```\n**mode** Choose one of SPI mode above.\n\n### transfer(wbuf, rbuf, len)\n\nTransfers any number of bytes to and from the currently selected SPI slave.\nSelected CS pins (as previously set by chipSelect) will be held in active state during the transfer.\n\nThe data read from the slave is placed into rbuf (rbuf must be at least `len` bytes long).\nUses polled transfer as per section 10.6.1 of the BCM 2835 ARM Peripherals manual.\n\n\n**wbuf** Buffer of bytes to write/send.\n\n**rbuf** Buffer of bytes to read/receive.\n\n**len**\tNumber of bytes to send/receive.\n\n\n### write(wbuf, len)\n\nWrite a number of bytes to the currently selected SPI slave.\n\nAsserts the currently selected CS pins (as previously set by chipSelect) during the transfer.\n\n**wbuf** Buffer of bytes to write/send to slave.\n\n**len**\t Number of bytes to write/send to slave.\n\n\n### read(rbuf, len)\n\nRead a number of bytes from the currently selected SPI slave.\n\n**rbuf** Buffer of bytes to read/receive from slave.\n\n**len**\t Number of bytes to read/receive from slave.\n\n\n### begin()\n\nEnable or restart SPI interface at anytime in your application. However, it is not necessary when using the SPI() constructor. \n\n### end()\n\nEnd SPI operations. SPI0 pins 19 (MOSI), 21 (MISO), 23 (CLK), 24 (CE0) and 26 (CE1) are returned to GPIO input mode.\n\nExample\n```js\n/* Using MCP3008 10-bit A/D Converter Chip */\n\n/* \n * VDD and Vref are connected to Raspberry Pi 3.3 V\n * Channel 0 (pin 1) will be used for analog input voltage using single-ended mode \n * Since Vref is set to 3.3 V, max. analog input voltage\n * should not be greater than 3.3 V\n * \n * Read the MCP3008 datasheet on how to configure the chip for more details \n */\n\nconst r = require('array-gpio');\n\nvar spi = r.SPI();\n\nspi.setDataMode(0); \nspi.setClockFreq(128); \nspi.setCSPolarity(0, 0); \nspi.chipSelect(0);\n\n/* setup write and read data buffer */\nconst wbuf = Buffer.alloc(16); // write buffer\nconst rbuf = Buffer.alloc(16); // read buffer\n\n/* configure the chip to use CH0 in single-ended mode */\nwbuf[0] = 0x01; // start bit\nwbuf[1] = 0x80; // using channel 0, single ended\nwbuf[2] = 0x00; // don't care data byte as per datasheet\nspi.write(wbuf, 3); // write 3 bytes to slave  \n\n/* alternative way to write and read to a slave at the same time */\n//spi.transfer(wbuf, rbuf, 3); // 3 bytes will be sent to slave and 3 bytes to read\n\nspi.read(rbuf, 3); // read 3 bytes from slave\n/* read A/D conversion result */\n/* the 1st byte received through rbuf[0] will be discarded as per datasheet */ \nvar data1 = rbuf[1] << 8;  // 2nd byte, using only 2 bits data\nvar data2 = rbuf[2];\t   // 3rd byte, 8 bits data\nvar value = data1 + data2; // combine both data to create a 10-bit digital output code \n        \nconsole.log(\"* A/D digital output code: \", value); \n\n/* compute the output voltage */ \nvar vout = (value * 3.3)/1024;\n        \nconsole.log(\"* A/D voltage output: \", vout); \n\nspi.end();\n```\n\n\n","starsCount":1,"created":"2017-02-28T19:17:16.951Z","modified":"2017-08-21T14:59:20.229Z","lastPublisher":{"name":"edolabworks","email":"ealegrid@gmail.com"},"owners":[{"name":"edolabworks","email":"ealegrid@gmail.com"}],"other":{"_attachments":{},"_id":"array-gpio","_nodeVersion":"8.2.1","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/array-gpio-1.1.55.tgz_1503327560087_0.07100482331588864"},"_npmUser":{"name":"edolabworks","email":"ealegrid@gmail.com"},"_npmVersion":"5.3.0","_rev":"42-703b706e2be7d775fa999eff98e6bd5f","author":{"name":"Ed Alegrid","email":"ealegrid@gmail.com"},"directories":{},"dist-tags":{"latest":"1.1.55"},"dist":{"integrity":"sha512-8Q8MskH91lheQMAIu/grG+qg1IEUjtXhYjS53BNyHUzBtON0FFDsQ1lw/EUwZHkwl7B3zsCkvENYEHL0gC5bdg==","shasum":"7b408ae78e1701a804f4794ee9fd81b223bf733f","tarball":"https://registry.npmjs.org/array-gpio/-/array-gpio-1.1.55.tgz"},"maintainers":[{"name":"edolabworks","email":"ealegrid@gmail.com"}],"readmeFilename":"Readme.md","time":{"modified":"2017-08-21T14:59:20.229Z","created":"2017-02-28T19:17:16.951Z","1.0.2":"2017-02-28T19:17:16.951Z","1.0.3":"2017-02-28T19:31:21.685Z","1.0.4":"2017-02-28T19:48:31.252Z","1.0.5":"2017-02-28T21:17:46.293Z","1.0.6":"2017-02-28T22:23:42.613Z","1.0.7":"2017-02-28T22:55:56.925Z","1.0.8":"2017-03-01T18:17:26.814Z","1.1.0":"2017-03-06T02:55:07.208Z","1.1.1":"2017-03-06T03:20:55.184Z","1.1.2":"2017-03-06T04:38:22.371Z","1.1.25":"2017-03-06T20:14:32.384Z","1.1.26":"2017-03-08T17:33:31.320Z","1.1.27":"2017-03-08T18:12:32.948Z","1.1.28":"2017-03-14T00:27:12.629Z","1.1.29":"2017-03-16T23:01:35.849Z","1.1.30":"2017-03-19T21:47:46.012Z","1.1.31":"2017-03-20T12:33:00.604Z","1.1.32":"2017-03-21T16:08:21.744Z","1.1.33":"2017-03-21T16:11:10.710Z","1.1.34":"2017-03-24T14:50:33.576Z","1.1.35":"2017-05-03T16:27:48.202Z","1.1.36":"2017-05-03T16:51:40.638Z","1.1.37":"2017-05-03T19:33:39.133Z","1.1.38":"2017-05-03T20:01:02.255Z","1.1.39":"2017-05-04T15:55:35.838Z","1.1.40":"2017-05-04T16:14:28.078Z","1.1.41":"2017-05-04T16:17:59.746Z","1.1.42":"2017-05-05T12:42:32.846Z","1.1.43":"2017-05-05T12:49:27.462Z","1.1.44":"2017-05-07T21:55:01.756Z","1.1.45":"2017-05-07T23:31:42.240Z","1.1.46":"2017-06-28T21:02:03.642Z","1.1.47":"2017-06-29T00:12:07.331Z","1.1.48":"2017-06-29T21:20:39.376Z","1.1.49":"2017-06-29T21:40:39.615Z","1.1.50":"2017-06-29T22:48:46.308Z","1.1.51":"2017-07-01T22:12:52.079Z","1.1.52":"2017-07-03T20:33:54.444Z","1.1.53":"2017-07-09T13:00:38.182Z","1.1.54":"2017-08-11T17:22:19.827Z","1.1.55":"2017-08-21T14:59:20.229Z"},"users":{"edolabworks":true}}}