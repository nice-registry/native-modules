{"name":"genx","version":"1.2.3","description":"Evented XML generation using the Genx C library","keywords":["xml","generation","generator","builder"],"homepage":"http://node-genx.wezm.net/","repository":"https://github.com/wezm/node-genx","main":"./lib/genx","engines":{"node":">=0.8.0"},"license":"BSD-3-Clause","licenses":[{"type":"BSD","url":"https://github.com/wezm/node-genx/blob/master/LICENSE"}],"scripts":{"clean":"(mkdir build || rm -rf build) && mkdir -p build","cmake":"cd build && cmake .. && make -j","cmake-debug":"cd build && cmake -DCMAKE_BUILD_TYPE=Debug .. && make -j","test":"mocha","install":"node-gyp rebuild"},"optionalDependencies":{"node-cmake":"1.x"},"devDependencies":{"mocha":"1.8.x","should":"1.2.x"},"dependencies":{"events":"*","nan":"2.x","node-cmake":"1.x"},"gypfile":true,"gitHead":"ca4f6447b0c6dbb038e4962fc8681036dbb3272d","versions":[{"number":"0.8.1","date":"2011-01-26T16:45:37.856Z"},{"number":"0.8.2","date":"2011-02-24T15:53:12.119Z"},{"number":"0.8.3","date":"2011-06-22T02:54:16.614Z"},{"number":"0.9.0","date":"2012-03-01T03:25:44.727Z"},{"number":"1.0.0","date":"2013-01-17T06:52:33.342Z"},{"number":"1.2.2","date":"2016-01-06T19:15:26.135Z"},{"number":"1.2.3","date":"2016-01-06T19:34:44.000Z"}],"readme":"[![Build Status](https://travis-ci.org/wezm/node-genx.svg)](https://travis-ci.org/wezm/node-genx)\n[![Build Status](https://ci.appveyor.com/api/projects/status/ssdjt6ugn8fsq1t8?svg=true)](https://ci.appveyor.com/project/PMLavigne/node-genx-3jhvy)\n\n# node-genx\n\n[node.js][node] bindings to the [Genx][genx] XML generation library.\n\n[node]: http://nodejs.org/\n[genx]: http://www.tbray.org/ongoing/When/200x/2004/02/20/GenxStatus\n[npm]: http://npmjs.org/\n\nInstalling\n----------\n\n    npm install genx\n\nBuilding From Source\n--------------------\n\nThere are a few ways to build this project:\n* Running `npm install` in the node-genx root directory should automatically trigger a build. You\n  should do this at least once regardless of which build method you wind up using since there are\n  some necessary dependencies npm must install before compilation.\n* If you have [node-gyp][gyp] installed, you can run `node-gyp configure build`\n* If you have [cmake][cmake] 3.1 or higher and Node.js 0.10 or higher, you can build using cmake:\n```bash\n  mkdir -p build\n  cd build\n  cmake ..\n```\n* Scripts are included to automate this process. They also require the `make` command to be present:\n  * Normal build: `npm run-script clean && npm run-script cmake`\n  * Debug build`npm run-script clean && npm run-script cmake-debug`\n\n\n[gyp]: https://github.com/TooTallNate/node-gyp\n[cmake]: https://cmake.org/\n\nExample\n-------\n\nThe following complete example uses Genx to reproduce the [brief, single-entry\nAtom Feed Document][specdoc] in the Atom spec. The result is written to stdout.\n\n[specdoc]: http://www.atomenabled.org/developers/syndication/atom-format-spec.php#rfc.section.1.1\n[xmllint]: http://xmlsoft.org/xmllint.html\n[libxml2]: http://xmlsoft.org/\n\n```node\nvar genx = require('genx');\n\n// Passing \"true\" to the constructor indicates we want to nicely format the output\nvar w = new genx.Writer(true);\n\nw.on('data', function(data) {\n  process.stdout.write(data);\n});\n\n// Declare the elements and attributes up-front\nvar ns      = w.declareNamespace('http://www.w3.org/2005/Atom', '');\nvar feed    = w.declareElement(ns, 'feed');\nvar title   = w.declareElement(ns, 'title');\nvar link    = w.declareElement(ns, 'link');\nvar updated = w.declareElement(ns, 'updated');\nvar author  = w.declareElement(ns, 'author');\nvar name    = w.declareElement(ns, 'name');\nvar id      = w.declareElement(ns, 'id');\nvar entry   = w.declareElement(ns, 'entry');\nvar summary = w.declareElement(ns, 'summary');\n\nvar href    = w.declareAttribute('href');\n\n// This is not a processing instruction and as such can't be generated by Genx\nprocess.stdout.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\");\nw.startDocument()\n  .startElement(feed)\n    .startElement(title).addText(\"Example Feed\").endElement()\n    .startElement(link).addAttribute(href, \"http://example.org/\").endElement()\n    .startElement(updated).addText(\"2003-12-13T18:30:02Z\").endElement()\n    .startElement(author)\n      .startElement(name).addText(\"John Doe\").endElement()\n    .endElement()\n    .startElement(id).addText(\"urn:uuid:60a76c80-d399-11d9-b93C-0003939e0af6\").endElement()\n    .startElement(entry)\n      .startElement(title).addText(\"Atom-Powered Robots Run Amok\").endElement()\n      .startElement(link).addAttribute(href, \"http://example.org/2003/12/13/atom03\").endElementInline()\n      .startElement(id).addText(\"urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a\").endElement()\n      .startElement(updated).addText(\"2003-12-13T18:30:02Z\").endElement()\n      .startElement(summary).addText(\"Some text.\").endElement()\n    .endElement()\n  .endElement()\n.endDocument();\n```\n\nTo run the above example:\n\n    node examples/atom.js\n\nFor more examples see, [Generating XML With node.js](http://www.wezm.net/technical/2011/01/generating-xml-with-node-js/).\n\nAPI\n---\n\nThe API pretty closely follows the underlying [Genx library's API][libapi].\nThis module exports one object, `Writer`, which you use to generate XML. Any\nerrors encountered are raised as exceptions.\n\n[libapi]: http://www.tbray.org/ongoing/genx/docs/Guide.html\n\n**Note:** Each of the following examples assumes the module has been imported\nand a `Writer` created as follows:\n\n```node\nvar genx = require('genx');\nvar writer = new genx.Writer();\n```\n\n### Events\n\nThe `Writer` emits data events with a single string argument containing an XML\nfragment. You listen for data events in order to make use of the generated XML.\n\n```node\nwriter.on('data', function(data) {\n  // Do something with the data such as write it to a file\n});\n```\n\nFor more information on how to use streams, consult the [Node Streams API][nstreamapi]\ndocumentation.\n\n[nstreamapi]: https://nodejs.org/api/stream.html\n\n### Writer\n\nThe Writer class provides the primary interface to Genx. Call writer methods to\ngenerate XML. XML can be generated via literal nodes (elements, attributes) or\nby reusing pre-declared nodes. The Genx documentation claims that using\npredeclared nodes are more efficient. Where it makes sense the methods return\n`this` allowing calls to be chained. For example:\n\n```node\nwriter.startDocument().startElement(elem);\n```\n\n---\n\n#### new Writer([prettyPrint], [newLine], [spacer])\n\nConstructs a new Writer object.\n\n**Arguments**\n* prettyPrint (optional, boolean) -- Output human-readable / indented XML.\n  Defaults to `false`\n* newLine (optional, String) -- Character(s) to use as the newline character\n  when prettyPrint is enabled. Defaults to `\\n`\n* spacer (optional, String) -- Character(s) to use to indent lines when\n  prettyPrint is enabled. Defaults to `\\t`\n\n**Return Value**\n\nReturns the created Writer\n\n**Example**\n\n```node\n// No output formatting\nvar writer = new genx.Writer();\n\n// PrettyPrint with the default \\n newlines and \\t to indent\nvar writer = new genx.Writer(true);\n\n// PrettyPrint with \\r\\n newlines and four spaces to indent\nvar writer = new genx.Writer(true, \"\\r\\n\", \"    \");\n```\n\n---\n\n#### startDocument()\n\nStarts an XML document. Must be called before any elements can be added. This\nmethod may be called on a `Writer` multiple times after completing each\ndocument with `endDocument` in order to re-use a `Writer` and generate multiple\ndocuments.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n```node\nwriter.startDocument();\n```\n\n---\n\n#### endDocument()\n\nEnds a document previously started with `startDocument`. Must be called after\n`startDocument` and after any open elements have been closed.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n```node\nwriter.startDocument().endDocument();\n```\n\n---\n\n#### declareNamespace(uri, [prefix])\n\nDeclares a namespace for later use in `declareElement`.\n\n**Arguments**\n\n* uri (mandatory, String) -- the uri of the namespace\n* prefix (optional, String) -- the prefix that will be used for elements in\n  this namespace.  If the prefix is omitted Genx will generate one for you.\n  Generated prefixes are of the form \"gN\", where N starts at 1. If prefix is\n  the empty string, `\"\"`, then this namespace will be set as the default\n  namespace.\n\n**Return Value**\n\nReturns a `Namespace` object for later use with `declareElement`.\n\n**Examples**\n\n```node\n// Namespace with prefix\nvar ns = writer.declareNamespace('http://www.w3.org/2005/Atom', \"atom\");\n\n// Default namespace\nvar ns = writer.declareNamespace('http://www.w3.org/2005/Atom', \"\");\n\n// Generated prefix\nvar ns = writer.declareNamespace('http://www.w3.org/2005/Atom');\n```\n\n### declareElement([namespace], name)\n\nDeclares an element with name `name` in namespace `namespace`. If\nno namespace is supplied then the element is in no namespace.\n\n**Arguments**\n\n* namespace (optional, Namespace) -- The namespace the element belongs to. Must\n  be a `Namespace` object returned by `declareNamespace`.\n* name (mandatory, String) -- The name of the element a.k.a. tag.\n\n**Return Value**\n\nReturns an `Element` object for later use with `startElement`.\n\n**Examples**\n\n```node\n// Element without a namespace\nvar elem = writer.declareElement('test');\n\n// Namespaced element\nvar ns = writer.declareNamespace('http://www.w3.org/2005/Atom', \"\");\nvar elem = writer.declareElement(ns, 'feed');\n```\n\n---\n\n#### declareAttribute([namespace], name)\n\nDeclares an attribute with name `name` in namespace `namespace`. If no\nnamespace is supplied then the attribute is in no namespace.\n\n**Arguments**\n\n* namespace (optional, String) -- The namespace the attribute belongs to. Must\n  be a `Namespace` object returned by `declareNamespace`.\n* name (mandatory, String) -- The name of the attribute. The value is supplied\n  later via `addAttribute`.\n\n**Return Value**\n\nReturns an `Attribute` object for later use with `addAttribute`.\n\n**Examples**\n\n```node\n// Attribute without a namespace\nvar elem = writer.declareElement('type');\n\n// Namespaced attribute\nvar ns = writer.declareAttribute('http://www.w3.org/2005/Atom', \"\");\nvar elem = writer.declareAttribute(ns, 'type');\n```\n\n---\n\n#### startElement(element)\n\nOpens the element `element`.\n\n**Arguments**\n\n* element (mandatory, Element) -- The element to open. Must be an `Element`\n  object previously declared via `declareElement`.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n```node\nvar elem = writer.declareElement('feed');\n\nwriter.startDocument()\n        .startElement(elem)\n        .endElement()\n      .endDocument()\n```\n\n---\n\n#### startElementLiteral([namespace], name)\n\nOpens an element with name, `name` in namespace `namespace` (a URI) without\npre-declaring it.  The Genx documentation claims that pre-declaring is more\nefficient, especially if the element is emitted multiple times.\n\n**Arguments**\n\n* namespace (optional, String) -- A namespace URI that the element belongs to.\n  If a prefix for this namespace has previously been declared via\n  `declareNamespace` then that prefix will be used, otherwise Genx will\n  generate one of the form described in `declareNamespace`.\n* name (mandatory, String) -- The name of the element to start.\n\n**Return Value**\n\nReturns the receiver.\n\n**Examples**\n\n```node\n// Without a namespace\nwriter.startDocument()\n        .startElementLiteral('feed')\n        .endElement()\n      .endDocument()\n\n// With a namespace\nwriter.startDocument()\n        .startElementLiteral('http://www.w3.org/2005/Atom', 'feed')\n        .endElement()\n      .endDocument()\n```\n\n---\n\n#### addText(text)\n\nAdds a text node to the document.\n\n**Arguments**\n\n* text (mandatory, String) -- The text to add to the document.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n```node\nwriter.startDocument()\n        .startElementLiteral('feed')\n          .addText(\"Some text\")\n        .endElement()\n      .endDocument()\n```\n\n---\n\n#### addComment(comment)\n\n**Arguments**\n\n* comment (mandatory, String) -- The comment text to add to the document.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n```node\nwriter.startDocument()\n        .addComment(\"Generated \" + (new Date()).toString())\n        .startElementLiteral('feed')\n        .endElement()\n      .endDocument();\n```\n\n---\n\n#### addAttribute(attribute, value)\n\n**Arguments**\n\n* attribute (mandatory, Attribute) -- The attribute to add to the document.\n  Must be an `Attribute` object previously declared via `declareAttribute`.\n* value (mandatory, String) -- The attribute's value.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n```node\nvar ns = writer.declareNamespace('http://www.w3.org/2005/Atom', '');\nvar feed = writer.declareElement(ns, 'feed');\nvar title = writer.declareElement(ns, 'title');\nvar type = writer.declareAttribute('type');\n\nwriter.startDocument()\n        .startElement(feed)\n          .startElement(title)\n            .addAttribute(type, 'text')\n            .addText(\"Test Title\")\n          .endElement()\n        .endElement()\n      .endDocument();\n```\n\n---\n\n#### addAttributeLiteral([namespace], name, value)\n\n**Arguments**\n\n* namespace (optional, String) -- A namespace URI that the attribute belongs\n  to.  If a prefix for this namespace has previously been declared via\n  `declareNamespace` then that prefix will be used, otherwise Genx will\n  generate one of the form described in `declareNamespace`.\n* name (mandatory, String) -- The attribute's name.\n* value (mandatory, String) -- The attribute's value.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n```node\nvar ns = writer.declareNamespace('http://www.w3.org/2005/Atom', '');\nvar feed = writer.declareElement(ns, 'feed');\nvar title = writer.declareElement(ns, 'title');\n\nwriter.startDocument()\n        .startElement(feed)\n          .startElement(title)\n            .addAttributeLiteral('type', 'text')\n            .addText(\"Test Title\")\n          .endElement()\n        .endElement()\n      .endDocument();\n```\n\n---\n\n#### endElement()\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n```node\nwriter.startDocument()\n        .startElementLiteral('feed')\n        .endElement()\n      .endDocument()\n```\n\n---\n\n#### endElementInline()\n\nEnds an element as an inline / \"self-closing\" tag. The element must only\ncontain attributes, or an exception is thrown.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n```node\nwriter.startDocument()\n        .startElementLiteral('feed')\n          .addAttributeLiteral('an-attribute', 'attribute-value')\n        .endElementInline()\n      .endDocument()\n```\n\nRunning the Tests\n-----------------\n\nThis project has a test suite in the `test` directory. It utilises the\n[Mocha][mocha] test framework. To run the suite you need to have the\n`mocha` and `should` modules installed:\n\n    npm install -g mocha\n    npm install should\n\n[mocha]: http://visionmedia.github.com/mocha/\n\nThe suite is run by running `mocha` in the project root:\n\n    % mocha\n\n      ...................................\n\n      42 passing (23ms)\n\nThere is also a Guardfile present that enables automatically rebuilding\nthe module and running the tests when one of the source files\nchange. To use this you need the `guard` and `guard-shell` Ruby gems\ninstalled. This can be done as follows:\n\n    gem install guard guard-shell\n\nThen run `guard` in the project root.\n\nContributors\n------------\n\n* Morten Siebuhr -- https://github.com/msiebuhr\n  * Applied fix for node-waf configuration errors on Linux\n* Patrick Lavigne -- https://github.com/PMLavigne\n  * Rewrote project to use Nan for compatibility with node 4+\n  * Added PrettyPrint output\n  * Merged in [inline tags PR][jaydata-pr] from [jaydata][jaydata]\n\n[jaydata-pr]: https://github.com/wezm/node-genx/pull/8\n[jaydata]: https://github.com/jaydata\n\nChangelog\n---------\n\n* 1.2.2 -- 04 Jan 2016\n  * \"PrettyPrint\" formatting\n  * Inline Tags\n  * Nan-based rewrite for node.js 4+ support\n* 1.0.0 -- 17 Jan 2013\n  * Update to support node 0.8.x\n* 0.9.0 -- 31 Jan 2012\n  * Update to support node 0.6.x\n* 0.8.3 -- 22 Jun 2011\n  * Fix build issues on Linux\n* 0.8.2 -- 25 Feb 2011\n  * Fix trailing comma in package.json\n","starsCount":1,"created":"2011-01-26T16:45:16.656Z","modified":"2016-01-06T19:34:53.897Z","lastPublisher":{"name":"pmlavigne","email":"me@patrick.codes"},"owners":[{"name":"pmlavigne","email":"me@patrick.codes"},{"name":"wezm","email":"wes@wezm.net"}],"other":{"_attachments":{},"_from":".","_id":"genx","_nodeVersion":"0.10.24","_npmUser":{"name":"pmlavigne","email":"me@patrick.codes"},"_npmVersion":"3.3.12","_rev":"1-9298a13fc6121557e535f2194c2115dd","_shasum":"ad668213d75a5fad9a43797d657fd760a6becc05","author":{"name":"Wesley Moore","email":"wes@wezm.net","url":"http://www.wezm.net/"},"bugs":{"url":"https://github.com/wezm/node-genx/issues"},"contributors":[{"name":"Patrick Lavigne","email":"me@patrick.codes","url":"https://github.com/PMLavigne"},{"name":"Morten Siebuhr","url":"https://github.com/msiebuhr"},{"name":"JayData","url":"https://github.com/jaydata"}],"directories":{},"dist-tags":{"latest":"1.2.3"},"dist":{"shasum":"ad668213d75a5fad9a43797d657fd760a6becc05","tarball":"http://registry.npmjs.org/genx/-/genx-1.2.3.tgz"},"maintainers":[{"name":"pmlavigne","email":"me@patrick.codes"},{"name":"wezm","email":"wes@wezm.net"}],"readmeFilename":"README.markdown","time":{"modified":"2016-01-06T19:34:53.897Z","created":"2011-01-26T16:45:16.656Z","0.8.1":"2011-01-26T16:45:37.856Z","0.8.2":"2011-02-24T15:53:12.119Z","0.8.3":"2011-06-22T02:54:16.614Z","0.9.0":"2012-03-01T03:25:44.727Z","1.0.0":"2013-01-17T06:52:33.342Z","1.2.2":"2016-01-06T19:15:26.135Z","1.2.3":"2016-01-06T19:34:44.000Z"},"users":{"pmlavigne":true}}}