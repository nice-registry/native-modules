{"name":"usocket","version":"0.0.3","description":"unix local sockets with descriptor passing","main":"index.js","scripts":{"test":"mocha -R spec","install":"node-gyp rebuild"},"repository":"https://github.com/jhs67/usocket","keywords":["unix","local","socket","file","descriptor"],"license":"ISC","homepage":"https://github.com/jhs67/usocket#readme","devDependencies":{"mocha":"^3.0.0"},"dependencies":{"bindings":"^1.2.1","nan":"^2.2.0"},"gypfile":true,"gitHead":"301b1fc812d81d00e5ec9fcf54371766f7e710b7","versions":[{"number":"0.0.1","date":"2016-04-11T22:35:38.480Z"},{"number":"0.0.3","date":"2017-08-23T21:41:42.964Z"}],"readme":"#USocket\n\n## Overview\n\nThe native node.js socket supports creating unix domain sockets, but\nthey do not support passing file descriptors. This module includes\nreplacements for net.Server and net.Socket that extend the API\nto allow passing file descriptors.\n\n### Table of Contents\n\n * [Quick Start](#quick-start)\n * [UServer](#class-usocketuserver)\n * [USocket](#class-usocketusocket)\n\n## Quick Start\n\n#### Installation\n\n```shell\nnpm install usocket\n```\n\n#### Quick Usage.\n\n```js\nvar fs = require('fs');\nvar usocket = require('usocket');\n\nvar server = new usocket.UServer();\nvar client = new usocket.USocket();\n\nserver.listen(__dirname + \"/socket\", function() {\n  client.connect(__dirname + \"/socket\");\n});\n\nserver.on('connection', function(connection) {\n  var msg = new Buffer(\"message\");\n  var fd = fs.openSync(__filename, \"r\");\n  setTimeout(function() {\n  \tconnection.end({ data: msg, fds: [fd], callback: function() { fs.close(fd); } });\n  }, 500);\n});\n\nclient.on('connected', function() { client.read(0); });\n\nclient.on('readable', function() {\n  var msg = client.read(7, 1);\n  if (!msg) return;\n  fs.close(msg.fds[0]);\n  server.close();\n  client.end();\n})\n```\n\n## Class: usocket.UServer\n\nThe UServer class largely mimics the behavior of the native net.Server, but\nthe `'connection'` event will create [`usocket.USockets`](#class-usocketusocket).\n\n### Event: 'connection'\n\n * USocket object - the newly connected socket\n\nEmitted on receipt of a new connection. The only argument is a new instance\nof usocket.USocket.\n\n### Event: 'error'\n\nEmitted when there is an error on the socket.\n\n### Event: 'listening'\n\nEmitted when the socket is ready to accept connections.\n\n### server.listen(path[, backlog][, callback])\n\nStart a local socket server listening for connection on the supplied path.\nThe optional callback will be set as a listener of the `'listening'` event.\n\n### server.listen(options[, callback])\n\n * options Object:\n  * path: the file system path to listen on\n  * backlog: the accept backlog\n\nStart a local socket server listening for connection on the supplied path.\nThe optional callback will be installed as a listener of the `'listening'` event.\n\n### server.pause\n\nCauses the server to pause accepting new connections. No more `'connection'` events\nwill be emitted until `resume` is called.\n\n### server.resume\n\nResumes accepting connections on a paused server.\n\n### server.close\n\nCloses the connection. No further events will be emitted. Unlike the native\nnet.Server there is no `'close'` event and the accepted connections are not\ntracked.\n\n## Class: usocket.USocket\n\nThe USocket class mirrors the net.Socket class but extends the API of several\nmethods. A USocket implements the Duplex stream interface.\n\n### new usocket.USocket([options][, callback])\n\nConstructs a new USocket object. If the options object is provided, the\n[`connect`](#socketconnect) method will be called immeditately.\n\n### Event: 'connected'\n\nThe event is emitted without arguments when the socket is connected.\n\n### Event: 'error'\n\nThis event indicates an error occurred on the socket. The 'close' event will\nfollow.\n\n### Event: 'close'\n\nThis event is emitted when the socket is completely closed and no more\nevents will be generated and no more data may be sent.\n\n### Event: 'readable'\n\nThis event is emitted as a readable stream and when there\nare new file descriptors available for reading.\n\n### socket.connect(path[, callback])\n\nConnect to the unix domain server at the supplied path. The optional `callback`\nwill be set as a listener of the `'connected'` event.\n\n### socket.read([length])\n\nImplements the readable stream API.\n\n### socket.read(length, count)\n\nWhen an optional second argument is provided to the read method its operation\nis modified. The `length` argument indicates the amount of data to be read from\nthe stream. If `length` is null then all the available data will be returned.\n\nThe `count` argument indicates the number of file descriptors to be read from\nthe stream. If `count` is null all available descriptors will be read. `count`\nis allowed to be zero.\n\nIf either the data or descriptors isn't available, the call will return\nnull. Otherwise the two argument read returns an object instead of a buffer.\n * return Object:\n  * data: the data read from the stream (as per the readable stream API)\n  * fds: an array of file descriptors read from the stream\n\n### socket.unshift(buffer, fds)\n\nThe `buffer` will put back on the the data read stream as per the readable\nstream interface. The optional `fds` is an array of file descriptors that\nwill be put back onto the stream for subsequent reads.\n\n### socket.write(buffer)\n\nImplements the writable stream API.\n\n### socket.write(array)\n\nWriting an array of integers will send file descriptors across the socket.\nThe file descriptors must be kept open until the data is sent.\n\n### socket.write(options)\n\nPassing an options object to write allows simultaneously writing data and\nfile descriptors.\nIt also provides a means to know when the data has been sent and it is safe\nto close the file descriptors.\n * options Object\n  * data: (optional) a buffer of data to send.\n  * fds: (optional) an array of file descriptors to send.\n  * callback: (optional) called when the data has been sent.\n\n### socket.destroy()\n\nCloses the socket. No further events will be emitted.\n","created":"2016-04-11T22:35:38.480Z","modified":"2017-08-23T21:41:42.964Z","lastPublisher":{"name":"jhs67","email":"jon@jonspencer.ca"},"owners":[{"name":"jhs67","email":"jon@jonspencer.ca"}],"other":{"_attachments":{},"_id":"usocket","_nodeVersion":"8.4.0","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/usocket-0.0.3.tgz_1503524502608_0.2787130263168365"},"_npmUser":{"name":"jhs67","email":"jon@jonspencer.ca"},"_npmVersion":"5.3.0","_rev":"2-8d13028a6ffeb2e2f98a2d52e5f77158","author":{"name":"Jon Spencer","email":"jon@jonspencer.ca"},"bugs":{"url":"https://github.com/jhs67/usocket/issues"},"directories":{},"dist-tags":{"latest":"0.0.3"},"dist":{"integrity":"sha512-LUDZP/iJtJktBmLVbv0yLlFEi+0109U7Zq9oQWSwCTWRkyvQPJK3v8xc7+WNv3X/9V4UBq/MLu/ywDFeTMIVZQ==","shasum":"a492d6cf72622ca5a6d7aed130b0894feacdeef6","tarball":"https://registry.npmjs.org/usocket/-/usocket-0.0.3.tgz"},"maintainers":[{"name":"jhs67","email":"jon@jonspencer.ca"}],"readmeFilename":"README.md","time":{"modified":"2017-08-23T21:41:42.964Z","created":"2016-04-11T22:35:38.480Z","0.0.1":"2016-04-11T22:35:38.480Z","0.0.3":"2017-08-23T21:41:42.964Z"}}}