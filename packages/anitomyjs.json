{"name":"anitomyjs","version":"1.4.2","description":"Node.js binding for the Anitomy anime video filename parsing library","main":"anitomy.js","scripts":{"test":"mocha test/test.js","install":"cmake-js compile"},"repository":"https://github.com/Xtansia/node.anitomy.js","keywords":["anitomy","anime","anime filename parsing","filename parsing","parsing","native binding"],"license":"MPL-2.0","homepage":"https://github.com/Xtansia/node.anitomy.js#readme","dependencies":{"bindings":"^1.2.1","boost-lib":"^0.11.3","cmake-js":"^3.3.1","nan":"^2.4.0"},"devDependencies":{"JSONStream":"^1.2.1","async":"^2.1.2","chai":"^3.5.0","event-stream":"^3.3.4","mocha":"^3.1.2"},"engines":{"node":">= 0.10.0"},"gitHead":"774c846f8e6dbbc7b69af3e381d35fa6c332625b","readme":"# node.anitomy.js\n[![License](https://img.shields.io/badge/license-MPL--2.0-blue.svg?style=flat-square&maxAge=2592000)](https://github.com/Xtansia/node.anitomy.js/raw/master/LICENSE)\n[![Linux & OSX Build Status](https://img.shields.io/travis/Xtansia/node.anitomy.js/master.svg?label=linux+%26+osx&style=flat-square&maxAge=2592000)](https://travis-ci.org/Xtansia/node.anitomy.js)\n[![Windows Build Status](https://img.shields.io/appveyor/ci/Xtansia/node-anitomy-js/master.svg?label=windows&style=flat-square&maxAge=2592000)](https://ci.appveyor.com/project/Xtansia/node-anitomy-js)  \n[![NPM](https://nodei.co/npm/anitomyjs.png)](https://nodei.co/npm/anitomyjs/)  \n*node.anitomy.js* is a Node.js binding for\n[Anitomy](https://github.com/erengy/anitomy) a C++ library for parsing anime\nvideo filenames.\n\n## Installing\nYou can install *node.anitomy.js* as a dependency of your project using NPM like\nso, provided you have met the dependencies listed below.\n```\n> npm install --save anitomyjs\n```\n\n### Dependencies\n* Node.JS >= 0.10.0\n  - Can also be used with [NW.js](https://github.com/nwjs/nw.js) and \n    [Electron](https://github.com/atom/electron) by setting the desired runtime\n    in your applications `package.json` as explained \n    [here](https://github.com/cmake-js/cmake-js#runtimes).\n* CMake >= 3.2\n* A C++11 compatible compiler\n  - GCC >= 4.9\n  - Clang >= 3.3 (Probably?)\n  - [Visual Studio 2015](https://www.visualstudio.com/products/vs-2015-product-editions) \n    OR [Visual C++ Build Tools](http://landinghub.visualstudio.com/visual-cpp-build-tools)\n\n### Note About Installing/Building\nBefore building the binding, the buildscript will test if the compiler supports \nthe `<codecvt>` header, if it doesn't, like GCC-4.9, the buildscript will \nautomatically enable using Boost::Locale, downloading and building Boost using \n[boost-lib](https://github.com/cmake-js/boost-lib). You can force using \nBoost::Locale by using `npm config` before installing or compiling like so:\n```\n> npm config set cmake_NODE_ANITOMY_USE_BOOST ON\n```\n\n## Example Usage\n```javascript\nconst anitomy = require('anitomyjs');\n\nconst filename = '[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD].mkv';\n\nconst elems = anitomy.parseSync(filename);\n\nconsole.log(elems.AnimeTitle + ' #' + elems.EpisodeNumber + \n            ' by ' + elems.ReleaseGroup);\n```\nWould output:\n```\nToradora! #01 by TaigaSubs\n```\n\n## API\n### parse(filenames[, options], callback)\nParses the filenames asynchronously.\n* `filenames` must be either a string, or an array of strings.\n* `options` is optional, if provided it must be an object, as set out\n  [here](#parse-options).\n* `callback` must be a function, will be called passing the resulting elements\n  as the first parameter.\n  - If `filenames` was an array, then the passed value will be an array of\n    [AnitomyElements](#anitomyelements), with the same ordering as `filenames`.\n  - If `filenames` was a string, then the passed value will be an\n    [AnitomyElements](#anitomyelements).\n```javascript\nconst filename = '[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD].mkv';\nanitomy.parse(filename, function (elems) {\n  console.log(elems.AnimeTitle + ' #' + elems.EpisodeNumber + \n              ' by ' + elems.ReleaseGroup);\n});\n```\nWould output:\n```\nToradora! #01 by TaigaSubs\n```\n\n### parseSync(filenames[, options])\nParses the filenames synchronously.\n* `filenames` must be either a string, or an array of strings.\n* `options` is optional, if provided it must be an object, as set out \n  [here](#parse-options).\n* Returns:\n  - If `filenames` was an array, then the returned value will be an array of\n    [AnitomyElements](#anitomyelements), with the same ordering as `filenames`.\n  - If `filenames` was a string, then the returned value will be an\n    [AnitomyElements](#anitomyelements).\n```javascript\nconst filename = '[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD].mkv';\nconst elems = anitomy.parseSync(filename);\nconsole.log(elems.AnimeTitle + ' #' + elems.EpisodeNumber + \n            ' by ' + elems.ReleaseGroup);\n```\nWould output:\n```\nToradora! #01 by TaigaSubs\n```\n\n### parseEach(filenames[, options], callback)\nParses each of the individual filenames asynchronously, as opposed to \n[parse](#parsefilenames-options-callback) which parses them all in bulk. As it\nis asynchronous there is no ordering ensured.\n* `filenames` must be either a string, or an array of strings.\n* `options` is optional, if provided it must be an object, as set out\n  [here](#parse-options).\n* `callback` must be a function, will be called when each filename is parsed,\n  passing the filename and the resulting [AnitomyElements](#anitomyelements) as\n  the first and second parameters respectively.\n```javascript\nconst filenames = [\n  '[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD].mkv',\n  '[ANBU]_Princess_Lover!_-_01_[2048A39A].mkv',\n  '[ANBU-Menclave]_Canaan_-_01_[1024x576_H.264_AAC][12F00E89].mkv',\n  '[ANBU-umai]_Haiyoru!_Nyaru-Ani_[596DD8E6].mkv'\n];\nanitomy.parseEach(filenames, function (filename, elems) {\n  console.log(filename + '\\n\\t=> ' + elems.AnimeTitle + ' #' + elems.EpisodeNumber + \n              ' by ' + elems.ReleaseGroup);\n});\n```\nWould output (though not necessarily in this order):\n```\n[ANBU]_Princess_Lover!_-_01_[2048A39A].mkv\n  => Princess Lover! #01 by ANBU\n[ANBU-Menclave]_Canaan_-_01_[1024x576_H.264_AAC][12F00E89].mkv\n  => Canaan #01 by ANBU-Menclave\n[ANBU-umai]_Haiyoru!_Nyaru-Ani_[596DD8E6].mkv\n  => Haiyoru! Nyaru-Ani #undefined by ANBU-umai\n[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD].mkv\n  => Toradora! #01 by TaigaSubs\n```\n\n### parseEachSync(filenames[, options], callback)\nSame as [parseEach](#parseeachfilenames-options-callback) but synchronous, i.e.\ncalls callback for each parsed filename, then returns. `callback` is ensured to\nbe called in the same order as `filenames`.\n* `filenames` must be either a string, or an array of strings.\n* `options` is optional, if provided it must be an object, as set out\n  [here](#parse-options).\n* `callback` must be a function, will be called when each filename is parsed,\n  passing the filename and the resulting [AnitomyElements](#anitomyelements) as\n  the first and second parameters respectively.\n```javascript\nconst filenames = [\n  '[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD].mkv',\n  '[ANBU]_Princess_Lover!_-_01_[2048A39A].mkv',\n  '[ANBU-Menclave]_Canaan_-_01_[1024x576_H.264_AAC][12F00E89].mkv',\n  '[ANBU-umai]_Haiyoru!_Nyaru-Ani_[596DD8E6].mkv'\n];\nanitomy.parseEachSync(filenames, function (filename, elems) {\n  console.log(filename + '\\n\\t=> ' + elems.AnimeTitle + ' #' + elems.EpisodeNumber + \n              ' by ' + elems.ReleaseGroup);\n});\nconsole.log('parseEachSync completed');\n```\nWould output:\n```\n[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD].mkv\n  => Toradora! #01 by TaigaSubs\n[ANBU]_Princess_Lover!_-_01_[2048A39A].mkv\n  => Princess Lover! #01 by ANBU\n[ANBU-Menclave]_Canaan_-_01_[1024x576_H.264_AAC][12F00E89].mkv\n  => Canaan #01 by ANBU-Menclave\n[ANBU-umai]_Haiyoru!_Nyaru-Ani_[596DD8E6].mkv\n  => Haiyoru! Nyaru-Ani #undefined by ANBU-umai\nparseEachSync completed\n```\n\n### Parse Options\nOptions are given in the form of an object, with any or all of the following \nproperties set, if unset they default to these values (Anitomy's defaults):\n```javascript\n{\n  allowedDelimiters: ' _.&+,|',\n  ignoredStrings: [],\n  parseEpisodeNumber: true,\n  parseEpisodeTitle: true,\n  parseFileExtension: true,\n  parseReleaseGroup: true\n}\n```\n\n### AnitomyElements\nThis object represents the parsed elements of the filename. With a property for\neach [ElementCategory](#element-categories) that it has a value for, the \nproperties are immutable. In cases where there are multiple elements in a \ncategory the property's value will be an array.\n```javascript\nAnitomyElements {\n  AnimeTitle: 'Toradora!',\n  AnimeYear: '2008',\n  AudioTerm: 'FLAC',\n  EpisodeNumber: '01',\n  EpisodeTitle: 'Tiger and Dragon',\n  FileChecksum: '1234ABCD',\n  FileExtension: 'mkv',\n  FileName: '[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD]',\n  ReleaseGroup: 'TaigaSubs',\n  ReleaseVersion: '2',\n  VideoResolution: '1280x720',\n  VideoTerm: 'H.264' }\n```\n\n#### AnitomyElements#empty([category])\nReturns true if the AnitomyElements has no category-value pairs.\n* `category` is optional, if provided must be a string representing an\n  [ElementCategory](#element-categories), return value will then be true if the \n  AnitomyElements has no values for that category.\n```javascript\nconst filename = '[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD].mkv';\nconst elems = anitomy.parseSync(filename);\n/* -> AnitomyElements {\n  AnimeTitle: 'Toradora!',\n  AnimeYear: '2008',\n  AudioTerm: 'FLAC',\n  EpisodeNumber: '01',\n  EpisodeTitle: 'Tiger and Dragon',\n  FileChecksum: '1234ABCD',\n  FileExtension: 'mkv',\n  FileName: '[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD]',\n  ReleaseGroup: 'TaigaSubs',\n  ReleaseVersion: '2',\n  VideoResolution: '1280x720',\n  VideoTerm: 'H.264' } */\nconst isEmpty = elems.empty();\n// -> false\nconst hasNoVolumeNumber = elems.empty('VolumeNumber');\n// -> true\n```\n\n#### AnitomyElements#count(category)\nReturns the number of values associated with the category in this AnitomyElements.\n* `category` must be a string representing an [ElementCategory](#element-categories).\n```javascript\nconst filename = 'Detective Conan - 316-317 [DCTP][2411959B].mkv';\nconst elems = anitomy.parseSync(filename);\n/* -> AnitomyElements {\n  AnimeTitle: 'Detective Conan',\n  EpisodeNumber: [ '316', '317' ],\n  FileChecksum: '2411959B',\n  FileExtension: 'mkv',\n  FileName: 'Detective Conan - 316-317 [DCTP][2411959B]',\n  ReleaseGroup: 'DCTP' } */\nconst numOfEpNumbers = elems.count('EpisodeNumber');\n// -> 2\n```\n\n#### AnitomyElements#size()\nReturns the number of category-value pairs this AnitomyElements has.\n```javascript\nconst filename = '[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD].mkv';\nconst elems = anitomy.parseSync(filename);\n/* -> AnitomyElements {\n  AnimeTitle: 'Toradora!',\n  AnimeYear: '2008',\n  AudioTerm: 'FLAC',\n  EpisodeNumber: '01',\n  EpisodeTitle: 'Tiger and Dragon',\n  FileChecksum: '1234ABCD',\n  FileExtension: 'mkv',\n  FileName: '[TaigaSubs]_Toradora!_(2008)_-_01v2_-_Tiger_and_Dragon_[1280x720_H.264_FLAC][1234ABCD]',\n  ReleaseGroup: 'TaigaSubs',\n  ReleaseVersion: '2',\n  VideoResolution: '1280x720',\n  VideoTerm: 'H.264' } */\nconst size = elems.size();\n// -> 12\n```\n\n#### AnitomyElements#get(category)\nReturns the first value associated with the category in this AnitomyElements,\nor an empty string if none.\n* `category` must be a string representing an [ElementCategory](#element-categories).\n```javascript\nconst filename = 'Detective Conan - 316-317 [DCTP][2411959B].mkv';\nconst elems = anitomy.parseSync(filename);\n/* -> AnitomyElements {\n  AnimeTitle: 'Detective Conan',\n  EpisodeNumber: [ '316', '317' ],\n  FileChecksum: '2411959B',\n  FileExtension: 'mkv',\n  FileName: 'Detective Conan - 316-317 [DCTP][2411959B]',\n  ReleaseGroup: 'DCTP' } */\nconst firstEpNum = elems.get('EpisodeNumber');\n// -> '316'\n```\n\n#### AnitomyElements#getAll(category)\nReturns an array of all the values associated with the category in this \nAnitomyElements, or an empty array if none.\n* `category` must be a string representing an [ElementCategory](#element-categories).\n```javascript\nconst filename = 'Detective Conan - 316-317 [DCTP][2411959B].mkv';\nconst elems = anitomy.parseSync(filename);\n/* -> AnitomyElements {\n  AnimeTitle: 'Detective Conan',\n  EpisodeNumber: [ '316', '317' ],\n  FileChecksum: '2411959B',\n  FileExtension: 'mkv',\n  FileName: 'Detective Conan - 316-317 [DCTP][2411959B]',\n  ReleaseGroup: 'DCTP' } */\nconst epNums = elems.getAll('EpisodeNumber');\n// -> [ '316', '317' ]\n```\n\n### Element Categories\nThe element category names are the same as in `anitomy::ElementCategory`, \nwithout the `anitomy::kElement` prefix:\n```javascript\n[\n  'AnimeSeason',\n  'AnimeSeasonPrefix',\n  'AnimeTitle',\n  'AnimeType',\n  'AnimeYear',\n  'AudioTerm',\n  'DeviceCompatibility',\n  'EpisodeNumber',\n  'EpisodeNumberAlt',\n  'EpisodePrefix',\n  'EpisodeTitle',\n  'FileChecksum',\n  'FileExtension',\n  'FileName',\n  'Language',\n  'Other',\n  'ReleaseGroup',\n  'ReleaseInformation',\n  'ReleaseVersion',\n  'Source',\n  'Subtitles',\n  'VideoResolution',\n  'VideoTerm',\n  'VolumeNumber',\n  'VolumePrefix'\n]\n```\n\n## To Be Implemented\n  * Methods on AnitomyElements much like those on anitomy::Elements\n\n## License\n*node.anitomy.js* is licensed under\n[Mozilla Public License 2.0](https://www.mozilla.org/en-US/MPL/2.0/FAQ/).\n","versions":[{"number":"1.4.0","date":"2016-12-24T05:35:40.017Z"},{"number":"1.4.1","date":"2016-12-24T05:46:09.832Z"},{"number":"1.4.2","date":"2017-01-23T12:07:05.493Z"}],"starsCount":1,"created":"2016-12-24T05:35:40.017Z","modified":"2017-01-23T12:07:05.493Z","lastPublisher":{"name":"xtansia","email":"xtansia@xtansia.com"},"owners":[{"name":"xtansia","email":"xtansia@xtansia.com"}],"other":{"_attachments":{},"_from":".","_id":"anitomyjs","_nodeVersion":"7.4.0","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/anitomyjs-1.4.2.tgz_1485173225248_0.6133019751869142"},"_npmUser":{"name":"xtansia","email":"xtansia@xtansia.com"},"_npmVersion":"4.1.1","_rev":"7-3b7b53d8fd3fd1663f850801d6f8dd50","_shasum":"45d7808cf447bb983aebb12223f8c19d6f6ab41e","author":{"name":"Thomas Farr","email":"xtansia@xtansia.com","url":"https://xtansia.com"},"bugs":{"url":"https://github.com/Xtansia/node.anitomy.js/issues"},"directories":{},"dist-tags":{"latest":"1.4.2"},"dist":{"shasum":"45d7808cf447bb983aebb12223f8c19d6f6ab41e","tarball":"https://registry.npmjs.org/anitomyjs/-/anitomyjs-1.4.2.tgz"},"maintainers":[{"name":"xtansia","email":"xtansia@xtansia.com"}],"readmeFilename":"README.md","time":{"modified":"2017-01-23T12:07:05.493Z","created":"2016-12-24T05:35:40.017Z","1.4.0":"2016-12-24T05:35:40.017Z","1.4.1":"2016-12-24T05:46:09.832Z","1.4.2":"2017-01-23T12:07:05.493Z"},"users":{"xtansia":true}}}