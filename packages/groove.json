{"name":"groove","version":"2.5.1","description":"bindings to libgroove - generic music player library","main":"lib/index.js","repository":"https://github.com/andrewrk/node-groove","scripts":{"test":"mocha --reporter spec","install":"node-gyp rebuild"},"license":"MIT","devDependencies":{"mocha":"~2.2.5","ncp":"~2.0.0"},"dependencies":{"bindings":"~1.2.1","nan":"~2.3.5"},"gypfile":true,"homepage":"https://github.com/andrewrk/node-groove","gitHead":"05f76fc1194192b9f1b72ab336db11acc6685c07","versions":[{"number":"0.0.0","date":"2013-09-18T21:36:34.685Z"},{"number":"0.0.1","date":"2013-09-19T02:58:15.182Z"},{"number":"0.0.2","date":"2013-09-19T04:18:13.464Z"},{"number":"0.0.3","date":"2013-09-20T06:23:04.324Z"},{"number":"0.0.4","date":"2013-09-24T11:03:37.256Z"},{"number":"0.0.5","date":"2013-09-24T18:49:01.633Z"},{"number":"0.0.6","date":"2013-09-24T18:55:36.820Z"},{"number":"0.0.7","date":"2013-09-24T19:55:19.732Z"},{"number":"0.0.8","date":"2013-09-24T20:38:37.724Z"},{"number":"0.0.9","date":"2013-09-26T04:14:11.901Z"},{"number":"0.0.10","date":"2013-09-27T04:38:26.966Z"},{"number":"0.0.11","date":"2013-10-02T20:29:13.617Z"},{"number":"0.0.12","date":"2013-10-08T15:03:13.754Z"},{"number":"0.0.13","date":"2013-10-10T04:25:05.251Z"},{"number":"1.0.0","date":"2013-10-23T18:56:14.471Z"},{"number":"1.1.0","date":"2013-10-29T20:06:47.571Z"},{"number":"1.1.1","date":"2013-10-30T17:55:45.697Z"},{"number":"1.1.2","date":"2013-10-31T16:03:45.998Z"},{"number":"1.1.3","date":"2013-10-31T17:52:32.006Z"},{"number":"1.2.0","date":"2013-11-18T16:22:38.467Z"},{"number":"1.3.0","date":"2013-11-24T20:35:15.441Z"},{"number":"1.3.1","date":"2014-03-27T19:23:17.165Z"},{"number":"1.3.2","date":"2014-03-27T23:56:48.613Z"},{"number":"1.4.0","date":"2014-04-19T21:46:51.595Z"},{"number":"1.4.1","date":"2014-04-21T17:05:02.120Z"},{"number":"2.0.0","date":"2014-05-13T02:57:33.773Z"},{"number":"2.1.0","date":"2014-05-14T01:23:26.787Z"},{"number":"2.2.0","date":"2014-06-14T01:09:12.679Z"},{"number":"2.2.1","date":"2014-06-15T18:18:46.166Z"},{"number":"2.2.2","date":"2014-06-30T15:16:23.890Z"},{"number":"2.2.3","date":"2014-07-02T19:01:22.406Z"},{"number":"2.2.4","date":"2014-07-11T22:12:03.845Z"},{"number":"2.2.5","date":"2014-07-27T00:27:14.191Z"},{"number":"2.2.6","date":"2014-07-27T00:46:15.686Z"},{"number":"2.2.7","date":"2014-11-23T18:38:29.638Z"},{"number":"2.3.0","date":"2015-02-19T02:33:56.153Z"},{"number":"2.3.1","date":"2015-02-19T02:37:47.836Z"},{"number":"2.3.2","date":"2015-03-04T06:38:24.024Z"},{"number":"2.3.3","date":"2015-05-14T16:29:59.789Z"},{"number":"2.3.4","date":"2015-05-18T19:44:04.873Z"},{"number":"2.4.0","date":"2015-05-26T01:37:35.029Z"},{"number":"2.5.0","date":"2015-12-14T23:40:49.810Z"},{"number":"2.5.1","date":"2016-07-02T19:52:08.006Z"}],"readme":"# node-groove\n\nNode.js bindings to [libgroove](https://github.com/andrewrk/libgroove) -\ngeneric music player backend library.\n\nLive discussion in `#libgroove` on [freenode](https://freenode.net/).\n\n## Usage\n\n1. Install libgroove to your system. libgroove is a set of 4 libraries;\n   node-groove depends on all of them. So for example on ubuntu, make sure to\n   install libgroove-dev, libgrooveplayer-dev, libgrooveloudness-dev, and\n   libgroovefingerprinter-dev.\n2. `npm install --save groove`\n\n### Versions\n\n * node-groove >=2.4.0 depends on libgroove >=4.3.0\n * use node-groove 2.3.4 if you want to use libgroove <4.3.0\n\n### Get Metadata from File\n\n```js\nvar groove = require('groove');\n\ngroove.open(\"danse-macabre.ogg\", function(err, file) {\n  if (err) throw err;\n  console.log(file.metadata());\n  console.log(\"duration:\", file.duration());\n  file.close(function(err) {\n    if (err) throw err;\n  });\n});\n```\n\n#### More Examples\n\n * example/metadata.js - read or update metadata in a media file\n * example/playlist.js - play several files in a row and then exit\n * example/replaygain.js - compute replaygain values for media files\n * example/transcode.js - convert and splice several files together\n * example/fingerprint.js - create an acoustid fingerprint for media files\n\n## API Documentation\n\n### globals\n\n#### groove.setLogging(level)\n\n`level` can be:\n\n * `groove.LOG_QUIET`\n * `groove.LOG_ERROR`\n * `groove.LOG_WARNING`\n * `groove.LOG_INFO`\n\n#### groove.loudnessToReplayGain(loudness)\n\nConverts a loudness value which is in LUFS to the ReplayGain-suggested dB\nadjustment.\n\n#### groove.dBToFloat(dB)\n\nConverts dB format volume adjustment to a floating point gain format.\n\n#### groove.getVersion()\n\nReturns an object with these properties:\n\n * `major`\n * `minor`\n * `patch`\n\n### GrooveFile\n\n#### groove.open(filename, callback)\n\n`callback(err, file)`\n\n#### file.close(callback)\n\n`callback(err)`\n\n#### file.duration()\n\nIn seconds.\n\n#### file.shortNames()\n\nA comma-separated list of short names for the format.\n\n#### file.getMetadata(key, [flags])\n\nFlags:\n\n * `groove.TAG_MATCH_CASE`\n * `groove.TAG_DONT_OVERWRITE`\n * `groove.TAG_APPEND`\n\n#### file.setMetadata(key, value, [flags])\n\nSee `getMetadata` for flags.\n\nPass `null` for `value` to delete a key.\n\n#### file.metadata()\n\nThis returns an object populated with all the metadata.\nUpdating the object does nothing. Use `setMetadata` to\nupdate metadata and then `save` to write changes to disk.\n\n#### file.dirty\n\nBoolean whether `save` will do anything.\n\n#### file.filename\n\nThe string that was passed to `groove.open`\n\n#### file.save(callback)\n\n`callback(err)`\n\n### GroovePlaylist\n\n#### groove.createPlaylist()\n\nA playlist managers keeping an audio buffer full. To send the buffer\nto your speakers, use `playlist.createPlayer()`.\n\n#### playlist.items()\n\nReturns a read-only array of playlist items.\nUse `playlist.insert` and `playlist.remove` to modify.\n\n`[playlistItem1, playlistItem2, ...]`\n\n#### playlist.play()\n\n#### playlist.pause()\n\n#### playlist.seek(playlistItem, position)\n\nSeek to `playlistItem`, `position` seconds into the song.\n\n#### playlist.insert(file, gain, peak, nextPlaylistItem)\n\nCreates a new playlist item with file and puts it in the playlist before\n`nextPlaylistItem`. If `nextPlaylistItem` is `null`, appends the new\nitem to the playlist.\n\n`gain` is a float format volume adjustment that applies only to this item.\ndefaults to 1.0\n\n`peak` is float format, see `item.peak`.\ndefaults to 1.0\n\nReturns the newly added playlist item.\n\nOnce you add a file to the playlist, you must not `file.close()` it until\nyou first remove it from the playlist.\n\n#### playlist.remove(playlistItem)\n\nRemove `playlistItem` from the playlist.\n\nNote that you are responsible for calling `file.close()` on every file\nthat you open with `groove.open`. `playlist.remove` will not close files.\n\n#### playlist.position()\n\nReturns `{item, pos}` where `item` is the playlist item currently being\ndecoded and `pos` is how many seconds into the song the decode head is.\n\nNote that typically you are more interested in the position of the play head,\nnot the decode head. Example methods which return the play head are\n`player.position()` and `encoder.position()`.\n\n#### playlist.playing()\n\nReturns `true` or `false`.\n\n#### playlist.clear()\n\nRemove all playlist items.\n\n#### playlist.count()\n\nHow many items are on the playlist.\n\n#### playlist.gain\n\n#### playlist.setGain(value)\n\nBetween 0.0 and 1.0. You probably want to leave this at 1.0, since using\nreplaygain will typically lower your volume a significant amount.\n\n#### playlist.setItemGain(playlistItem, gain)\n\n`gain` is a float that affects the volume of the specified playlist item only.\nTo convert from dB to float, use exp(log(10) * 0.05 * dBValue).\n\n#### playlist.setItemPeak(playlistItem, peak)\n\nSee `item.peak`\n\n#### playlist.setFillMode(mode)\n\n`mode` can be:\n\n * `groove.EVERY_SINK_FULL`\n\n    This is the default behavior. The playlist will decode audio if any sinks\n    are not full. If any sinks do not drain fast enough the data will buffer up\n    in the playlist.\n\n * `groove.ANY_SINK_FULL`\n\n    With this behavior, the playlist will stop decoding audio when any attached\n    sink is full, and then resume decoding audio every sink is not full.\n\nDefaults to `groove.EVERY_SINK_FULL`.\n\n### GroovePlaylistItem\n\nThese are not instantiated directly; instead they are returned from\n`playlist.items()`.\n\n#### item.file\n\nRead-only.\n\n#### item.gain\n\nA volume adjustment in float format to apply to the file when it plays.\nThis is typically used for loudness compensation, for example ReplayGain.\nTo convert from dB to float, use `groove.dBToFloat`\n\nRead-only. Use `playlist.setItemGain` to modify.\n\n#### item.peak\n\nThe sample peak of this playlist item is assumed to be 1.0 in float\nformat. If you know for certain that the peak is less than 1.0, you\nmay set this value which may allow the volume adjustment to use\na pure amplifier rather than a compressor. This results in slightly\nbetter audio quality.\n\nRead-only. Use `playlist.setItemPeak` to modify.\n\n#### item.id\n\nEvery time you obtain a playlist item from groove, you will get a fresh\nJavaScript object, but it might point to the same underlying libgroove pointer\nas another. The `id` field is a way to check if two playlist items reference\nthe same one.\n\nRead-only.\n\n### GroovePlayer\n\n#### groove.getDevices()\n\nReturns an array of device names which are the devices you can send audio\nto.\n\n#### groove.createPlayer()\n\nCreates a GroovePlayer instance which you can then configure by setting\nproperties.\n\n#### player.deviceIndex\n\nBefore calling `attach()`, set this to the index of one of the devices\nreturned from `groove.getDevices()` or `null` to represent the default device.\nUse `groove.DUMMY_DEVICE` to represent a dummy audio player.\n\n#### player.targetAudioFormat\n\nThe desired audio format settings with which to open the device.\n`groove.createPlayer()` defaults these to 44100 Hz,\nsigned 16-bit int, stereo.\nThese are preferences; if a setting cannot be used, a substitute will\nbe used instead. In this case, actualAudioFormat will be updated to reflect\nthe substituted values.\n\nProperties:\n\n * `sampleRate`\n * `channelLayout`\n * `sampleFormat`\n\n#### player.actualAudioFormat\n\ngroove sets this to the actual format you get when you open the device.\nIdeally will be the same as targetAudioFormat but might not be.\n\nProperties:\n\n * `sampleRate`\n * `channelLayout`\n * `sampleFormat`\n\n#### player.deviceBufferSize\n\nhow big the device buffer should be, in sample frames.\nmust be a power of 2.\n`groove.createPlayer()` defaults this to 1024\n\n#### player.sinkBufferSize\n\nHow big the sink buffer should be, in sample frames.\n`groove.createPlayer()` defaults this to 8192\n\n#### player.useExactAudioFormat\n\nIf you set this to `true`, `targetAudioFormat` and `actualAudioFormat` are\nignored and no resampling, channel layout remapping, or sample format\nconversion will occur. The audio device will be reopened with exact parameters\nwhenever necessary.\n\n#### player.attach(playlist, callback)\n\nSends audio to sound device.\n\n`callback(err)`\n\n#### player.detach(callback)\n\n`callback(err)`\n\n#### player.position()\n\nReturns `{item, pos}` where `item` is the playlist item currently being\nplayed and `pos` is how many seconds into the song the play head is.\n\n#### player.on('nowplaying', handler)\n\nFires when the item that is now playing changes. It can be `null`.\n\n`handler()`\n\n#### player.on('bufferunderrun', handler)\n\nFires when a buffer underrun occurs. Ideally you'll never see this.\n\n`handler()`\n\n#### player.on('devicereopened', handler)\n\nFires when you have set `useExactAudioFormat` to `true` and the audio device\nhas been closed and re-opened to match incoming audio data.\n\n`handler()`\n\n### GrooveEncoder\n\n#### groove.createEncoder()\n\n#### encoder.bitRate\n\nselect encoding quality by choosing a target bit rate\n\n#### encoder.formatShortName\n\noptional - help libgroove guess which format to use.\n`avconv -formats` to get a list of possibilities.\n\n#### encoder.codecShortName\n\noptional - help libgroove guess which codec to use.\n`avconv-codecs` to get a list of possibilities.\n\n#### encoder.filename\n\noptional - provide an example filename to help libgroove guess\nwhich format/codec to use.\n\n#### encoder.mimeType\n\noptional - provide a mime type string to help libgrooove guess\nwhich format/codec to use.\n\n#### encoder.targetAudioFormat\n\nThe desired audio format settings with which to encode.\n`groove.createEncoder()` defaults these to 44100 Hz,\nsigned 16-bit int, stereo.\nThese are preferences; if a setting cannot be used, a substitute will\nbe used instead. In this case, actualAudioFormat will be updated to reflect\nthe substituted values.\n\nProperties:\n\n * `sampleRate`\n * `channelLayout`\n * `sampleFormat`\n\n#### encoder.actualAudioFormat\n\ngroove sets this to the actual format you get when you attach the encoder.\nIdeally will be the same as targetAudioFormat but might not be.\n\nProperties:\n\n * `sampleRate`\n * `channelLayout`\n * `sampleFormat`\n\n#### encoder.sinkBufferSize\n\nHow big the sink buffer should be, in sample frames.\n`createEncoder` defaults this to 8192\n\n#### encoder.encodedBufferSize\n\nHow big the encoded audio buffer should be, in bytes.\n`createEncoder` defaults this to 16384\n\n#### encoder.attach(playlist, callback)\n\n`callback(err)`\n\n#### encoder.detach(callback)\n\n`callback(err)`\n\n#### encoder.getBuffer()\n\nReturns `null` if no buffer available, or an object with these properties:\n\n * `buffer` - a node `Buffer` instance which is the encoded data for this chunk\n   this can be `null` in which case this buffer is actually the end of\n   playlist sentinel.\n * `item` - the GroovePlaylistItem of which this buffer is encoded data for\n * `pos` - position in seconds that this buffer represents in into the item\n\n#### encoder.on('buffer', handler)\n\n`handler()`\n\nEmitted when there is a buffer available to get. You still need to get the\nbuffer with `getBuffer()`.\n\n#### encoder.position()\n\nReturns `{item, pos}` where `item` is the playlist item currently being\nencoded and `pos` is how many seconds into the song the encode head is.\n\n### GrooveLoudnessDetector\n\n#### groove.createLoudnessDetector()\n\nreturns a GrooveLoudnessDetector\n\n#### detector.infoQueueSize\n\nSet this to determine how far ahead into the playlist to look.\n\n#### detector.sinkBufferSize\n\nHow big the sink buffer should be, in sample frames.\n`groove.createLoudnessDetector()` defaults this to 8192\n\n#### detector.disableAlbum\n\nSet to `true` to only compute track loudness. This is faster and requires less\nmemory than computing both.\n\n#### detector.attach(playlist, callback)\n\n`callback(err)`\n\n#### detector.detach(callback)\n\n`callback(err)`\n\n#### detector.getInfo()\n\nReturns `null` if no info available, or an object with these properties:\n\n * `loudness` - loudness in LUFS\n * `peak` - sample peak in float format of the file\n * `duration` - duration in seconds of the track\n * `item` - the GroovePlaylistItem that this applies to, or `null` if it applies\n   to the entire album.\n\n#### detector.position()\n\nReturns `{item, pos}` where `item` is the playlist item currently being\ndetected and `pos` is how many seconds into the song the detect head is.\n\n#### detector.on('info', handler)\n\n`handler()`\n\nEmitted when there is info available to get. You still need to get the info\nwith `getInfo()`.\n\n### GrooveFingerprinter\n\n#### groove.createFingerprinter()\n\nreturns a GrooveFingerprinter\n\n#### groove.encodeFingerprint(rawFingerprint)\n\nGiven an Array of integers which is the raw fingerprint, encode it into a\nstring which can be submitted to acoustid.org.\n\n#### groove.decodeFingerprint(fingerprint)\n\nGiven the fingerprint string, returns a list of integers which is the raw\nfingerprint data.\n\n#### printer.infoQueueSize\n\nSet this to determine how far ahead into the playlist to look.\n\n#### printer.sinkBufferSize\n\nHow big the sink buffer should be, in sample frames.\n`groove.createFingerprinter()` defaults this to 8192\n\n#### printer.attach(playlist, callback)\n\n`callback(err)`\n\n#### printer.detach(callback)\n\n`callback(err)`\n\n#### printer.getInfo()\n\nReturns `null` if no info available, or an object with these properties:\n\n * `fingerprint` - integer array which is the raw fingerprint\n * `duration` - duration in seconds of the track\n * `item` - the GroovePlaylistItem that this applies to, or `null` if it applies\n   to the entire album.\n\n#### printer.position()\n\nReturns `{item, pos}` where `item` is the playlist item currently being\nfingerprinted and `pos` is how many seconds into the song the printer head is.\n\n#### printer.on('info', handler)\n\n`handler()`\n\nEmitted when there is info available to get. You still need to get the info\nwith `getInfo()`.\n","starsCount":3,"created":"2013-09-18T21:36:33.110Z","modified":"2017-06-23T12:43:05.529Z","lastPublisher":{"name":"superjoe","email":"superjoe30@gmail.com"},"owners":[{"name":"superjoe","email":"superjoe30@gmail.com"},{"name":"thejoshwolfe","email":"thejoshwolfe@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"groove","_nodeVersion":"4.4.4","_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/groove-2.5.1.tgz_1467489125863_0.7531236864160746"},"_npmUser":{"name":"superjoe","email":"superjoe30@gmail.com"},"_npmVersion":"2.15.1","_rev":"3-071638b7e4bfe832d3569bc39e146a8a","_shasum":"43d9c100b00b33e2cd1c295ec5100aac150a0d34","author":{"name":"Andrew Kelley","email":"superjoe30@gmail.com"},"bugs":{"url":"https://github.com/andrewrk/node-groove/issues"},"directories":{"example":"example","test":"test"},"dist-tags":{"latest":"2.5.1"},"dist":{"shasum":"43d9c100b00b33e2cd1c295ec5100aac150a0d34","tarball":"http://registry.npmjs.org/groove/-/groove-2.5.1.tgz"},"maintainers":[{"name":"superjoe","email":"superjoe30@gmail.com"},{"name":"thejoshwolfe","email":"thejoshwolfe@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-06-23T12:43:05.529Z","created":"2013-09-18T21:36:33.110Z","0.0.0":"2013-09-18T21:36:34.685Z","0.0.1":"2013-09-19T02:58:15.182Z","0.0.2":"2013-09-19T04:18:13.464Z","0.0.3":"2013-09-20T06:23:04.324Z","0.0.4":"2013-09-24T11:03:37.256Z","0.0.5":"2013-09-24T18:49:01.633Z","0.0.6":"2013-09-24T18:55:36.820Z","0.0.7":"2013-09-24T19:55:19.732Z","0.0.8":"2013-09-24T20:38:37.724Z","0.0.9":"2013-09-26T04:14:11.901Z","0.0.10":"2013-09-27T04:38:26.966Z","0.0.11":"2013-10-02T20:29:13.617Z","0.0.12":"2013-10-08T15:03:13.754Z","0.0.13":"2013-10-10T04:25:05.251Z","1.0.0":"2013-10-23T18:56:14.471Z","1.1.0":"2013-10-29T20:06:47.571Z","1.1.1":"2013-10-30T17:55:45.697Z","1.1.2":"2013-10-31T16:03:45.998Z","1.1.3":"2013-10-31T17:52:32.006Z","1.2.0":"2013-11-18T16:22:38.467Z","1.3.0":"2013-11-24T20:35:15.441Z","1.3.1":"2014-03-27T19:23:17.165Z","1.3.2":"2014-03-27T23:56:48.613Z","1.4.0":"2014-04-19T21:46:51.595Z","1.4.1":"2014-04-21T17:05:02.120Z","2.0.0":"2014-05-13T02:57:33.773Z","2.1.0":"2014-05-14T01:23:26.787Z","2.2.0":"2014-06-14T01:09:12.679Z","2.2.1":"2014-06-15T18:18:46.166Z","2.2.2":"2014-06-30T15:16:23.890Z","2.2.3":"2014-07-02T19:01:22.406Z","2.2.4":"2014-07-11T22:12:03.845Z","2.2.5":"2014-07-27T00:27:14.191Z","2.2.6":"2014-07-27T00:46:15.686Z","2.2.7":"2014-11-23T18:38:29.638Z","2.3.0":"2015-02-19T02:33:56.153Z","2.3.1":"2015-02-19T02:37:47.836Z","2.3.2":"2015-03-04T06:38:24.024Z","2.3.3":"2015-05-14T16:29:59.789Z","2.3.4":"2015-05-18T19:44:04.873Z","2.4.0":"2015-05-26T01:37:35.029Z","2.5.0":"2015-12-14T23:40:49.810Z","2.5.1":"2016-07-02T19:52:08.006Z"},"users":{"mariod3w":true,"soulchainer":true,"tobitobitobi":true}}}