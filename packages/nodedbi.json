{"name":"nodedbi","version":"1.0.12","description":"A LibDBI interface for Node.js","keywords":["database","dbi","libdbi","mysql","postgresql","sql"],"repository":"https://github.com/danieloneill/nodedbi","scripts":{"preinstall":"(pkg-config dbi --exists) || (echo Sorry, you need to install LibDBI and development headers as well as pkg-config to build this module.; exit 1)","install":"(node-gyp rebuild 2> builderror.log) || (exit 1)"},"engines":{"node":">=0.11.13"},"dependencies":{"nan":">=2.4.0"},"gypfile":true,"homepage":"https://github.com/danieloneill/nodedbi","gitHead":"08d69eef65709629e0923185cc70c1d4924ff5f7","readme":"# NodeDBI\n\nNodeDBI is a LibDBI interface for Node.js.\n\nFor the source code please visit [the github repository](https://github.com/danieloneill/nodedbi).\n\nIn addition to providing a traditional interface for SQL database access, it also offers developers the ability of paging on results programmatically and storing result handles to a session as shown below.\n\nIt's somewhat complete, and of course contributions are much appreciated.\n\nLibDBI and development headers are required.\n\nOn Debian or Ubuntu, **apt-get install libdbi-dev.**\n\nThen run **node-gyp configure build** to build the module and **node-gyp install** to install it.\n\n## Example\n\nI've put together a couple Gists that may be useful:\n\n* [node.js + nodedbi, convenience methods](https://gist.github.com/danieloneill/2605640f020c89fb806a)\n* [Nodejs + libdbi + paging results](https://gist.github.com/danieloneill/d069be8e02e852008cbd)\n\n```javascript\n#!/usr/bin/nodejs\n\nvar mod = require('nodedbi');\n\nvar args = { 'host':'localhost', 'port':3306, 'username':'root', 'password':'', 'type':'mysql', 'dbname':'test' };\n\nvar obj = new mod.DBConnection( args );\n\nvar q = obj.query(\"SELECT * FROM users WHERE username=%1 OR id=%2\", ['doneill', 6]);\nif( !q )\n{\n        console.log(\"Query failed!\");\n        return;\n}\n\n// Simple:\nvar results = q.toArray();\n\n// Doing the same thing manually:\nvar rc = q.count();\nconsole.log(\"Row count: \"+rc);\n\nvar fc = q.fieldCount();\nconsole.log(\"Field count: \"+q.fieldCount());\n\nvar fna = [];\nfor( var x=0; x < fc; x++ )\n{\n        var fn = q.fieldName(x+1);\n        console.log(\"Field name(\"+(x+1)+\"): \"+fn);\n        fna.push( fn );\n}\n\nfor( var y=0; y < rc; y++ )\n{\n        q.seek(y+1);\n        for( var x=0; x < fc; x++ )\n        {\n                var v = q.value(x+1);\n                console.log( y+\" [\"+fna[x]+\"] = [\"+v+\"]\" );\n        }\n}\n\n```\n\n# Methods\n\n## DBConnection( args )\n`Create a new database connection and connect.`\n\nMust be called with *new* qualifier, eg:\n\n```javascript\nvar NodeDBI = require('nodedbi');\nvar db = new NodeDBI.DBConnection(args);\n```\n\nA **type** parameter is required. Other parameters are database specific. For database specific driver options see [the libdbi-drivers documentation](http://libdbi-drivers.sourceforge.net/docs.html).\n\n* `args` - Object containing LibDBI-specific connection parameters in key:value sets.\n* `Returns`: A database object, or **undefined** and an Exception on failure.\n\n---\n\n## DBConnection::query(queryString, [parameters])\n`Create and execute a database query.`\n\n* `queryString` - Query string with placeholders enumerated as %1, %2, etc.\n* `parameters` - Optional array of query placeholder values.\n* `Returns`: A DBQuery object, or **false** if the query fails for any reason.\n\n---\n\n## DBConnection::lastError()\n`Retrieve the latest error as a string.`\n\n* `Returns`: The latest database error as a string.\n\n---\n\n## DBConnection::lastErrorCode()\n`Retrieve the latest error.`\n\n* `Returns`: The latest database error enumerated as below. See [LibDBI's documentation for a comprehensive list](http://libdbi.sourceforge.net/docs/programmers-guide/connerrors.html). *(Enumerations are members of the imported nodedbi module. For example, if imported with* **var DBI = require('nodedbi');** *one would reference an error as* **if( db.lastErrorCode() == DBI.DBI_ERROR_CLIENT ) ... ** *or similar.*)\n  * DBI_ERROR_USER\n  * DBI_ERROR_DBD\n  * ...\n  * DBI_ERROR_NONE\n\n---\n\n## Connection::lastInsertId([name])\n`Fetch the row ID generated by the last INSERT command. The row ID is most commonly generated by an auto-incrementing column in the table.`\n\n* `name` - The name of the sequence, or NULL if the database engine does not use explicit sequences.\n* `Returns`: A value corresponding to the ID that was created by the last INSERT command. If the database engine does not support sequences, the function returns 0.\n\n---\n\n## Query()\n`This object is returned by` **DBConnection::query** `and cannot be instantiated on its own.`\n\n---\n\n## Query::count()\n`Row count of result set.`\n\n* `Returns`: A count of the returned rows in a SELECT or similar query.\n\n---\n\n## Query::fieldCount()\n`Column count of the result set.`\n\n* `Returns`: A count of the returned columns (fields) in a SELECT or similar query.\n\n---\n\n## Query::fieldName(column)\n`Fetch the field name of a specific column index. Column indexes in LibDBI begin at` **1**`, not 0.`\n\n* `column` - The column index in the result object. Column indexes in LibDBI begin at **1**, not 0.\n* `Returns`: The name of the field at the specified index or **undefined** and an exception if the index is invalid.\n\n---\n\n## Query::fieldIndex(fieldName)\n`Fetch the column index of a specific field name. Column indexes in LibDBI begin at` **1**`, not 0.`\n\n* `fieldName` - The field name in the result object.\n* `Returns`: The column index with the specified field name or **undefined** and an exception if the field name isn't found. Column indexes in LibDBI begin at **1**, not 0.\n\n---\n\n## Query::seek(row)\n`Seek to a specified row in the resultset. Row indexes in LibDBI begin at` **1**`, not 0.`\n\n* `row` - The row index in the result object. Row indexes in LibDBI begin at **1**, not 0.\n* `Returns`: **true** on success, **false** or an exception on failure.\n\n---\n\n## Query::previousRow()\n`Seek the cursor to the previous row in the resultset.`\n\n* `Returns`: **true** on success, **false** if already at the first result in the set.\n\n---\n\n## Query::nextRow()\n`Seek the cursor to the next row in the resultset.`\n\n* `Returns`: **true** on success, **false** if already at the last result in the set.\n\n---\n\n## Query::currentRow()\n`Fetch the current row index of the resultset cursor. Row indexes in LibDBI begin at` **1**`, not 0.`\n\n* `Returns`: The current row index. Row indexes in LibDBI begin at **1**, not 0.\n\n---\n\n## Query::value(field)\n`Fetch the value of the specified field on the current row index of the resultset cursor. Row and column indexes in LibDBI begin at` **1**`, not 0.`\n\n**field** can be either a numeric column index or the field name.\n\nValues are converted to the best Javascript type possible to avoid loss of precision. Binary data is returned as a [Buffer object](https://nodejs.org/api/buffer.html).\n\n* `Returns`: The value.\n\n---\n\n## Query::begin()\n`Starts a transaction.`\n\n* `Returns`: **true** on success, **false** if the database cannot or will not start a new transaction.\n\n---\n\n## Query::commit()\n`Commits a transaction, i.e. writes all changes since the transaction was started to the database.`\n\n* `Returns`: **true** on success, **false** if the database cannot or will not commit the transaction.\n\n---\n\n## Query::rollback()\n`Rolls back a transaction, i.e. reverts all changes since the transaction started.`\n\n* `Returns`: **true** on success, **false** if the database cannot or will not commit the transaction.\n\n","versions":[{"number":"1.0.0","date":"2015-03-29T03:14:41.246Z"},{"number":"1.0.1","date":"2015-03-29T03:34:02.562Z"},{"number":"1.0.2","date":"2015-03-29T21:01:56.903Z"},{"number":"1.0.3","date":"2015-03-29T22:14:22.705Z"},{"number":"1.0.4","date":"2015-03-30T10:47:19.781Z"},{"number":"1.0.5","date":"2015-06-24T09:09:50.164Z"},{"number":"1.0.6","date":"2015-08-31T18:36:45.263Z"},{"number":"1.0.7","date":"2015-09-08T17:00:17.594Z"},{"number":"1.0.8","date":"2015-10-11T02:32:26.083Z"},{"number":"1.0.9","date":"2015-10-20T14:06:38.798Z"},{"number":"1.0.10","date":"2015-10-21T17:26:35.681Z"},{"number":"1.0.11","date":"2016-07-24T05:31:50.619Z"},{"number":"1.0.12","date":"2016-09-22T23:39:11.976Z"}],"created":"2015-03-29T03:14:41.246Z","modified":"2016-10-01T21:05:45.436Z","lastPublisher":{"name":"danieloneill","email":"doneill@akielectronics.com"},"owners":[{"name":"danieloneill","email":"doneill@akielectronics.com"}],"other":{"_attachments":{},"_from":".","_id":"nodedbi","_nodeVersion":"6.3.1","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/nodedbi-1.0.12.tgz_1474587551738_0.9140437114983797"},"_npmUser":{"name":"danieloneill","email":"doneill@akielectronics.com"},"_npmVersion":"3.10.3","_rev":"1-6a9b3d0f25ef5a5360ca10f0de5322af","_shasum":"4a22076f0bd9095afe10795ea9a9d951a72dae62","author":{"name":"Daniel O'Neill","email":"doneill@akielectronics.com","url":"http://akielectronics.com"},"bugs":{"url":"https://github.com/danieloneill/nodedbi/issues"},"directories":{},"dist-tags":{"latest":"1.0.12"},"dist":{"shasum":"4a22076f0bd9095afe10795ea9a9d951a72dae62","tarball":"http://registry.npmjs.org/nodedbi/-/nodedbi-1.0.12.tgz"},"maintainers":[{"name":"danieloneill","email":"doneill@akielectronics.com"}],"readmeFilename":"README.md","time":{"modified":"2016-10-01T21:05:45.436Z","created":"2015-03-29T03:14:41.246Z","1.0.0":"2015-03-29T03:14:41.246Z","1.0.1":"2015-03-29T03:34:02.562Z","1.0.2":"2015-03-29T21:01:56.903Z","1.0.3":"2015-03-29T22:14:22.705Z","1.0.4":"2015-03-30T10:47:19.781Z","1.0.5":"2015-06-24T09:09:50.164Z","1.0.6":"2015-08-31T18:36:45.263Z","1.0.7":"2015-09-08T17:00:17.594Z","1.0.8":"2015-10-11T02:32:26.083Z","1.0.9":"2015-10-20T14:06:38.798Z","1.0.10":"2015-10-21T17:26:35.681Z","1.0.11":"2016-07-24T05:31:50.619Z","1.0.12":"2016-09-22T23:39:11.976Z"}}}