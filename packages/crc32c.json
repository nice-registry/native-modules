{"name":"crc32c","version":"0.6.0","description":"CRC32C C  implementation for Linux. Supports strings, String Objects and Buffers!","keywords":["crc","crc32","crc32c","hash","castagnoli"],"license":"MIT","dependencies":{"nan":"^1.8"},"devDependencies":{"crc32":"latest","mocha":"1.20.x","should":"4.0.x"},"main":"./bin/crc32c.node","repository":"https://github.com/dozoisch/node-crc32c","bin":{"crc32c":"./crc32c"},"files":["LICENSE","README.md","HISTORY.md","src","test","benchmarks","binding.gyp","crc32c","bin/crc32c-cli.js"],"scripts":{"test":"NODE_ENV=test ./node_modules/.bin/mocha --harmony --reporter spec ./test/test.js","install":"node-gyp rebuild"},"engines":{"node":">= 0.10.0"},"os":["linux"],"gypfile":true,"gitHead":"4bd3c589edf02eb2ccdbf87ea105c8e957517b4c","homepage":"https://github.com/dozoisch/node-crc32c#readme","versions":[{"number":"0.1.0","date":"2013-11-07T04:07:15.507Z"},{"number":"0.1.2","date":"2013-11-07T04:16:00.558Z"},{"number":"0.1.3","date":"2013-11-08T00:30:41.038Z"},{"number":"0.1.4","date":"2013-11-08T01:16:00.939Z"},{"number":"0.2.0","date":"2013-11-10T18:12:53.415Z"},{"number":"0.2.1","date":"2013-12-03T02:16:07.604Z"},{"number":"0.2.2","date":"2013-12-03T02:30:43.776Z"},{"number":"0.2.3","date":"2013-12-14T23:06:22.018Z"},{"number":"0.3.0","date":"2013-12-17T03:47:44.685Z"},{"number":"0.4.0","date":"2013-12-17T21:48:50.859Z"},{"number":"0.4.1","date":"2013-12-20T17:54:35.438Z"},{"number":"0.4.2","date":"2014-02-13T03:32:47.093Z"},{"number":"0.5.0","date":"2014-06-15T06:08:46.914Z"},{"number":"0.5.1","date":"2014-06-15T14:04:21.689Z"},{"number":"0.6.0","date":"2015-05-08T03:00:47.297Z"}],"readme":"Node-crc32c\n===========\n\n[![Build Status][travis.img]][travis.url]\n\nBasic C  modules for NodeJS with crc32c (Castagnoli) implementation for Linux. The implementation uses the native Linux library \"AF\\_ALG\".\nIt is compatible with node 0.10 and 0.11!\n\nIt supports strings, string objects, buffers, numbers! Works well with mongoose. Just do a toString on the entity to hash!\n\nThis module is not meant for secure hashing but really for something like ETags or anything that is easier to compare using a hash than the full string.\n\n##Building\n\n    make build\n\nor\n\n    npm install crc32c\n\n##Usage\n\n### For small number of computation needed\n\nYou have the function `compute`, which takes only one argument, the string to hash.\n\nFrom JavaScript:\n```javascript\nvar crc32c = require('crc32c');\n\n// Works with strings!\nvar toHash = \"HELLOWORLD\";\nconsole.log(crc32c.compute(toHash));\n\n// Or buffers!\nconsole.log(crc32c.compute(new Buffer('{\"jsonString\":\"property1\",\"jsonArray\":[\"arr1\",\"arr2\",\"arr3\"]}')));\n\n// Or String Objects!\nconsole.log(crc32c.compute(new String('A superb string!')));\n\n// It also supports numbers, if you really need to compute on a single integer/float!\nconsole.log(crc32c.compute(3.141592654);\n```\n\n### For batch computing\n\n*With >100 iterations I get a 3x to 5x performance improvements. It really shows up at more than 10K iterations though.*\n\nYou have to create an object called a Batcher. This object then has 3 methods: `openSocket`, `closeSocket`, and `compute`.\n\nFrom JavaScript:\n```javascript\nvar crc32c = require('crc32c');\nvar Batcher = new crc32c.Batcher(); // You can create as many as you want. Every instance will use a single socket.\nvar Batcher.openSocket();\nconsole.log(Batcher.compute(new Buffer('{\"jsonString\":\"property1\",\"jsonArray\":[\"arr1\",\"arr2\",\"arr3\"]}')));\n// ... Iterate on many strings/buffer/etc.\nBatcher.closeSocket();\n```\n\nFrom cli:\n```shell\ncrc32c <filename>\n```\n*It currently supports only one file at the time.*\n\n### Want more examples?\n\n**SOON** See the example sections!\n\n##License\n\nThe plugin is under MIT license, please see the LICENSE file provided with the module.\n\n\n## Tests\n\nYou can run the test by doing `make test`. Currently the test only contains successful use case, but error handling test cases will be added soon.\n\n## Benchmarks\n\nRun the script by doing `make benchmarks`!\n\n*I think that pure times are not representative of reality, since every setup will get different results. This is why I've put the times in ratio using AF_ALG batch as the base (1).*\n\n- **AF_ALG batch**: This test has used this library in single socket (batch) mode.\n- **AF_ALG std**: This test has used this library in multi socket (standard) mode.\n- **SSE4.2**: Using the SSE4.2 Implementation by Voxer, which is using x86 asm implementation.\n- **Pure JS (table)**: This is using the pure JS CRC32 implementation, using a pre-baked table.\n- **Pure JS (direct)**: This is using the pure JS CRC32 implementation, without using a pre-calculated table.\n\n*For the original times see benchmarks/results.txt*\n\n| Test | AF_ALG batch | AF_ALG std | SSE4.2 | Pure JS (table) | Pure JS (direct) |\n| ---- |:------------:|:----------:|:------:|:---------------:|:----------------:|\n| TEST_STRING_1024 | 1 | 4.4 | 0.3 | 60.4 | 97.4 |\n| TEST_STRING_2048 | 1 | 4.6 | 0.4 | 119.8 | 186.9 |\n| TEST_BUFFER_1024 | 1 | 5.7 | 0.4 | 8.9 | 45.5 |\n| TEST_BUFFER_2048 | 1 | 5.2 | 0.5 | 95.0 | 86.5 |\n| TEST_STRING_OBJECT_1024 | 1 | 3.5 | *N/A* | 50.6 | 115.8 |\n| TEST_STRING_OBJECT_2048 | 1 | 3.3 | *N/A* | 103.9 | 208.6 |\n\n*N/A* means that it is not available because not supported.\n\n### Interesting things\n\n- The library closely always takes the same times to execute even though the data is bigger. The main bottleneck is the data unboxing.\n- The single-socket can improve the performance by a lot when needing to do a lot of calculations\n- Yes the assembly implementation is faster, and that is not really surprising. Why taking crc32c? Because it's a cross platform implementation, that uses a core linux library (so very robust implementation). Also, this library support string objects.\n- The pure JS library is waaaaaaaaaay slower with 1024 bytes strings and gets slower and slower when the string is bigger. The C implementation is pretty stable, and the only thing slowing it in the unboxing from JavaScript to pure C.\n\n[travis.img]: https://api.travis-ci.org/dozoisch/node-crc32c.svg\n[travis.url]: https://travis-ci.org/dozoisch/node-crc32c\n","starsCount":1,"created":"2013-11-07T04:07:13.940Z","modified":"2015-05-08T03:00:47.297Z","lastPublisher":{"name":"dozoisch","email":"hugo@dozoisch.com"},"owners":[{"name":"dozoisch","email":"hugo@dozoisch.com"}],"other":{"_attachments":{},"_from":".","_id":"crc32c","_nodeVersion":"2.0.1","_npmUser":{"name":"dozoisch","email":"hugo@dozoisch.com"},"_npmVersion":"2.9.0","_rev":"1-7d7e879013d6c00dff380faaa5f18e2c","_shasum":"77345909ebe519f4fa081fe4b56f2acb3e13e809","author":{"name":"Hugo Dozois","email":"hugo@dozoisch.com"},"bugs":{"url":"https://github.com/dozoisch/node-crc32c/issues"},"directories":{},"dist-tags":{"latest":"0.6.0"},"dist":{"shasum":"77345909ebe519f4fa081fe4b56f2acb3e13e809","tarball":"http://registry.npmjs.org/crc32c/-/crc32c-0.6.0.tgz"},"maintainers":[{"name":"dozoisch","email":"hugo@dozoisch.com"}],"readmeFilename":"README.md","time":{"modified":"2015-05-08T03:00:47.297Z","created":"2013-11-07T04:07:13.940Z","0.1.0":"2013-11-07T04:07:15.507Z","0.1.2":"2013-11-07T04:16:00.558Z","0.1.3":"2013-11-08T00:30:41.038Z","0.1.4":"2013-11-08T01:16:00.939Z","0.2.0":"2013-11-10T18:12:53.415Z","0.2.1":"2013-12-03T02:16:07.604Z","0.2.2":"2013-12-03T02:30:43.776Z","0.2.3":"2013-12-14T23:06:22.018Z","0.3.0":"2013-12-17T03:47:44.685Z","0.4.0":"2013-12-17T21:48:50.859Z","0.4.1":"2013-12-20T17:54:35.438Z","0.4.2":"2014-02-13T03:32:47.093Z","0.5.0":"2014-06-15T06:08:46.914Z","0.5.1":"2014-06-15T14:04:21.689Z","0.6.0":"2015-05-08T03:00:47.297Z"},"users":{"dozoisch":true}}}