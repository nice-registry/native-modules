{"name":"cap","version":"0.1.2","description":"A cross-platform binding for performing packet capturing with node.js","main":"./lib/Cap","dependencies":{"nan":"^2.4.0"},"scripts":{"install":"node-gyp rebuild","test":"node test/test.js"},"engines":{"node":">=0.10.0"},"keywords":["pcap","packet","capture","libpcap","winpcap"],"licenses":[{"type":"MIT","url":"http://github.com/mscdex/cap/raw/master/LICENSE"}],"repository":"https://github.com/mscdex/cap","gypfile":true,"homepage":"https://github.com/mscdex/cap#readme","_resolved":"https://github.com/mscdex/cap/tarball/v0.1.2","versions":[{"number":"0.0.1","date":"2013-01-05T18:37:13.200Z"},{"number":"0.0.2","date":"2013-01-06T01:33:52.530Z"},{"number":"0.0.3","date":"2013-02-12T05:47:17.255Z"},{"number":"0.0.4","date":"2013-02-19T19:44:46.569Z"},{"number":"0.0.5","date":"2013-03-28T00:34:44.143Z"},{"number":"0.0.6","date":"2013-10-10T20:17:29.652Z"},{"number":"0.0.7","date":"2013-12-01T03:26:31.435Z"},{"number":"0.0.8","date":"2014-01-23T19:11:52.013Z"},{"number":"0.0.9","date":"2014-07-10T15:03:03.681Z"},{"number":"0.0.10","date":"2014-07-22T16:00:04.129Z"},{"number":"0.0.11","date":"2015-02-01T20:54:30.511Z"},{"number":"0.0.12","date":"2015-02-10T04:58:45.461Z"},{"number":"0.0.13","date":"2015-04-06T13:32:23.367Z"},{"number":"0.0.14","date":"2015-05-05T17:30:57.071Z"},{"number":"0.0.15","date":"2015-05-15T14:26:08.710Z"},{"number":"0.1.0","date":"2015-09-02T00:12:08.192Z"},{"number":"0.1.1","date":"2016-01-09T20:30:57.655Z"},{"number":"0.1.2","date":"2016-10-06T18:26:53.779Z"}],"readme":"\nDescription\n===========\n\nA cross-platform binding for performing packet capturing with [node.js](http://nodejs.org/).\n\n[![Build Status](https://travis-ci.org/mscdex/cap.svg)](https://travis-ci.org/mscdex/cap)\n[![Build status](https://ci.appveyor.com/api/projects/status/hypcya975yogcu9h)](https://ci.appveyor.com/project/mscdex/cap)\n\n\nRequirements\n============\n\n* [node.js](http://nodejs.org/) -- v0.10.0 or newer\n\n* For Windows: [WinPcap](http://www.winpcap.org/install/default.htm)\n\n* For *nix: libpcap and libpcap-dev/libpcap-devel packages\n\n\nInstall\n============\n\n    npm install cap\n\n\nExamples\n========\n\n* Capture and decode all outgoing TCP data packets destined for port 80 on the interface for 192.168.0.10:\n\n```javascript\nvar Cap = require('cap').Cap,\n    decoders = require('cap').decoders,\n    PROTOCOL = decoders.PROTOCOL;\n\nvar c = new Cap(),\n    device = Cap.findDevice('192.168.0.10'),\n    filter = 'tcp and dst port 80',\n    bufSize = 10 * 1024 * 1024,\n    buffer = new Buffer(65535);\n\nvar linkType = c.open(device, filter, bufSize, buffer);\n\nc.setMinBytes && c.setMinBytes(0);\n\nc.on('packet', function(nbytes, trunc) {\n  console.log('packet: length ' + nbytes + ' bytes, truncated? '\n              + (trunc ? 'yes' : 'no'));\n\n  // raw packet data === buffer.slice(0, nbytes)\n\n  if (linkType === 'ETHERNET') {\n    var ret = decoders.Ethernet(buffer);\n\n    if (ret.info.type === PROTOCOL.ETHERNET.IPV4) {\n      console.log('Decoding IPv4 ...');\n\n      ret = decoders.IPV4(buffer, ret.offset);\n      console.log('from: ' + ret.info.srcaddr + ' to ' + ret.info.dstaddr);\n\n      if (ret.info.protocol === PROTOCOL.IP.TCP) {\n        var datalen = ret.info.totallen - ret.hdrlen;\n\n        console.log('Decoding TCP ...');\n\n        ret = decoders.TCP(buffer, ret.offset);\n        console.log(' from port: ' + ret.info.srcport + ' to port: ' + ret.info.dstport);\n        datalen -= ret.hdrlen;\n        console.log(buffer.toString('binary', ret.offset, ret.offset + datalen));\n      } else if (ret.info.protocol === PROTOCOL.IP.UDP) {\n        console.log('Decoding UDP ...');\n\n        ret = decoders.UDP(buffer, ret.offset);\n        console.log(' from port: ' + ret.info.srcport + ' to port: ' + ret.info.dstport);\n        console.log(buffer.toString('binary', ret.offset, ret.offset + ret.info.length));\n      } else\n        console.log('Unsupported IPv4 protocol: ' + PROTOCOL.IP[ret.info.protocol]);\n    } else\n      console.log('Unsupported Ethertype: ' + PROTOCOL.ETHERNET[ret.info.type]);\n  }\n});\n```\n\n* Send an arbitrary packet: An arp request for example\n\n```javascript\nvar Cap = require('cap').Cap,\n    c = new Cap(),\n    device = Cap.findDevice('192.168.1.200'),\n    filter = 'arp',\n    bufSize = 10 * 1024 * 1024,\n    buffer = new Buffer(65535);\n\nvar linkType = c.open(device, filter, bufSize, buffer);\n\n\n// To use this example, change Source Mac, Sender Hardware Address (MAC) and Target Protocol address\nvar buffer = new Buffer ([\n    // ETHERNET\n    0xff, 0xff, 0xff, 0xff, 0xff,0xff,                  // 0    = Destination MAC\n    0x84, 0x8F, 0x69, 0xB7, 0x3D, 0x92,                 // 6    = Source MAC\n    0x08, 0x06,                                         // 12   = EtherType = ARP\n    // ARP\n    0x00, 0x01,                                         // 14/0   = Hardware Type = Ethernet (or wifi)\n    0x08, 0x00,                                         // 16/2   = Protocol type = ipv4 (request ipv4 route info)\n    0x06, 0x04,                                         // 18/4   = Hardware Addr Len (Ether/MAC = 6), Protocol Addr Len (ipv4 = 4)\n    0x00, 0x01,                                         // 20/6   = Operation (ARP, who-has)\n    0x84, 0x8f, 0x69, 0xb7, 0x3d, 0x92,                 // 22/8   = Sender Hardware Addr (MAC)\n    0xc0, 0xa8, 0x01, 0xc8,                             // 28/14  = Sender Protocol address (ipv4)\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                 // 32/18  = Target Hardware Address (Blank/nulls for who-has)\n    0xc0, 0xa8, 0x01, 0xc9                              // 38/24  = Target Protocol address (ipv4)\n]);\n\ntry {\n  // send will not work if pcap_sendpacket is not supported by underlying `device`\n  c.send(buffer, buffer.length);\n} catch (e) {\n  console.log(\"Error sending packet:\", e);\n}\n\n// TCPDUMP.  Note: Some values are changed by the network stack when the broadcast arp message is received.\n//12:28:33.230319 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.1.200 tell 192.168.1.199, length 46\n//0x0000:  ffff ffff ffff 848f 69b7 3d92 0806 0001  ........i.=.....\n//0x0010:  0800 0604 0001 848f 69b7 3d92 c0a8 01c7  ........i.=.....\n//0x0020:  0000 0000 0000 c0a8 01c8 0000 0000 0000  ................\n//0x0030:  0000 0000 0000 0000 0000 0000            ............\n//12:28:33.230336 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.1.200 is-at 74:ea:3a:a3:e6:69, length 28\n//0x0000:  848f 69b7 3d92 74ea 3aa3 e669 0806 0001  ..i.=.t.:..i....\n//0x0010:  0800 0604 0002 74ea 3aa3 e669 c0a8 01c8  ......t.:..i....\n//0x0020:  848f 69b7 3d92 c0a8 01c7                 ..i.=.....\n\n```\n\n* List all network devices:\n\n```javascript\nvar Cap = require('cap').Cap;\n\nconsole.dir(Cap.deviceList());\n\n// example output on Linux:\n// [ { name: 'eth0',\n//     addresses:\n//      [ { addr: '192.168.0.10',\n//          netmask: '255.255.255.0',\n//          broadaddr: '192.168.0.255' } ] },\n//   { name: 'nflog',\n//     description: 'Linux netfilter log (NFLOG) interface',\n//     addresses: [] },\n//   { name: 'any',\n//     description: 'Pseudo-device that captures on all interfaces',\n//     addresses: [] },\n//   { name: 'lo',\n//     addresses:\n//      [ { addr: '127.0.0.1', netmask: '255.0.0.0' },\n//        { addr: '::1',\n//          netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff' } ],\n//     flags: 'PCAP_IF_LOOPBACK' } ]\n```\n\n\nAPI\n===\n\nCap events\n----------\n\n* **packet**(< _integer_ >nbytes, < _boolean_ >truncated) - A packet `nbytes` in size was captured. `truncated` indicates if the entire packet did not fit inside the _Buffer_ supplied to open().\n\n\nCap methods\n-----------\n\n* **(constructor)**() - Creates and returns a new Cap instance.\n\n* **open**(< _string_ >device, < _string_ >filter, < _integer_ >bufSize, < _Buffer_ >buffer) - _(void)_ - Opens `device` and starts capturing packets using `filter`. To see the syntax for `filter` check [`pcap-filter` man page](http://www.tcpdump.org/manpages/pcap-filter.7.html). `bufSize` is the size of the internal buffer that libpcap uses to temporarily store packets until they are emitted. `buffer` is a Buffer large enough to store one packet. If open() is called again without a previous call to close(), an implicit close() will occur first.\n\n* **close**() - _(void)_ - Stops capturing.\n\n* **setMinBytes**(< _integer_ >nBytes) - _(void)_ - **(Windows ONLY)** This sets the minimum number of packet bytes that must be captured before the full packet data is made available. If this value is set too high, you may not receive any packets until WinPCap's internal buffer fills up. Therefore it's generally best to pass in 0 to this function after calling open(), despite it resulting in more syscalls.\n\n* **send**(< _Buffer_ >buffer[, < _integer_ >nBytes]) - _(void)_ - Sends an arbitrary, raw packet on the opened device. `nBytes` is the number of bytes in `buffer` to send (starting from position 0) and defaults to `buffer.length`.\n\n\nCap static methods\n------------------\n\n* **findDevice**([< _string_ >ip]) - _mixed_ - If `ip` is given, the (first) device name associated with `ip`, or undefined is returned if not found. If `ip` is not given, the device name of the first non-loopback device is returned.\n\n* **deviceList**() - _array_ - Returns a list of available devices and related information.\n\n\nDecoders static methods\n-----------------------\n\nThe following methods are available off of `require('cap').decoders`. They parse the relevant protocol header and return an object containing the parsed information:\n\n* Link Layer Protocols\n\n    * **Ethernet**(< _Buffer_ buf[, < _integer_ >bufOffset=0])\n\n* Internet Layer Protocols\n\n    * **IPV4**(< _Buffer_ buf[, < _integer_ >bufOffset=0])\n\n    * **IPV6**(< _Buffer_ buf[, < _integer_ >bufOffset=0])\n\n    * **ICMPV4**(< _Buffer_ buf, < _integer_ >nbytes[, < _integer_ >bufOffset=0])\n\n* Transport Layer Protocols\n\n    * **TCP**(< _Buffer_ buf[, < _integer_ >bufOffset=0])\n\n    * **UDP**(< _Buffer_ buf[, < _integer_ >bufOffset=0])\n\n    * **SCTP**(< _Buffer_ buf, < _integer_ >nbytes[, < _integer_ >bufOffset=0])\n","starsCount":2,"created":"2013-01-05T18:37:11.566Z","modified":"2016-10-06T18:26:53.779Z","lastPublisher":{"name":"mscdex","email":"mscdex@mscdex.net"},"owners":[{"name":"mscdex","email":"mscdex@mscdex.net"}],"other":{"_attachments":{},"_from":"https://github.com/mscdex/cap/tarball/v0.1.2","_id":"cap","_nodeVersion":"6.5.0","_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/cap-0.1.2.tgz_1475778411217_0.8432097346521914"},"_npmUser":{"name":"mscdex","email":"mscdex@mscdex.net"},"_npmVersion":"3.10.3","_rev":"1-3721bf8c4044023cbc70ad48d537b5a2","_shasum":"9ff2bb0a59d52dbf0b63d989fef21460df87b382","author":{"name":"Brian White","email":"mscdex@mscdex.net"},"bugs":{"url":"https://github.com/mscdex/cap/issues"},"directories":{},"dist-tags":{"latest":"0.1.2"},"dist":{"shasum":"9ff2bb0a59d52dbf0b63d989fef21460df87b382","tarball":"http://registry.npmjs.org/cap/-/cap-0.1.2.tgz"},"maintainers":[{"name":"mscdex","email":"mscdex@mscdex.net"}],"readmeFilename":"README.md","time":{"modified":"2016-10-06T18:26:53.779Z","created":"2013-01-05T18:37:11.566Z","0.0.1":"2013-01-05T18:37:13.200Z","0.0.2":"2013-01-06T01:33:52.530Z","0.0.3":"2013-02-12T05:47:17.255Z","0.0.4":"2013-02-19T19:44:46.569Z","0.0.5":"2013-03-28T00:34:44.143Z","0.0.6":"2013-10-10T20:17:29.652Z","0.0.7":"2013-12-01T03:26:31.435Z","0.0.8":"2014-01-23T19:11:52.013Z","0.0.9":"2014-07-10T15:03:03.681Z","0.0.10":"2014-07-22T16:00:04.129Z","0.0.11":"2015-02-01T20:54:30.511Z","0.0.12":"2015-02-10T04:58:45.461Z","0.0.13":"2015-04-06T13:32:23.367Z","0.0.14":"2015-05-05T17:30:57.071Z","0.0.15":"2015-05-15T14:26:08.710Z","0.1.0":"2015-09-02T00:12:08.192Z","0.1.1":"2016-01-09T20:30:57.655Z","0.1.2":"2016-10-06T18:26:53.779Z"},"users":{"hij1nx":true,"itsmealves":true}}}