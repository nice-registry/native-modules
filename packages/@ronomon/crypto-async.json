{"name":"@ronomon/crypto-async","version":"2.2.0","description":"Asynchronous cipher, hash, hmac","main":"index.js","repository":"https://github.com/ronomon/crypto-async","keywords":["async","asynchronous","crypto","hash","hmac","cipher","cipheriv","decipher","decipheriv","threadpool","worker","zero-copy","throughput","non-blocking","event loop"],"license":"MIT","homepage":"https://github.com/ronomon/crypto-async#readme","scripts":{"postinstall":"node-gyp clean","test":"node test.js","install":"node-gyp rebuild"},"dependencies":{"@ronomon/queue":"^2.1.0","nan":"^2.6.2"},"gypfile":true,"gitHead":"53b390cce87dc0a5a1779c2a1150402d7f552d89","versions":[{"number":"2.0.0","date":"2017-03-20T10:36:40.194Z"},{"number":"2.0.1","date":"2017-03-20T12:12:30.886Z"},{"number":"2.2.0","date":"2017-08-03T13:12:29.850Z"}],"readme":"# crypto-async\nNative Cipher, Hash, and HMAC operations executed in Node's threadpool for\nmulti-core throughput.\n\n## Motivation\n#### Some issues with parts of the `crypto` module\n* `crypto` cipher, hash and hmac streams are not really asynchronous. They\nexecute in C++, but only in the main thread and so they still block the event\nloop. Encrypting 64 MB of data might block the event loop for +/- 70ms. Hashing\n64 MB of data might block the event loop for +/- 190ms.\n* These `crypto` operations do not take advantage of multiple CPU cores. Your\nserver may have 4 cores available but `crypto` will use only 1 of these 4 cores\nfor all encrypting and hashing operations.\n* These `crypto` operations were not designed to use statically allocated\nbuffers. They allocate a new output buffer when encrypting or hashing data, even\nif you already have an output buffer available. If you want to hash only a\nportion of a buffer you must first create a slice. Thousands of JS object\nallocations put unnecessary strain on the GC. This in turn leads to longer GC\npauses which also block the event loop.\n* These `crypto` operations require multiple roundtrips between JS and C++ even\nif you are only encrypting or hashing a single buffer.\n* These `crypto` operations are not suitable for high-throughput network\nprotocols or filesystems which need to checksum and encrypt/decrypt large\namounts of data. Such a user-space network protocol or filesystem using `crypto`\nmight actually saturate a single CPU core with crypto operations before\nsaturating a fast local network or SSD disk.\n\n#### Some new ideas with the `crypto-async` module\n* Truly asynchronous. All calls execute asynchronously in the `node.js`\nthreadpool. This keeps the main thread and event loop free without blocking.\n* Scalable across multiple CPU cores. While `crypto-async` is a fraction slower\nper call than `crypto` (possibly because of the overhead of interacting with the\nthreadpool), for buffers larger than 1024 bytes it shines and provides N-cores\nmore throughput. `crypto-async` achieves up to 3x more throughput compared to\n`crypto`.\n* Zero-copy. All keys, ivs, source and target arguments can be passed directly\nusing offsets into existing buffers, without requiring any slices and without\nallocating any temporary output buffers. This enables predictable memory usage\nfor programs with tight memory budgets.\n* Designed to support the common use-case of encrypting or hashing a single\nbuffer, where memory is adequate and buffers are already in memory. This avoids\nmultiple round-trips between JS and C++.\n* Separates the control plane and the data plane to enable high-throughput\napplications.\n\n## Performance\n```\n\n           CPU: Intel(R) Xeon(R) CPU E3-1230 V2 @ 3.30GHz\n         Cores: 8\n       Threads: 4\n\n============================================================\n\n   AES-256-CTR: 10000 x 256 Bytes\n        crypto: Latency: 0.009ms Throughput: 24.62 MB/s\n  crypto-async: Latency: 0.039ms Throughput: 25.86 MB/s\n\n   AES-256-CTR: 10000 x 1024 Bytes\n        crypto: Latency: 0.011ms Throughput: 91.43 MB/s\n  crypto-async: Latency: 0.039ms Throughput: 103.43 MB/s\n\n   AES-256-CTR: 10000 x 4096 Bytes\n        crypto: Latency: 0.019ms Throughput: 186.18 MB/s\n  crypto-async: Latency: 0.038ms Throughput: 417.96 MB/s\n\n   AES-256-CTR: 1024 x 65536 Bytes\n        crypto: Latency: 0.091ms Throughput: 699.05 MB/s\n  crypto-async: Latency: 0.095ms Throughput: 2684.35 MB/s\n\n   AES-256-CTR: 64 x 1048576 Bytes\n        crypto: Latency: 1.105ms Throughput: 945.20 MB/s\n  crypto-async: Latency: 1.362ms Throughput: 3050.40 MB/s\n\n============================================================\n\n   HASH-SHA256: 10000 x 256 Bytes\n        crypto: Latency: 0.005ms Throughput: 43.39 MB/s\n  crypto-async: Latency: 0.038ms Throughput: 25.10 MB/s\n\n   HASH-SHA256: 10000 x 1024 Bytes\n        crypto: Latency: 0.010ms Throughput: 96.60 MB/s\n  crypto-async: Latency: 0.029ms Throughput: 140.27 MB/s\n\n   HASH-SHA256: 10000 x 4096 Bytes\n        crypto: Latency: 0.016ms Throughput: 246.75 MB/s\n  crypto-async: Latency: 0.038ms Throughput: 422.27 MB/s\n\n   HASH-SHA256: 1024 x 65536 Bytes\n        crypto: Latency: 0.192ms Throughput: 338.93 MB/s\n  crypto-async: Latency: 0.242ms Throughput: 1065.22 MB/s\n\n   HASH-SHA256: 64 x 1048576 Bytes\n        crypto: Latency: 3.023ms Throughput: 347.71 MB/s\n  crypto-async: Latency: 3.162ms Throughput: 1290.56 MB/s\n\n============================================================\n\n   HMAC-SHA256: 10000 x 256 Bytes\n        crypto: Latency: 0.008ms Throughput: 27.23 MB/s\n  crypto-async: Latency: 0.039ms Throughput: 25.35 MB/s\n\n   HMAC-SHA256: 10000 x 1024 Bytes\n        crypto: Latency: 0.011ms Throughput: 80.63 MB/s\n  crypto-async: Latency: 0.032ms Throughput: 123.37 MB/s\n\n   HMAC-SHA256: 10000 x 4096 Bytes\n        crypto: Latency: 0.020ms Throughput: 197.87 MB/s\n  crypto-async: Latency: 0.039ms Throughput: 390.10 MB/s\n\n   HMAC-SHA256: 1024 x 65536 Bytes\n        crypto: Latency: 0.195ms Throughput: 335.54 MB/s\n  crypto-async: Latency: 0.279ms Throughput: 945.20 MB/s\n\n   HMAC-SHA256: 64 x 1048576 Bytes\n        crypto: Latency: 3.134ms Throughput: 335.54 MB/s\n  crypto-async: Latency: 3.974ms Throughput: 1048.58 MB/s\n\n```\n\n## Installation\nThis will install `crypto-async` and compile the native binding automatically:\n```\nnpm install @ronomon/crypto-async\n```\n\n## Usage\n\n#### Adjust threadpool size and control concurrency\nNode runs filesystem and DNS operations in the threadpool. The threadpool\nconsists of 4 threads by default. This means that at most 4 operations can be\nrunning at any point in time. If any operation is slow to complete, it will\ncause head-of-line blocking. The size of the threadpool should therefore be\nincreased at startup time (at the top of your script, before requiring any\nmodules) by setting the `UV_THREADPOOL_SIZE` environment variable (the absolute\nmaximum is 128 threads, which requires only ~1 MB memory in total according to\nthe [libuv docs](http://docs.libuv.org/en/v1.x/threadpool.html)).\n\nConventional wisdom would set the number of threads to the number of CPU cores,\nbut most operations running in the threadpool are not run hot, they are not\nCPU-intensive and block mostly on IO. Issuing more IO operations than there are\nCPU cores will increase throughput and will decrease latency per operation by\ndecreasing queueing time. On the other hand, `crypto-async` operations are\nCPU-intensive. Issuing more `crypto-async` operations than there are CPU cores\nwill not increase throughput and will increase latency per operation by\nincreasing queueing time.\n\nYou should therefore:\n\n1. Set the threadpool size to `IO` + `N`, where `IO` is the number of filesystem\nand DNS operations you expect to be running concurrently, and where `N` is the\nnumber of CPU cores available. This will reduce head-of-line blocking.\n\n2. Allow or design for at most `N` `crypto-async` operations to be running\nconcurrently, where `N` is the number of CPU cores available. This will keep\nlatency within reasonable bounds.\n\n```javascript\n// At the top of your script, before requiring any modules:\nprocess.env['UV_THREADPOOL_SIZE'] = 128;\n```\n\n#### Cipher\n```javascript\nvar cryptoAsync = require('@ronomon/crypto-async');\nvar algorithm = 'AES-256-CTR';\nvar encrypt = 1; // 1 = Encrypt\nvar key = Buffer.alloc(32);\nvar iv = Buffer.alloc(16);\nvar plaintext = Buffer.alloc(128);\ncryptoAsync.cipher(algorithm, encrypt, key, iv, plaintext,\n  function(error, ciphertext) {\n    if (error) throw error;\n    console.log(ciphertext.toString('hex'));\n    var encrypt = 0; // 0 = Decrypt\n    cryptoAsync.cipher(algorithm, encrypt, key, iv, ciphertext,\n      function(error, plaintext) {\n        if (error) throw error;\n        console.log(plaintext.toString('hex'));\n      }\n    );\n  }\n);\n```\n\n#### Hash\n```javascript\nvar cryptoAsync = require('@ronomon/crypto-async');\nvar algorithm = 'SHA256';\nvar source = Buffer.alloc(1024 * 1024);\ncryptoAsync.hash(algorithm, source,\n  function(error, hash) {\n    if (error) throw error;\n    console.log(hash.toString('hex'));\n  }\n);\n```\n\n#### HMAC\n```javascript\nvar cryptoAsync = require('@ronomon/crypto-async');\nvar algorithm = 'SHA256';\nvar key = Buffer.alloc(1024);\nvar source = Buffer.alloc(1024 * 1024);\ncryptoAsync.hmac(algorithm, key, source,\n  function(error, hmac) {\n    if (error) throw error;\n    console.log(hmac.toString('hex'));\n  }\n);\n```\n\n### Zero-Copy Methods\n\nThe following method alternatives require more arguments but support zero-copy\ncrypto operations, for reduced memory overhead and GC pressure.\n\n#### Cipher (Zero-Copy)\n```javascript\nvar cryptoAsync = require('@ronomon/crypto-async');\nvar algorithm = 'AES-256-CTR';\nvar encrypt = 1; // 0 = Decrypt, 1 = Encrypt\nvar key = Buffer.alloc(1024);\nvar keyOffset = 4;\nvar keySize = 32;\nvar iv = Buffer.alloc(32);\nvar ivOffset = 2;\nvar ivSize = 16;\nvar source = Buffer.alloc(1024 * 1024);\nvar sourceOffset = 512;\nvar sourceSize = 32;\nvar target = Buffer.alloc(1024 * 1024);\nvar targetOffset = 32768;\ncryptoAsync.cipher(\n  algorithm,\n  encrypt,\n  key,\n  keyOffset,\n  keySize,\n  iv,\n  ivOffset,\n  ivSize,\n  source,\n  sourceOffset,\n  sourceSize,\n  target,\n  targetOffset,\n  function(error, targetSize) {\n    if (error) throw error;\n    var slice = target.slice(targetOffset, targetOffset + targetSize);\n    console.log(slice.toString('hex'));\n  }\n);\n```\n\n#### Hash (Zero-Copy)\n```javascript\nvar cryptoAsync = require('@ronomon/crypto-async');\nvar algorithm = 'SHA256';\nvar source = Buffer.alloc(1024 * 1024);\nvar sourceOffset = 512;\nvar sourceSize = 65536;\nvar target = Buffer.alloc(1024 * 1024);\nvar targetOffset = 32768;\ncryptoAsync.hash(\n  algorithm,\n  source,\n  sourceOffset,\n  sourceSize,\n  target,\n  targetOffset,\n  function(error, targetSize) {\n    if (error) throw error;\n    var slice = target.slice(targetOffset, targetOffset + targetSize);\n    console.log(slice.toString('hex'));\n  }\n);\n```\n\n#### HMAC (Zero-Copy)\n```javascript\nvar cryptoAsync = require('@ronomon/crypto-async');\nvar algorithm = 'SHA256';\nvar key = Buffer.alloc(1024);\nvar keyOffset = 4;\nvar keySize = 8;\nvar source = Buffer.alloc(1024 * 1024);\nvar sourceOffset = 512;\nvar sourceSize = 65536;\nvar target = Buffer.alloc(1024 * 1024);\nvar targetOffset = 32768;\ncryptoAsync.hmac(\n  algorithm,\n  key,\n  keyOffset,\n  keySize,\n  source,\n  sourceOffset,\n  sourceSize,\n  target,\n  targetOffset,\n  function(error, targetSize) {\n    if (error) throw error;\n    var slice = target.slice(targetOffset, targetOffset + targetSize);\n    console.log(slice.toString('hex'));\n  }\n);\n```\n\n## Tests\n`crypto-async` ships with a long-running fuzz test:\n\n```\nnode test.js\n```\n\n## Benchmark\nTo benchmark `crypto-async` vs `crypto`:\n```\nnode benchmark.js\n```\n\n## AEAD Ciphers\n\nAEAD ciphers such as GCM are currently not supported and may be added in future\nas an `aead` method.\n","created":"2017-03-20T10:36:40.194Z","modified":"2017-08-03T13:12:29.850Z","lastPublisher":{"name":"ronomon","email":"info@ronomon.com"},"owners":[{"name":"ronomon","email":"info@ronomon.com"}],"other":{"_attachments":{},"_id":"@ronomon/crypto-async","_nodeVersion":"8.2.1","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/crypto-async-2.2.0.tgz_1501765949740_0.24307815171778202"},"_npmUser":{"name":"ronomon","email":"info@ronomon.com"},"_npmVersion":"5.3.0","_rev":"3-cd2abacb591b0c9441ad3a774065797a","author":{"name":"Joran Dirk Greef"},"bugs":{"url":"https://github.com/ronomon/crypto-async/issues"},"directories":{},"dist-tags":{"latest":"2.2.0"},"dist":{"integrity":"sha512-Ne5AkS7b8hOVtNZlhTxBUwiP5h5gN2bLWneHhV+yvn+RRE4kNG8ZzM1BtvWz6steZhi0WWnH+0ewed/8f0K+ZQ==","shasum":"9a3f428777f3e8c6cdce52d272f44bdd071c0421","tarball":"https://registry.npmjs.org/@ronomon/crypto-async/-/crypto-async-2.2.0.tgz"},"maintainers":[{"name":"ronomon","email":"info@ronomon.com"}],"readmeFilename":"README.md","time":{"modified":"2017-08-03T13:12:29.850Z","created":"2017-03-20T10:36:40.194Z","2.0.0":"2017-03-20T10:36:40.194Z","2.0.1":"2017-03-20T12:12:30.886Z","2.2.0":"2017-08-03T13:12:29.850Z"}}}