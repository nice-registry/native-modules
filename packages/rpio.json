{"name":"rpio","version":"0.9.17","description":"High performance GPIO/i2c/PWM/SPI module for Raspberry Pi","main":"./lib/rpio.js","scripts":{"test":"true","install":"node-gyp rebuild"},"dependencies":{"bindings":"*","nan":"*"},"engines":{"node":">=0.8"},"repository":"https://github.com/jperkin/node-rpio","keywords":["bcm2835","gpio","gpiomem","i2c","mmap","pi","pwm","raspberry","raspberrypi","raspberry pi","rpi","spi"],"license":"(ISC AND GPL-2.0)","gypfile":true,"gitHead":"4d4ef6c03e50e8875c85bec10173b9afd9a58fa5","homepage":"https://github.com/jperkin/node-rpio#readme","versions":[{"number":"0.0.1","date":"2012-10-20T22:20:30.275Z"},{"number":"0.0.2","date":"2012-10-20T22:23:28.436Z"},{"number":"0.0.3","date":"2012-10-21T19:31:17.631Z"},{"number":"0.0.4","date":"2012-10-21T20:17:13.634Z"},{"number":"0.0.5","date":"2013-05-20T17:02:32.332Z"},{"number":"0.0.6","date":"2013-05-20T17:59:22.284Z"},{"number":"0.0.7","date":"2015-03-05T21:50:17.423Z"},{"number":"0.0.8","date":"2015-03-05T23:27:26.179Z"},{"number":"0.0.9","date":"2015-03-05T23:44:57.697Z"},{"number":"0.0.10","date":"2015-03-06T11:55:36.844Z"},{"number":"0.1.0","date":"2015-03-06T14:50:13.425Z"},{"number":"0.1.1","date":"2015-03-06T14:58:25.163Z"},{"number":"0.1.2","date":"2015-03-06T23:13:55.462Z"},{"number":"0.2.0","date":"2015-03-09T21:13:49.515Z"},{"number":"0.2.1","date":"2015-03-09T21:16:30.694Z"},{"number":"0.2.2","date":"2015-03-09T21:29:55.980Z"},{"number":"0.2.3","date":"2015-03-10T09:56:42.769Z"},{"number":"0.3.0","date":"2015-03-12T13:38:06.773Z"},{"number":"0.3.1","date":"2015-03-12T13:47:01.301Z"},{"number":"0.4.0","date":"2015-03-13T19:48:20.504Z"},{"number":"0.4.1","date":"2015-03-13T20:40:25.540Z"},{"number":"0.4.2","date":"2015-03-13T20:53:27.515Z"},{"number":"0.4.3","date":"2015-03-14T19:25:23.561Z"},{"number":"0.4.4","date":"2015-04-23T10:19:31.856Z"},{"number":"0.4.5","date":"2015-12-14T17:01:03.637Z"},{"number":"0.5.0","date":"2015-12-18T11:57:15.605Z"},{"number":"0.5.1","date":"2015-12-19T09:05:32.742Z"},{"number":"0.6.0","date":"2015-12-19T20:35:28.975Z"},{"number":"0.6.1","date":"2015-12-19T22:30:52.035Z"},{"number":"0.6.2","date":"2015-12-19T22:31:52.352Z"},{"number":"0.6.3","date":"2015-12-19T22:33:12.159Z"},{"number":"0.6.4","date":"2015-12-19T23:35:28.276Z"},{"number":"0.6.5","date":"2015-12-19T23:38:15.716Z"},{"number":"0.6.6","date":"2015-12-28T22:24:56.429Z"},{"number":"0.7.0","date":"2016-01-04T23:02:35.847Z"},{"number":"0.8.0","date":"2016-01-06T10:14:19.347Z"},{"number":"0.8.1","date":"2016-01-06T10:38:31.296Z"},{"number":"0.8.2","date":"2016-01-06T10:44:16.644Z"},{"number":"0.8.3","date":"2016-01-06T10:57:30.537Z"},{"number":"0.8.4","date":"2016-01-06T11:36:32.903Z"},{"number":"0.8.5","date":"2016-01-06T11:38:55.065Z"},{"number":"0.8.6","date":"2016-01-06T11:46:41.957Z"},{"number":"0.8.7","date":"2016-01-06T12:48:51.234Z"},{"number":"0.8.8","date":"2016-01-06T12:52:20.196Z"},{"number":"0.8.9","date":"2016-01-07T16:41:41.033Z"},{"number":"0.8.10","date":"2016-01-07T18:02:45.262Z"},{"number":"0.8.11","date":"2016-01-07T18:06:33.752Z"},{"number":"0.9.0","date":"2016-01-07T23:16:44.887Z"},{"number":"0.9.1","date":"2016-01-07T23:22:17.253Z"},{"number":"0.9.2","date":"2016-01-08T11:28:54.321Z"},{"number":"0.9.3","date":"2016-01-08T11:33:39.456Z"},{"number":"0.9.4","date":"2016-01-08T16:09:02.199Z"},{"number":"0.9.5","date":"2016-01-09T19:57:45.160Z"},{"number":"0.9.6","date":"2016-01-10T19:44:50.856Z"},{"number":"0.9.7","date":"2016-01-20T11:41:11.746Z"},{"number":"0.9.8","date":"2016-02-22T08:18:28.680Z"},{"number":"0.9.9","date":"2016-02-22T09:21:46.848Z"},{"number":"0.9.10","date":"2016-03-09T10:09:18.234Z"},{"number":"0.9.11","date":"2016-04-29T11:33:15.919Z"},{"number":"0.9.12","date":"2016-08-19T08:24:58.137Z"},{"number":"0.9.13","date":"2016-12-21T08:01:47.662Z"},{"number":"0.9.14","date":"2016-12-29T14:49:14.148Z"},{"number":"0.9.15","date":"2017-01-31T19:56:15.120Z"},{"number":"0.9.16","date":"2017-03-03T22:38:25.160Z"},{"number":"0.9.17","date":"2017-06-23T09:25:30.405Z"}],"readme":"node-rpio\n=========\n\nThis is a high performance node.js addon which provides access to the Raspberry\nPi GPIO interface, supporting regular GPIO as well as i²c, PWM, and SPI.\n\n[![Node.js version](https://img.shields.io/node/v/rpio.svg)](http://nodejs.org/download/)\n[![NPM version](https://badge.fury.io/js/rpio.svg)](http://badge.fury.io/js/rpio)\n[![Build Status](https://travis-ci.org/jperkin/node-rpio.svg?branch=master)](https://travis-ci.org/jperkin/node-rpio)\n\n## Compatibility\n\n* Raspberry Pi Models: A, B (revisions 1.0 and 2.0), A+, B+, 2, 3, Zero.\n* Node.js Versions: 0.8, 0.10, 0.12, 4.x, 5.x, 6.x, 7.x\n\nNewer versions of node.js require you to install the GCC 4.8 packages for C++11\nsupport.  If you see compilation problems related to C++11, this is the likely\ncause.\n\n## Install\n\nEasily install the latest via npm:\n\n```console\n$ npm install rpio\n```\n\nBy default the module will use `/dev/gpiomem` when using simple GPIO access.\nTo access this device, your user will need to be a member of the `gpio` group,\nand you may need to configure udev with the following rule (as root):\n\n```console\n$ cat >/etc/udev/rules.d/20-gpiomem.rules <<EOF\nSUBSYSTEM==\"bcm2835-gpiomem\", KERNEL==\"gpiomem\", GROUP=\"gpio\", MODE=\"0660\"\nEOF\n```\n\nFor access to i²c, PWM, and SPI, or if you are running an older kernel which\ndoes not have the `bcm2835-gpiomem` module, you will need to run your programs\nas root for access to `/dev/mem`.\n\n## Quickstart\n\nAll these examples use the physical numbering (P01-P40) and assume that the\nexample is started with:\n\n```js\nvar rpio = require('rpio');\n```\n\n### Read a pin\n\nSetup pin P11 / GPIO17 for read-only input and print its current value:\n\n```js\nrpio.open(11, rpio.INPUT);\nconsole.log('Pin 11 is currently set ' + (rpio.read(11) ? 'high' : 'low'));\n```\n\n### Blink an LED\n\nBlink an LED attached to P12 / GPIO18 a few times:\n\n```js\n/*\n * Set the initial state to low.  The state is set prior to the pin becoming\n * active, so is safe for devices which require a stable setup.\n */\nrpio.open(12, rpio.OUTPUT, rpio.LOW);\n\n/*\n * The sleep functions block, but rarely in these simple programs does one care\n * about that.  Use a setInterval()/setTimeout() loop instead if it matters.\n */\nfor (var i = 0; i < 5; i++) {\n        /* On for 1 second */\n        rpio.write(12, rpio.HIGH);\n        rpio.sleep(1);\n\n        /* Off for half a second (500ms) */\n        rpio.write(12, rpio.LOW);\n        rpio.msleep(500);\n}\n```\n\n### Poll a button switch for events\n\nConfigure the internal pulldown resistor on P15 / GPIO22 and watch the pin for\nstate changes from an attached button switch:\n\n```js\nrpio.open(15, rpio.INPUT, rpio.PULL_DOWN);\n\nfunction pollcb(pin)\n{\n        /*\n         * Interrupts aren't supported by the underlying hardware, so events\n         * may be missed during the 1ms poll window.  The best we can do is to\n         * print the current state after a event is detected.\n         */\n        var state = rpio.read(pin) ? 'pressed' : 'released';\n        console.log('Button event on P%d (button currently %s)', pin, state);\n}\n\nrpio.poll(15, pollcb);\n```\n\nA collection of example programs are also available in the\n[examples](https://github.com/jperkin/node-rpio/tree/master/examples)\ndirectory.\n\n## Features\n\nThere are lots of GPIO modules available for node.js.  Why use this one?\n\n### Performance\n\nIt's very fast.  Part of the module is a native addon which links against Mike\nMcCauley's [bcm2835](http://www.open.com.au/mikem/bcm2835/) library, providing\ndirect access to the hardware via `/dev/mem` and `/dev/gpiomem`.\n\nMost alternative GPIO modules use the slower `/sys` file system interface.\n\nHow much faster?  Here is a [simple\ntest](https://gist.github.com/jperkin/e1f0ce996c83ccf2bca9) which calculates\nhow long it takes to switch a pin on and off 1 million times:\n\n* rpi-gpio (using `/sys`): `701.023` seconds\n* rpio (using `/dev/*mem`): `0.684` seconds\n\nSo rpio can be anywhere up to **1000x faster** than the alternatives.\n\n### Hardware support\n\nWhile `/sys` provides a simple interface to GPIO, not all hardware features are\nsupported, and it's not always possible to handle certain types of hardware,\nespecially when employing an asynchronous model.  Using the `/dev/*mem`\ninterface means rpio can support a lot more functionality:\n\n* rpio supports sub-millisecond access, with features to support multiple\n  reads/writes directly with hardware rather than being delayed by the event\n  loop.\n\n* Output pins can be configured with a default state prior to being enabled,\n  required by some devices and not possible to configure via `/sys`.\n\n* Internal pullup/pulldown registers can be configured.\n\n* Hardware i²c, PWM, and SPI functions are supported.\n\n### Simple programming\n\nrpio tries to make it simple to program devices, rather than having to jump\nthrough hoops to support an asynchronous workflow.  Some parts of rpio block,\nbut that is intentional in order to provide a simpler interface, as well as\nbeing able to support time-sensitive devices.\n\nThe aim is to provide an interface familiar to Unix programmers, with the\nperformance to match.\n\n## API\n\nStart by requiring the addon.\n\n```js\nvar rpio = require('rpio');\n```\n\n### GPIO\n\nGeneral purpose I/O tries to follow a standard open/read/write/close model.\n\nSome useful constants are provided for use by all supporting functions:\n\n* `rpio.HIGH`: pin high/1/on\n* `rpio.LOW`: pin low/0/off\n\nThese can be useful to avoid magic numbers in your code.\n\n#### `rpio.init([options])`\n\nInitialise the bcm2835 library.  This will be called automatically by `.open()`\nusing the default option values if not called explicitly.  The default values\nare:\n\n```js\nvar options = {\n        gpiomem: true,          /* Use /dev/gpiomem */\n        mapping: 'physical',    /* Use the P1-P40 numbering scheme */\n}\n```\n\n##### `gpiomem`\n\nThere are two device nodes for GPIO access.  The default is `/dev/gpiomem`\nwhich, when configured with `gpio` group access, allows users in that group to\nread/write directly to that device.  This removes the need to run as root, but\nis limited to GPIO functions.\n\nFor non-GPIO functions (i²c, PWM, SPI) the `/dev/mem` device is required for\nfull access to the Broadcom peripheral address range and the program needs to\nbe executed as the root user (e.g. via sudo).  If you do not explicitly call\n`.init()` when using those functions, the library will do it for you with\n`gpiomem: false`.\n\nYou may also need to use `gpiomem: false` if you are running on an older Linux\nkernel which does not support the `gpiomem` module.\n\nrpio will throw an exception if you try to use one of the non-GPIO functions\nafter already opening with `/dev/gpiomem`, as well as checking to see if you\nhave the necessary permissions.\n\nValid options:\n\n* `true`: use `/dev/gpiomem` for non-root but GPIO-only access\n* `false`: use `/dev/mem` for full access but requires root\n\n#### `mapping`\n\nThere are two naming schemes when referring to GPIO pins:\n\n* By their physical header location: Pins 1 to 26 (A/B) or Pins 1 to 40 (A+/B+)\n* Using the Broadcom hardware map: GPIO 0-25 (B rev1), GPIO 2-27 (A/B rev2, A+/B+)\n\nConfusingly however, the Broadcom GPIO map changes between revisions, so for\nexample P3 maps to GPIO0 on Model B Revision 1 models, but maps to GPIO2 on all\nlater models.\n\nThis means the only sane default mapping is the physical layout, so that the\nsame code will work on all models regardless of the underlying GPIO mapping.\n\nIf you prefer to use the Broadcom GPIO scheme for whatever reason (e.g. to use\nthe P5 header pins on the Raspberry Pi 1 revision 2.0 model which aren't\ncurrently mapped to the physical layout), you can set `mapping` to `gpio` to\nswitch to the GPIOxx naming.\n\nValid options:\n\n* `gpio`: use the Broadcom GPIOxx naming\n* `physical`: use the physical P01-P40 header layout\n\nExamples:\n\n```js\nrpio.init({gpiomem: false});    /* Use /dev/mem for i²c/PWM/SPI */\nrpio.init({mapping: 'gpio'});   /* Use the GPIOxx numbering */\n```\n\n#### `rpio.open(pin, mode[, option])`\n\nOpen a pin for input or output.  Valid modes are:\n\n* `rpio.INPUT`: pin is input (read-only).\n* `rpio.OUTPUT`: pin is output (read-write).\n* `rpio.PWM`: configure pin for hardware PWM (see PWM section below).\n\nFor input pins, `option` can be used to configure the internal pullup or\npulldown resistors using options as described in the `.pud()` documentation\nbelow.\n\nFor output pins, `option` defines the initial state of the pin, rather than\nhaving to issue a separate `.write()` call.  This can be critical for devices\nwhich must have a stable value, rather than relying on the initial floating\nvalue when a pin is enabled for output but hasn't yet been configured with a\nvalue.\n\nExamples:\n\n```js\n/* Configure P11 as input with the internal pulldown resistor enabled */\nrpio.open(11, rpio.INPUT, rpio.PULL_DOWN);\n\n/* Configure P12 as output with the initiate state set high */\nrpio.open(12, rpio.OUTPUT, rpio.HIGH);\n\n/* Configure P13 as output, but leave it in its initial undefined state */\nrpio.open(13, rpio.OUTPUT);\n```\n\n#### `rpio.mode(pin, mode)`\n\nSwitch a pin that has already been opened in one mode to a different mode.\nThis is provided primarily for performance reasons, as it avoids some of the\nsetup work done by `.open()`.\n\nExample:\n\n```js\nrpio.mode(12, rpio.INPUT);      /* Switch P12 back to input mode */\n```\n\n#### `rpio.read(pin)`\n\nRead the current value of `pin`, returning either `1` (high) or `0` (low).\n\nExample:\n\n```js\nconsole.log('Pin 12 = %d', rpio.read(12));\n```\n\n#### `rpio.readbuf(pin, buffer[, length])`\n\nRead `length` bits from `pin` into `buffer` as fast as possible.  If `length`\nisn't specified it defaults to `buffer.length`.\n\nThis is useful for devices which send out information faster than the\nJavaScript function call overhead can handle, e.g. if you need microsecond\naccuracy.  See\n[dht11.js](https://github.com/jperkin/node-rpio/blob/master/examples/dht11.js)\nfor an example which uses this to pull data from a DHT11 temperature/humidity\nsensor.\n\nExample:\n\n```js\nvar buf = new Buffer(10000);\n\n/* Read the value of Pin 12 10,000 times in a row, storing the values in buf */\nrpio.readbuf(12, buf);\n```\n\n#### `rpio.write(pin, value)`\n\nSet the specified pin either high or low, using either the\n`rpio.HIGH`/`rpio.LOW` constants, or simply `1` or `0`.\n\nExample:\n\n```js\nrpio.write(13, rpio.HIGH);\n```\n\n#### `rpio.writebuf(pin, buffer[, length])`\n\nWrite `length` bits to `pin` from `buffer` as fast as possible.  If `length`\nisn't specified it defaults to `buffer.length`.\n\nExample:\n\n```js\n/* Write 1 0 1 0 1 0 1 0 to Pin 13 */\nvar buf = new Buffer(8).fill(rpio.LOW);\nbuf[0] = buf[2] = buf[4] = buf[6] = rpio.HIGH;\nrpio.writebuf(13, buf);\n```\n\n#### `rpio.readpad(group)`\n\nRead the current state of the GPIO pad control for the specified GPIO group.\nOn current models of Raspberry Pi there are three groups with corresponding\ndefines:\n\n* `rpio.PAD_GROUP_0_27`: GPIO0 - GPIO27.  Use this for the main GPIO header.\n* `rpio.PAD_GROUP_28_45`: GPIO28 - GPIO45.  Use this to configure the P5 header.\n* `rpio.PAD_GROUP_46_53`: GPIO46 - GPIO53.  Internal, you probably won't need this.\n\nThe value returned will be a bit mask of the following defines:\n\n* `rpio.PAD_SLEW_UNLIMITED`: `0x10`.  Slew rate unlimited if set.\n* `rpio.PAD_HYSTERESIS`: `0x08`.  Hysteresis is enabled if set.\n\nThe bottom three bits determine the drive current:\n\n* `rpio.PAD_DRIVE_2mA`: `0b000`\n* `rpio.PAD_DRIVE_4mA`: `0b001`\n* `rpio.PAD_DRIVE_6mA`: `0b010`\n* `rpio.PAD_DRIVE_8mA`: `0b011`\n* `rpio.PAD_DRIVE_10mA`: `0b100`\n* `rpio.PAD_DRIVE_12mA`: `0b101`\n* `rpio.PAD_DRIVE_14mA`: `0b110`\n* `rpio.PAD_DRIVE_16mA`: `0b111`\n\nNote that the pad control registers are not available via `/dev/gpiomem`, so\nyou will need to use `.init({gpiomem: false})` and run as root.\n\nExample:\n\n```js\nvar curpad = rpio.readpad(rpio.PAD_GROUP_0_27);\n\nvar slew = ((curpad & rpio.PAD_SLEW_UNLIMITED) == rpio.PAD_SLEW_UNLIMITED);\nvar hysteresis = ((curpad & rpio.PAD_HYSTERESIS) == rpio.PAD_HYSTERESIS);\nvar drive = (curpad & 0x7);\n\nconsole.log('GPIO Pad Control for GPIO0 - GPIO27 is currently set to:');\nconsole.log('\\tSlew rate: ' + (slew ? 'unlimited' : 'limited'));\nconsole.log('\\tInput hysteresis: ' + (hysteresis ? 'enabled' : 'disabled'));\nconsole.log('\\tDrive rate: ' + (drive * 2 + 2) + 'mA');\n```\n\n#### `rpio.writepad(group, control)`\n\nWrite `control` settings to the pad control for `group`.  Uses the same defines\nas above for `.readpad()`.\n\nExample:\n\n```js\n/* Disable input hysteresis but retain other current settings. */\nvar control = rpio.readpad(rpio.PAD_GROUP_0_27);\ncontrol &= ~rpio.PAD_HYSTERESIS;\nrpio.writepad(rpio.PAD_GROUP_0_27, control);\n```\n\n#### `rpio.pud(pin, state)`\n\nConfigure the pin's internal pullup or pulldown resistors, using the following\n`state` constants:\n\n* `rpio.PULL_OFF`: disable configured resistors.\n* `rpio.PULL_DOWN`: enable the pulldown resistor.\n* `rpio.PULL_UP`: enable the pullup resistor.\n\nExamples:\n\n```js\nrpio.pud(11, rpio.PULL_UP);\nrpio.pud(12, rpio.PULL_DOWN);\n```\n\n#### `rpio.poll(pin, cb[, direction])`\n\nWatch `pin` for changes and execute the callback `cb()` on events.  `cb()`\ntakes a single argument, the pin which triggered the callback.\n\nThe optional `direction` argument can be used to watch for specific events:\n\n* `rpio.POLL_LOW`: poll for falling edge transitions to low.\n* `rpio.POLL_HIGH`: poll for rising edge transitions to high.\n* `rpio.POLL_BOTH`: poll for both transitions (the default).\n\nDue to hardware/kernel limitations we can only poll for changes, and the event\ndetection only says that an event occurred, not which one.  The poll interval\nis a 1ms `setInterval()` and transitions could come in between detecting the\nevent and reading the value.  Therefore this interface is only useful for\nevents which transition slower than approximately 1kHz.\n\nTo stop watching for `pin` changes, call `.poll()` again, setting the callback\nto `null` (or anything else which isn't a function).\n\nExample:\n\n```js\nfunction nuke_button(pin)\n{\n        console.log('Nuke button on pin %d pressed', pin);\n\n        /* No need to nuke more than once. */\n        rpio.poll(pin, null);\n}\n\nfunction regular_button(pin)\n{\n        /* Watch pin 11 forever. */\n        console.log('Button event on pin %d, is now %d', pin, rpio.read(pin));\n}\n\n/*\n * Pin 11 watches for both high and low transitions.  Pin 12 only watches for\n * high transitions (e.g. the nuke button is pushed).\n */\nrpio.poll(11, regular_button);\nrpio.poll(12, nuke_button, rpio.POLL_HIGH);\n```\n\n#### `rpio.close(pin[, reset])`\n\nIndicate that the pin will no longer be used, and clear any poll events\nassociated with it.\n\nThe optional `reset` argument can be used to configure the state that `pin`\nwill be left in after close:\n\n* `rpio.PIN_RESET`: return pin to `rpio.INPUT` and clear any pullup/pulldown\n  resistors.  This is the default.\n* `rpio.PIN_PRESERVE`: leave pin in its currently configured state.\n\nExamples:\n\n```js\nrpio.close(11);\nrpio.close(12, rpio.PIN_RESET);\nrpio.close(13, rpio.PIN_PRESERVE);\n```\n\n#### GPIO demo\n\nThe code below continuously flashes an LED connected to pin 11 at 100Hz.\n\n```js\nvar rpio = require('rpio');\n\n/* Configure P11 as an output pin, setting its initial state to low */\nrpio.open(11, rpio.OUTPUT, rpio.LOW);\n\n/* Set the pin high every 10ms, and low 5ms after each transition to high */\nsetInterval(function() {\n        rpio.write(11, rpio.HIGH);\n        setTimeout(function() {\n                rpio.write(11, rpio.LOW);\n        }, 5);\n}, 10);\n```\n\n### i²c\n\ni²c is primarily of use for driving LCD displays, and makes use of pins 3 and 5\n(GPIO0/GPIO1 on Rev 1, GPIO2/GPIO3 on Rev 2 and newer).  The bcm2835 library\nautomatically detects which Raspberry Pi revision you are running, so you do\nnot need to worry about which i²c bus to configure.\n\nTo get started call `.i2cBegin()` which assigns pins 3 and 5 to i²c use.  Until\n`.i2cEnd()` is called they won't be available for GPIO use.  The pin\nassignments are:\n\n* Pin 3: SDA (Serial Data)\n* Pin 5: SCL (Serial Clock)\n\n`.i2cBegin()` will call `.init()` if it hasn't already been called, with\n`gpiomem: false` set.  Hardware i²c support requires `/dev/mem` access and\ntherefore root.\n\n```js\nrpio.i2cBegin();\n```\n\nConfigure the slave address.  This is between `0 - 0x7f`, and it can be helpful\nto run the `i2cdetect` program to figure out where your devices are if you are\nunsure.\n\n```js\nrpio.i2cSetSlaveAddress(0x20);\n```\n\nSet the baud rate.  You can do this two different ways, depending on your\npreference.  Either use `.i2cSetBaudRate()` to directly set the speed in hertz,\nor `.i2cSetClockDivider()` to set it based on a divisor of the base 250MHz\nrate.\n\n```js\nrpio.i2cSetBaudRate(100000);    /* 100kHz */\nrpio.i2cSetClockDivider(2500);  /* 250MHz / 2500 = 100kHz */\n```\n\nRead from and write to the i²c slave.  Both functions take a buffer and\noptional length argument, defaulting to the length of the buffer if not\nspecified.\n\n```js\nvar txbuf = new Buffer([0x0b, 0x0e, 0x0e, 0x0f]);\nvar rxbuf = new Buffer(32);\n\nrpio.i2cWrite(txbuf);           /* Sends 4 bytes */\nrpio.i2cRead(rxbuf, 16);        /* Reads 16 bytes */\n```\n\nFinally, turn off the i²c interface and return the pins to GPIO.\n\n```js\nrpio.i2cEnd();\n```\n\n#### i²c demo\n\nThe code below writes two strings to a 16x2 LCD.\n\n```js\nvar rpio = require('rpio');\n\n/*\n * Magic numbers to initialise the i2c display device and write output,\n * cribbed from various python drivers.\n */\nvar init = new Buffer([0x03, 0x03, 0x03, 0x02, 0x28, 0x0c, 0x01, 0x06]);\nvar LCD_LINE1 = 0x80, LCD_LINE2 = 0xc0;\nvar LCD_ENABLE = 0x04, LCD_BACKLIGHT = 0x08;\n\n/*\n * Data is written 4 bits at a time with the lower 4 bits containing the mode.\n */\nfunction lcdwrite4(data)\n{\n        rpio.i2cWrite(Buffer([(data | LCD_BACKLIGHT)]));\n        rpio.i2cWrite(Buffer([(data | LCD_ENABLE | LCD_BACKLIGHT)]));\n        rpio.i2cWrite(Buffer([((data & ~LCD_ENABLE) | LCD_BACKLIGHT)]));\n}\nfunction lcdwrite(data, mode)\n{\n        lcdwrite4(mode | (data & 0xF0));\n        lcdwrite4(mode | ((data << 4) & 0xF0));\n}\n\n/*\n * Write a string to the specified LCD line.\n */\nfunction lineout(str, addr)\n{\n        lcdwrite(addr, 0);\n\n        str.split('').forEach(function (c) {\n                lcdwrite(c.charCodeAt(0), 1);\n        });\n}\n\n/*\n * We can now start the program, talking to the i2c LCD at address 0x27.\n */\nrpio.i2cBegin();\nrpio.i2cSetSlaveAddress(0x27);\nrpio.i2cSetBaudRate(10000);\n\nfor (var i = 0; i < init.length; i++)\n        lcdwrite(init[i], 0);\n\nlineout('node.js i2c LCD!', LCD_LINE1);\nlineout('npm install rpio', LCD_LINE2);\n\nrpio.i2cEnd();\n```\n\n### PWM\n\nPulse Width Modulation (PWM) allows you to create analog output from the\ndigital pins.  This can be used, for example, to make an LED appear to pulse\nrather than be fully off or on.\n\nThe Broadcom chipset supports hardware PWM, i.e. you configure it with the\nappropriate values and it will generate the required pulse.  This is much more\nefficient and accurate than emulating it in software (by setting pins high and\nlow at particular times), but you are limited to only certain pins supporting\nhardware PWM:\n\n* 26-pin models: pin 12\n* 40-pin models: pins 12, 32, 33, 35\n\nHardware PWM also requires `gpiomem: false` and root privileges.  `.open()`\nwill call `.init()` with the appropriate values if you do not explicitly call\nit yourself.\n\nTo enable a PIN for PWM, use the `rpio.PWM` argument to `open()`:\n\n```js\nrpio.open(12, rpio.PWM); /* Use pin 12 */\n```\n\nSet the PWM refresh rate with `pwmSetClockDivider()`.  This is a power-of-two\ndivisor of the base 19.2MHz rate, with a maximum value of 4096 (4.6875kHz).\n\n```js\nrpio.pwmSetClockDivider(64);    /* Set PWM refresh rate to 300kHz */\n```\n\nSet the PWM range for a pin with `pwmSetRange()`.  This determines the maximum\npulse width.\n\n```js\nrpio.pwmSetRange(12, 1024);\n```\n\nFinally, set the PWM width for a pin with `pwmSetData()`.\n\n```js\nrpio.pwmSetData(12, 512);\n```\n\n#### PWM demo\n\nThe code below pulses an LED 5 times before exiting.\n\n```js\nvar rpio = require('rpio');\n\nvar pin = 12;           /* P12/GPIO18 */\nvar range = 1024;       /* LEDs can quickly hit max brightness, so only use */\nvar max = 128;          /*   the bottom 8th of a larger scale */\nvar clockdiv = 8;       /* Clock divider (PWM refresh rate), 8 == 2.4MHz */\nvar interval = 5;       /* setInterval timer, speed of pulses */\nvar times = 5;          /* How many times to pulse before exiting */\n\n/*\n * Enable PWM on the chosen pin and set the clock and range.\n */\nrpio.open(pin, rpio.PWM);\nrpio.pwmSetClockDivider(clockdiv);\nrpio.pwmSetRange(pin, range);\n\n/*\n * Repeatedly pulse from low to high and back again until times runs out.\n */\nvar direction = 1;\nvar data = 0;\nvar pulse = setInterval(function() {\n        rpio.pwmSetData(pin, data);\n        if (data === 0) {\n                direction = 1;\n                if (times-- === 0) {\n                        clearInterval(pulse);\n                        rpio.open(pin, rpio.INPUT);\n                        return;\n                }\n        } else if (data === max) {\n                direction = -1;\n        }\n        data += direction;\n}, interval, data, direction, times);\n```\n\n### SPI\n\nSPI switches pins 19, 21, 23, 24 and 26 (GPIO7-GPIO11) to a special mode where\nyou can bulk transfer data at high speeds to and from SPI devices, with the\ncontroller handling the chip enable, clock and data in/out functions.\n\n```js\n/*\n *  Pin | Function\n * -----|----------\n *   19 |   MOSI\n *   21 |   MISO\n *   23 |   SCLK\n *   24 |   CE0\n *   26 |   CE1\n */\n```\n\nOnce SPI is enabled, the SPI pins are unavailable for GPIO use until `spiEnd()`\nis called.\n\nUse `.spiBegin()` to initiate SPI mode.  SPI requires `gpiomem: false` and root\nprivileges.  `.spiBegin()` will call `.init()` with the appropriate values if\nyou do not explicitly call it yourself.\n\n```js\nrpio.spiBegin();           /* Switch GPIO7-GPIO11 to SPI mode */\n```\n\nChoose which of the chip select / chip enable pins to control:\n\n```js\n/*\n *  Value | Pin\n *  ------|---------------------\n *    0   | SPI_CE0 (24 / GPIO8)\n *    1   | SPI_CE1 (26 / GPIO7)\n *    2   | Both\n */\nrpio.spiChipSelect(0);\n```\n\nCommonly chip enable (CE) pins are active low, and this is the default.  If\nyour device's CE pin is active high, use `spiSetCSPolarity()` to change the\npolarity.\n\n```js\nrpio.spiSetCSPolarity(0, rpio.HIGH);    /* Set CE0 high to activate */\n```\n\nSet the SPI clock speed with `spiSetClockDivider(div)`.  The `div` argument is\nan even divisor of the base 250MHz rate ranging between 0 and 65536.\n\n```js\nrpio.spiSetClockDivider(128);   /* Set SPI speed to 1.95MHz */\n```\n\nSet the SPI Data Mode:\n\n```js\n/*\n *  Mode | CPOL | CPHA\n *  -----|------|-----\n *    0  |  0   |  0\n *    1  |  0   |  1\n *    2  |  1   |  0\n *    3  |  1   |  1\n */\nrpio.spiSetDataMode(0);         /* 0 is the default */\n```\n\nOnce everything is set up we can transfer data.  Data is sent and received in\n8-bit chunks via buffers which should be the same size.\n\n```js\nvar txbuf = new Buffer([0x3, 0x0, 0xff, 0xff]);\nvar rxbuf = new Buffer(txbuf.length);\n\nrpio.spiTransfer(txbuf, rxbuf, txbuf.length);\n```\n\nIf you only need to send data and do not care about the data coming back, you\ncan use the slightly faster `spiWrite()` call:\n\n```js\nrpio.spiWrite(txbuf, txbuf.length);\n```\n\nWhen you're finished call `.spiEnd()` to release the pins back to general\npurpose use.\n\n```js\nrpio.spiEnd();\n```\n\n#### SPI demo\n\nThe code below reads the 128x8 contents of an AT93C46 serial EEPROM.\n\n```js\nvar rpio = require('rpio');\n\nrpio.spiBegin();\nrpio.spiChipSelect(0);                  /* Use CE0 */\nrpio.spiSetCSPolarity(0, rpio.HIGH);    /* AT93C46 chip select is active-high */\nrpio.spiSetClockDivider(128);           /* AT93C46 max is 2MHz, 128 == 1.95MHz */\nrpio.spiSetDataMode(0);\n\n/*\n * There are various magic numbers below.  A quick overview:\n *\n *   tx[0] is always 0x3, the EEPROM READ instruction.\n *   tx[1] is set to var i which is the EEPROM address to read from.\n *   tx[2] and tx[3] can be anything, at this point we are only interested in\n *     reading the data back from the EEPROM into our rx buffer.\n *\n * Once we have the data returned in rx, we have to do some bit shifting to\n * get the result in the format we want, as the data is not 8-bit aligned.\n */\nvar tx = new Buffer([0x3, 0x0, 0x0, 0x0]);\nvar rx = new Buffer(4);\nvar out;\nvar i, j = 0;\n\nfor (i = 0; i < 128; i++, ++j) {\n        tx[1] = i;\n        rpio.spiTransfer(tx, rx, 4);\n        out = ((rx[2] << 1) | (rx[3] >> 7));\n        process.stdout.write(out.toString(16) + ((j % 16 == 0) ? '\\n' : ' '));\n}\nrpio.spiEnd();\n```\n\n### Misc\n\nTo make code simpler a few sleep functions are supported, using the hardware\ndirectly so should be reasonably accurate.\n\n```js\nrpio.sleep(n);          /* Sleep for n seconds */\nrpio.msleep(n);         /* Sleep for n milliseconds */\nrpio.usleep(n);         /* Sleep for n microseconds */\n```\n\n## Authors And Licenses\n\nMike McCauley wrote `src/bcm2835.{c,h}` which are under the GPL.\n\nI wrote the rest, which is under the ISC license unless otherwise specified.\n","starsCount":10,"created":"2012-10-20T22:20:28.757Z","modified":"2017-06-26T01:14:34.527Z","lastPublisher":{"name":"jperkin","email":"jonathan@perkin.org.uk"},"owners":[{"name":"jperkin","email":"jonathan@perkin.org.uk"}],"other":{"_attachments":{},"_from":".","_id":"rpio","_nodeVersion":"7.10.0","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/rpio-0.9.17.tgz_1498209929096_0.3378301481716335"},"_npmUser":{"name":"jperkin","email":"jonathan@perkin.org.uk"},"_npmVersion":"2.15.11","_rev":"11-097494a3ad9b4a37badb736e35591dd0","_shasum":"f816c0950911dec6727b425f6900799af659397e","author":{"name":"Jonathan Perkin","email":"jonathan@perkin.org.uk","url":"http://www.perkin.org.uk/"},"bugs":{"url":"https://github.com/jperkin/node-rpio/issues"},"directories":{},"dist-tags":{"latest":"0.9.17"},"dist":{"shasum":"f816c0950911dec6727b425f6900799af659397e","tarball":"https://registry.npmjs.org/rpio/-/rpio-0.9.17.tgz"},"maintainers":[{"name":"jperkin","email":"jonathan@perkin.org.uk"}],"readmeFilename":"README.md","time":{"modified":"2017-06-26T01:14:34.527Z","created":"2012-10-20T22:20:28.757Z","0.0.1":"2012-10-20T22:20:30.275Z","0.0.2":"2012-10-20T22:23:28.436Z","0.0.3":"2012-10-21T19:31:17.631Z","0.0.4":"2012-10-21T20:17:13.634Z","0.0.5":"2013-05-20T17:02:32.332Z","0.0.6":"2013-05-20T17:59:22.284Z","0.0.7":"2015-03-05T21:50:17.423Z","0.0.8":"2015-03-05T23:27:26.179Z","0.0.9":"2015-03-05T23:44:57.697Z","0.0.10":"2015-03-06T11:55:36.844Z","0.1.0":"2015-03-06T14:50:13.425Z","0.1.1":"2015-03-06T14:58:25.163Z","0.1.2":"2015-03-06T23:13:55.462Z","0.2.0":"2015-03-09T21:13:49.515Z","0.2.1":"2015-03-09T21:16:30.694Z","0.2.2":"2015-03-09T21:29:55.980Z","0.2.3":"2015-03-10T09:56:42.769Z","0.3.0":"2015-03-12T13:38:06.773Z","0.3.1":"2015-03-12T13:47:01.301Z","0.4.0":"2015-03-13T19:48:20.504Z","0.4.1":"2015-03-13T20:40:25.540Z","0.4.2":"2015-03-13T20:53:27.515Z","0.4.3":"2015-03-14T19:25:23.561Z","0.4.4":"2015-04-23T10:19:31.856Z","0.4.5":"2015-12-14T17:01:03.637Z","0.5.0":"2015-12-18T11:57:15.605Z","0.5.1":"2015-12-19T09:05:32.742Z","0.6.0":"2015-12-19T20:35:28.975Z","0.6.1":"2015-12-19T22:30:52.035Z","0.6.2":"2015-12-19T22:31:52.352Z","0.6.3":"2015-12-19T22:33:12.159Z","0.6.4":"2015-12-19T23:35:28.276Z","0.6.5":"2015-12-19T23:38:15.716Z","0.6.6":"2015-12-28T22:24:56.429Z","0.7.0":"2016-01-04T23:02:35.847Z","0.8.0":"2016-01-06T10:14:19.347Z","0.8.1":"2016-01-06T10:38:31.296Z","0.8.2":"2016-01-06T10:44:16.644Z","0.8.3":"2016-01-06T10:57:30.537Z","0.8.4":"2016-01-06T11:36:32.903Z","0.8.5":"2016-01-06T11:38:55.065Z","0.8.6":"2016-01-06T11:46:41.957Z","0.8.7":"2016-01-06T12:48:51.234Z","0.8.8":"2016-01-06T12:52:20.196Z","0.8.9":"2016-01-07T16:41:41.033Z","0.8.10":"2016-01-07T18:02:45.262Z","0.8.11":"2016-01-07T18:06:33.752Z","0.9.0":"2016-01-07T23:16:44.887Z","0.9.1":"2016-01-07T23:22:17.253Z","0.9.2":"2016-01-08T11:28:54.321Z","0.9.3":"2016-01-08T11:33:39.456Z","0.9.4":"2016-01-08T16:09:02.199Z","0.9.5":"2016-01-09T19:57:45.160Z","0.9.6":"2016-01-10T19:44:50.856Z","0.9.7":"2016-01-20T11:41:11.746Z","0.9.8":"2016-02-22T08:18:28.680Z","0.9.9":"2016-02-22T09:21:46.848Z","0.9.10":"2016-03-09T10:09:18.234Z","0.9.11":"2016-04-29T11:33:15.919Z","0.9.12":"2016-08-19T08:24:58.137Z","0.9.13":"2016-12-21T08:01:47.662Z","0.9.14":"2016-12-29T14:49:14.148Z","0.9.15":"2017-01-31T19:56:15.120Z","0.9.16":"2017-03-03T22:38:25.160Z","0.9.17":"2017-06-23T09:25:30.405Z"},"users":{"fgribreau":true,"jason0518":true,"jperkin":true,"viking":true,"swak":true,"franksansc":true,"lexon":true,"shanquan":true,"gefanxe":true,"shujianbu":true}}}