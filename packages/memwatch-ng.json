{"name":"memwatch-ng","description":"Keep an eye on your memory usage, and discover and isolate leaks.","version":"1.2.0","engines":{"node":">= 0.8.0"},"repository":"https://github.com/srowatt/memwatch-ng","main":"include.js","licenses":[{"type":"wtfpl"}],"scripts":{"install":"node-gyp rebuild","test":"mocha tests --reporter spec"},"devDependencies":{"mocha":"^2.4.5","should":"^8.3.1"},"dependencies":{"bindings":"^1.2.1","nan":"^2.3.2"},"gitHead":"76b376ebca92dc69ee9ad1f6ea8e1d1a872437c7","gypfile":true,"homepage":"https://github.com/srowatt/memwatch-ng#readme","versions":[{"number":"0.3.0","date":"2016-12-09T01:47:27.127Z"},{"number":"0.4.0","date":"2016-12-09T08:00:02.917Z"},{"number":"1.0.0","date":"2016-12-09T11:56:33.295Z"},{"number":"1.1.0","date":"2016-12-11T02:12:22.317Z"},{"number":"1.2.0","date":"2016-12-12T04:14:24.388Z"}],"readme":"`memwatch-ng`: Leak Detection and Heap Diffing for Node.JS\n============================================================\n\n[![Build Status](https://travis-ci.org/srowatt/memwatch-ng.svg?branch=master)](https://travis-ci.org/srowatt/memwatch-ng)\n\n`memwatch-ng` is here to help you detect and find memory leaks in Node.JS code. `memwatch-ng` is based on the original `node-memwatch` project but adds some additional features to give you more control over how a leak is detected. \n\nIt provides:\n\n- A `leak` event, emitted when it appears your code is leaking memory.\n\n- A `stats` event, emitted occasionally, giving you\n  data describing your heap usage and trends over time.\n\n- A `HeapDiff` class that lets you compare the state of your heap between\n  two points in time, telling you what has been allocated, and what\n  has been released.\n\n`memwatch-ng` has been tested on Node.js versions: `0.10`, `0.12`, `1.x`, `2.x`, `3.x`, `4.x`, `5.x`, `6.x` and `7.x`.  \n\n\nInstallation\n------------\n\n- `npm install memwatch-ng`\n\nor\n\n- `git clone git://github.com/srowatt/memwatch-ng.git`\n\n\nDescription\n-----------\n\nThere are a growing number of tools for debugging and profiling memory\nusage in Node.JS applications, but there is still a need for a\nplatform-independent native module that requires no special\ninstrumentation.  This module attempts to satisfy that need.\n\nTo get started, import `memwatch-ng` like so:\n\n```javascript\nvar memwatch = require('memwatch-ng');\n```\n\n### Leak Detection\n\nYou can then subscribe to `leak` events.  A `leak` event will be\nemitted when your heap usage has increased for five consecutive\ngarbage collections:\n\n```javascript\nmemwatch.on('leak', function(info) { ... });\n```\n\nThe `info` object will look something like:\n\n```javascript\n{ start: Fri, 29 Jun 2012 14:12:13 GMT,\n  end: Fri, 29 Jun 2012 14:12:33 GMT,\n  growth: 67984,\n  reason: 'heap growth over 5 consecutive GCs (20s) - 11.67 mb/hr' }\n```\n\n### Leak Detection Settings\n\nBy default, leaks are defined as 5 consecutive calls to the garbage collector \nthat result in an increase of memory. To change the number of consecutive \nincreases of memory limit, call \n\n```javascript\nmemwatch.set_consecutive_growth_limit(10);\n```\n\nTo retrieve the current growth limit setting, call:\n\n```javascript\nvar growthLimit = memwatch.get_consecutive_growth_limit();\n```\n\nTwo different algorithms are used to determine leak detections. One is used for initial startup when memory is being allocated for loading modules and the other is for when Node.js is in a standard running state where memory allocations are less frequent. The `set_recent_period` method is used to set how many garbage compactions are triggered on startup before switching from the first leak detection algorithm to the second. \n\n```javascript\nmemwatch.set_recent_period(10);\n```\n\nTo retrieve the current recent period setting, call:\n\n```javascript\nvar recentPeriod = memwatch.get_recent_period();\n```\n\nThe algorithm to detect leaks uses a moving window over a period of garbage compactions with a decaying weight applied to older garbage compactions. To set the moving window period, call the `set_ancient_period` method to set the number of garbage compactions used in the moving window:\n\n```javascript\nmemwatch.set_ancient_period(120);\n```\n\nTo retrieve the current ancient period setting, call:\n\n```javascript\nvar ancientPeriod = memwatch.get_ancient_period();\n```\n\n### Heap Usage\n\nThe best way to evaluate your memory footprint is to look at heap\nusage right aver V8 performs garbage collection.  `memwatch` does\nexactly this - it checks heap usage only after GC to give you a stable\nbaseline of your actual memory usage.\n\nWhen V8 performs a garbage collection (technically, we're talking\nabout a full GC with heap compaction), `memwatch` will emit a `stats`\nevent.\n\n```javascript\nmemwatch.on('stats', function(stats) { ... });\n```\n\nThe `stats` data will look something like this:\n\n```javascript\n{\n  \"num_full_gc\": 17,\n  \"num_inc_gc\": 8,\n  \"heap_compactions\": 8,\n  \"estimated_base\": 2592568,\n  \"current_base\": 2592568,\n  \"min\": 2499912,\n  \"max\": 2592568,\n  \"usage_trend\": 0\n}\n```\n\n`estimated_base` and `usage_trend` are tracked over time.  If usage\ntrend is consistently positive, it indicates that your base heap size\nis continuously growing and you might have a leak.\n\nV8 has its own idea of when it's best to perform a GC, and under a\nheavy load, it may defer this action for some time.  To aid in\nspeedier debugging, `memwatch` provides a `gc()` method to force V8 to\ndo a full GC and heap compaction.\n\nThe `min` and `max` stats report the most extreme values we've seen for base \nheap size and are only recorded after the first 3 GC's, by default. This\ncan be changed by calling:\n\n```javascript\nmemwatch.set_extremes_period(10);\n```\n\n### Heap Diffing\n\nSo far we have seen how `memwatch` can aid in leak detection.  For\nleak isolation, it provides a `HeapDiff` class that takes two snapshots\nand computes a diff between them.  For example:\n\n```javascript\n// Take first snapshot\nvar hd = new memwatch.HeapDiff();\n\n// do some things ...\n\n// Take the second snapshot and compute the diff\nvar diff = hd.end();\n```\n\nThe contents of `diff` will look something like:\n\n```javascript\n{\n  \"before\": { \"nodes\": 11625, \"size_bytes\": 1869904, \"size\": \"1.78 mb\" },\n  \"after\":  { \"nodes\": 21435, \"size_bytes\": 2119136, \"size\": \"2.02 mb\" },\n  \"change\": { \"size_bytes\": 249232, \"size\": \"243.39 kb\", \"freed_nodes\": 197,\n    \"allocated_nodes\": 10007,\n    \"details\": [\n      { \"what\": \"String\",\n        \"size_bytes\": -2120,  \"size\": \"-2.07 kb\",  \"+\": 3,    \"-\": 62\n      },\n      { \"what\": \"Array\",\n        \"size_bytes\": 66687,  \"size\": \"65.13 kb\",  \"+\": 4,    \"-\": 78\n      },\n      { \"what\": \"LeakingClass\",\n        \"size_bytes\": 239952, \"size\": \"234.33 kb\", \"+\": 9998, \"-\": 0\n      }\n    ]\n  }\n}\n```\n\nThe diff shows that during the sample period, the total number of\nallocated `String` and `Array` classes decreased, but `Leaking Class`\ngrew by 9998 allocations.  Hmmm.\n\nYou can use `HeapDiff` in your `on('stats')` callback; even though it\ntakes a memory snapshot, which triggers a V8 GC, it will not trigger\nthe `stats` event itself.  Because that would be silly.\n\n\nFuture Work\n-----------\n\nPlease see the Issues to share suggestions and contribute!\n\n\nLicense\n-------\n\nhttp://wtfpl.net\n","created":"2016-12-09T01:47:27.127Z","modified":"2016-12-12T04:14:24.388Z","lastPublisher":{"name":"srowatt","email":"rowatt@optusnet.com.au"},"owners":[{"name":"srowatt","email":"rowatt@optusnet.com.au"}],"other":{"_attachments":{},"_from":".","_id":"memwatch-ng","_nodeVersion":"5.12.0","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/memwatch-ng-1.2.0.tgz_1481516064149_0.04626028495840728"},"_npmUser":{"name":"srowatt","email":"rowatt@optusnet.com.au"},"_npmVersion":"3.8.6","_rev":"7-3e65815982142f0f94528f7b9744237c","_shasum":"b5a457a7c46b1db813b45a11ccfe09e8bd7fccfa","author":{"name":"Shane Rowatt","url":"http://www.shanerowatt.com"},"bugs":{"url":"https://github.com/srowatt/memwatch-ng/issues"},"contributors":[{"name":"Shane Rowatt","url":"@srowatt"}],"directories":{},"dist-tags":{"latest":"1.2.0"},"dist":{"shasum":"b5a457a7c46b1db813b45a11ccfe09e8bd7fccfa","tarball":"http://registry.npmjs.org/memwatch-ng/-/memwatch-ng-1.2.0.tgz"},"maintainers":[{"name":"srowatt","email":"rowatt@optusnet.com.au"}],"readmeFilename":"README.md","time":{"modified":"2016-12-12T04:14:24.388Z","created":"2016-12-09T01:47:27.127Z","0.3.0":"2016-12-09T01:47:27.127Z","0.4.0":"2016-12-09T08:00:02.917Z","1.0.0":"2016-12-09T11:56:33.295Z","1.1.0":"2016-12-11T02:12:22.317Z","1.2.0":"2016-12-12T04:14:24.388Z"}}}