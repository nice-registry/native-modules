{"name":"marisa-trie","version":"1.0.1","description":"A wrapper of MARISA library.","license":"ISC","os":["darwin","linux","win32"],"engines":{"node":">=0.8.0"},"main":"index.js","scripts":{"rebuild":"node-gyp rebuild","build":"node-gyp build","clean":"node-gyp clean","benchmark":"node benchmark/index.js","test":"mocha --reporter spec --bail","install":"node-gyp rebuild"},"files":["LICENSE","README.md","binding.gyp","index.js","src"],"keywords":["dictionary","libmarisa","marisa-trie","trie","bindings","wrapper","iojs"],"dependencies":{"nan":"~2.1.0"},"devDependencies":{"cli-table":"~0.3.1","mocha":"~2.3.3","should":"~7.1.1","temp-fs":"~0.9.0"},"repository":"https://github.com/jakwings/iojs-marisa-trie","homepage":"https://github.com/jakwings/iojs-marisa-trie","gypfile":true,"gitHead":"4c402188f3b69979c06819e38f7fdc8669b5dacd","versions":[{"number":"1.0.0","date":"2015-11-12T00:37:27.326Z"},{"number":"1.0.1","date":"2015-11-13T06:39:22.885Z"}],"readme":"# marisa-trie\n\n[![Build Status](https://travis-ci.org/jakwings/iojs-marisa-trie.svg)](https://travis-ci.org/jakwings/iojs-marisa-trie)\n[![NPM version](https://badge.fury.io/js/marisa-trie.svg)](http://badge.fury.io/js/marisa-trie)\n\nThis package provides a wrapper (a set of bindings) of [MARISA-Trie].\n\nNode requirements:\n\n*   Version >= 0.11.14 or Version == 0.10.x or Version == 0.8.x\n\n[MARISA-Trie]: https://code.google.com/p/marisa-trie/\n\n\n## Installation\n\n```bash\nnpm install marisa-trie\n```\n\nIf installation failed, try to update npm via `npm install -g npm` and [update\nnode-gyp bundled with npm].\n\n[update node-gyp bundled with npm]:\nhttps://github.com/TooTallNate/node-gyp/wiki/Updating-npm's-bundled-node-gyp\n\n\n## Usage\n\nThe APIs are almost the same as the C++ library's. For example:\n\n```javascript\nvar Marisa = require('marisa-trie');\n\nvar keyset = new Marisa.Keyset();  // The keyword \"new\" is optional.\nkeyset.push_back('a');\nkeyset.push_back('app');\nkeyset.push_back('apple');\n\nvar trie = new Marisa.Trie();\ntrie.build(keyset);\n\nvar agent = new Marisa.Agent();\nagent.set_query('apple');\nwhile (trie.common_prefix_search(agent)) {\n    var key = agent.key();\n    console.log(key.id(), key.ptr());\n}\n/* OUTPUT:\n * 0 'a'\n * 1 'app'\n * 2 'apple'\n */\n```\n\n\n## APIs\n\nFor detailed information, please see the [official site].\n\n[official site]: http://marisa-trie.googlecode.com/svn/trunk/docs/readme.en.html\n\n### Marisa.Trie\n\n```cpp\nclass Trie {\n public:\n  Trie();\n\n  void build(Keyset &keyset, int config_flags = 0);\n\n  void mmap(const char *filename);\n  void map(const void *ptr, std::size_t size);\n\n  void load(const char *filename);\n  void read(int fd);\n\n  void save(const char *filename) const;\n  void write(int fd) const;\n\n  bool lookup(Agent &agent) const;\n  void reverse_lookup(Agent &agent) const;\n  bool common_prefix_search(Agent &agent) const;\n  bool predictive_search(Agent &agent) const;\n\n  std::size_t num_tries() const;\n  std::size_t num_keys() const;\n  std::size_t num_nodes() const;\n\n  TailMode tail_mode() const;\n  NodeOrder node_order() const;\n\n  bool empty() const;\n  std::size_t size() const;\n  std::size_t io_size() const;\n\n  void clear();\n  void swap(Trie &rhs);\n};\n```\n\n*   `build(keyset:Keyset [, flag:Number])`\n\n    Initialize the trie with a keyset.\n\n*   `mmap(filepath:String)`\n\n    Map a file of trie data into memory and build the trie with it.\n\n*   `map(buffer:Buffer [, length:Number])`\n\n    Map a UTF8-encoded string buffer into memory and build the trie with it.\n    If `length` is specified, only load the first `length` bytes of the buffer.\n\n*   `load(filepath:String)`\n\n    Load trie data from a file and build the trie.\n\n*   `read(fd:Number)`\n\n    Read trie data from a ReadStream and build the trie. `fd` is an integer\n    file descriptor.\n\n*   `save(filepath:String)`\n\n    Dump the trie data into a file.\n\n*   `write(fd:Number)`\n\n    Dump the trie data into a WriteStream. `fd` is an integer file descriptor'.\n\n*   `empty(): Boolean`\n\n    Check whether the trie has no keys.\n\n*   `size(): Number`\n\n    Return the number of keys. It is the same as `num_keys()`.\n\n*   `io_size(): Number`\n\n    Return the size of trie data in byte.\n\n*   `lookup(agent:Agent): Boolean`\n\n    Check whether the key `agent.query().ptr()` is registered. If it is\n    registered, return `true`, otherwise `false`. The search result is available\n    through `agent.key()` and `agent.key().ptr()` should be equal to\n    `agent.query().ptr()`.\n\n*   `reverse_lookup(agent:Agent)`\n\n    Restore a key with its ID `agent.query().id()`. The result is\n    `agent.key().ptr()`. This method will throw an error if the ID is out of range.\n\n*   `common_prefix_search(agent:Agent): Boolean`\n\n    Search keys with the possible prefixes of the query string\n    `agent.query().ptr()`. If any matching key is found, return true. The first key\n    is available through `agent.key()`. The next match will be available after the\n    next `common_prefix_search()`.\n\n*   `predictive_search(agent:Agent): Boolean`\n\n    Search keys started with the query string `agent.query().ptr()`. And\n    Similar to `common_prefix_search()`, it will return true until there are no\n    more matching keys. **There is one difference from the C++ version**:\n    `agent.key().length()` is equal to `Buffer.byteLength(agent.key().ptr())`.\n\nNote: An agent keeps the internal state of `common_prefix_search()` and\n`predictive_search()` until it is passed to another search function or\n`agent.set_query()` is called.\n\n### Marisa.Keyset\n\n```cpp\nclass Keyset {\n public:\n  Keyset();\n\n  void push_back(const Key &key);\n  //void push_back(const Key &key, char end_marker);\n\n  void push_back(const char *str);\n  void push_back(const char *ptr, std::size_t length, float weight = 1.0);\n\n  const Key &operator[](std::size_t i) const;\n  Key &operator[](std::size_t i);\n\n  std::size_t num_keys();\n\n  bool empty() const;\n  std::size_t size() const;\n  std::size_t total_length() const;\n\n  void reset();\n\n  void clear();\n  void swap(Keyset &rhs);\n};\n```\n\n*   `[index]: Key`\n\n    Access the key at the index. Return `undefined` if the index is out of\n    range.\n\n*   `push_back(key:Key)`\n\n    Add one key to the key set.\n\n*   `push_back(string:String [, length:Number [, weight:Number]])`\n\n    Add one key to the key set. If `length` is specified, only read the first\n    `length` bytes from the string. And `weight` can be used as the frequency\n    of the key to help optimize the searching performance optionally.  Weights\n    will be accumulated for the same keys. After building the trie, weights\n    will be overwritten by key IDs because every key uses a union to store\n    a weight or an ID.\n\n    If the key string contains NUL (0x00) characters, please specify the length\n    explicitly so as to keep the NULs.\n\n*   `empty(): Boolean`\n\n    Check whether the key set has no keys.\n\n*   `size(): Number`\n\n    Return the number of keys. It is the same as `num_keys()`.\n\n*   `total_length(): Number`\n\n    Return the total length of all keys in byte.\n\n### Marisa.Agent\n\n```cpp\nclass Agent {\n public:\n  Agent();\n\n  const Query &query() const;\n  const Key &key() const;\n\n  void set_query(const char *str);\n  void set_query(const char *ptr, std::size_t length);\n  void set_query(std::size_t key_id);\n};\n```\n\n*   `query(): Query`\n\n    Return the query information.\n\n*   `key(): Key`\n\n    Return the search result.\n\n*   `set_query(string:String [, length:Number])`\n\n    Set the query string. If `length` is specified, read only the first\n    `length` bytes from the string.\n\n    If the query string contains NUL (0x00) characters, please specify the\n    length explicitly so as to keep the NULs.\n\n*   `set_query(id:Number)`\n\n    Set the ID of key to restore.\n\n### Marisa.Query\n\n```cpp\nclass Query {\n public:\n  char operator[](std::size_t i) const;\n  const char *ptr() const;\n  std::size_t length() const;\n  std::size_t id() const;\n};\n```\n\n*   `[index]: Number`\n\n    Access the UTF-8 unit at the index. Return `undefined` if the index is out\n    of range.\n\n*   `ptr(): String`\n\n    Return the query string.\n\n*   `length(): Number`\n\n    Return the byte-length of the query string.\n\n*   `id(): Number`\n\n    Return the ID of the key to restore.\n\n### Marisa.Key\n\n```cpp\nclass Key {\n public:\n  char operator[](std::size_t i) const;\n  const char *ptr() const;\n  std::size_t length() const;\n  std::size_t id() const;\n};\n```\n\n*   `[index]: Number`\n\n    Access the UTF-8 unit at the index. Return `undefined` if the index is out\n    of range.\n\n*   `ptr(): String`\n\n    Return the last result of the query as a string.\n\n*   `length(): Number`\n\n    Return the byte-length of the result string.\n\n*   `id(): Number`\n\n    Return the ID of the key.\n\n### Enumerations\n\n```cpp\ntypedef enum marisa_num_tries_ {\n  MARISA_MIN_NUM_TRIES     = 0x00001,\n  MARISA_MAX_NUM_TRIES     = 0x0007F,\n  MARISA_DEFAULT_NUM_TRIES = 0x00003,\n} marisa_num_tries;\n```\n\n*   `Marisa.MIN_NUM_TRIES`\n*   `Marisa.MAX_NUM_TRIES`\n*   `Marisa.DEFAULT_NUM_TRIES`\n\n```cpp\ntypedef enum marisa_cache_level_ {\n  MARISA_HUGE_CACHE    = 0x00080,\n  MARISA_LARGE_CACHE   = 0x00100,\n  MARISA_NORMAL_CACHE  = 0x00200,\n  MARISA_SMALL_CACHE   = 0x00400,\n  MARISA_TINY_CACHE    = 0x00800,\n  MARISA_DEFAULT_CACHE = MARISA_NORMAL_CACHE\n} marisa_cache_level;\n```\n\n*   `Marisa.HUGE_CACHE`\n*   `Marisa.LARGE_CACHE`\n*   `Marisa.NORMAL_CACHE`\n*   `Marisa.SMALL_CACHE`\n*   `Marisa.TINY_CACHE`\n*   `Marisa.DEFAULT_CACHE`\n\n```cpp\ntypedef enum marisa_tail_mode_ {\n  MARISA_TEXT_TAIL    = 0x01000,\n  MARISA_BINARY_TAIL  = 0x02000,\n  MARISA_DEFAULT_TAIL = MARISA_TEXT_TAIL,\n} marisa_tail_mode;\n```\n\n*   `Marisa.TEXT_TAIL`\n*   `Marisa.BINARY_TAIL`\n*   `Marisa.DEFAULT_TAIL`\n\n```cpp\ntypedef enum marisa_node_order_ {\n  MARISA_LABEL_ORDER   = 0x10000,\n  MARISA_WEIGHT_ORDER  = 0x20000,\n  MARISA_DEFAULT_ORDER = MARISA_WEIGHT_ORDER,\n} marisa_node_order;\n```\n\n*   `Marisa.LABEL_ORDER`\n*   `Marisa.WEIGHT_ORDER`\n*   `Marisa.DEFAULT_ORDER`\n\n```cpp\ntypedef enum marisa_config_mask_ {\n  MARISA_NUM_TRIES_MASK    = 0x0007F,\n  MARISA_CACHE_LEVEL_MASK  = 0x00F80,\n  MARISA_TAIL_MODE_MASK    = 0x0F000,\n  MARISA_NODE_ORDER_MASK   = 0xF0000,\n  MARISA_CONFIG_MASK       = 0xFFFFF\n} marisa_config_mask;\n```\n\n*   `Marisa.NUM_TRIES_MASK`\n*   `Marisa.CACHE_LEVEL_MASK`\n*   `Marisa.TAIL_MODE_MASK`\n*   `Marisa.NODE_ORDER_MASK`\n*   `Marisa.CONFIG_MASK`\n\n\n## Benchmarks\n\nNode v0.10.40 on my Macbook i5 2.4Ghz (Your mileage may vary.):\n\n```\n METHOD               | TIME (ms/r) | SPEED (K/s) | SPEED (ns/key) | SIZE (N) | IO_SIZE (bytes) | ROUNDS (N)\n build                | 412.37      | 863.35      | 1158.28        | 356017   | 1301528         | 10\n lookup               | 284.85      | 1249.86     | 800.09         | 356017   | 1301528         | 10\n reverse_lookup       | 198.15      | 1796.67     | 556.59         | 356017   | 1301528         | 10\n common_prefix_search | 347.49      | 1024.53     | 976.05         | 356017   | 1301528         | 10\n predictive_search    | 379.03      | 939.29      | 1064.64        | 356017   | 1301528         | 10\n```\n\n> K/s – thousand keys per second\n\nNormally, the speed of `reverse_lookup` should be the highest.\n\nTravis CI Results: <https://travis-ci.org/jakwings/iojs-marisa-trie>\n\n\n## License\n\nThe wrapper code is licensed under ISC License.\n\nThe bundled source code of [MARISA-Trie] is dual-licensed under LGPL-2.1+ and BSD-2-Clause license.\n","created":"2015-11-12T00:37:27.326Z","modified":"2015-11-13T06:39:22.885Z","lastPublisher":{"name":"jakwings","email":"jakwings@gmail.com"},"owners":[{"name":"jakwings","email":"jakwings@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"marisa-trie","_nodeVersion":"5.0.0","_npmUser":{"name":"jakwings","email":"jakwings@gmail.com"},"_npmVersion":"3.3.6","_rev":"1-0c54acf561e1da1324cd8de76d496b58","_shasum":"949382dd5d8f6f4da1ecdf2b7622d86cbf75fb45","author":{"name":"Jak Wings","email":"jakwings@gmail.com"},"bugs":{"url":"https://github.com/jakwings/iojs-marisa-trie/issues"},"directories":{},"dist-tags":{"latest":"1.0.1"},"dist":{"shasum":"949382dd5d8f6f4da1ecdf2b7622d86cbf75fb45","tarball":"http://registry.npmjs.org/marisa-trie/-/marisa-trie-1.0.1.tgz"},"maintainers":[{"name":"jakwings","email":"jakwings@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2015-11-13T06:39:22.885Z","created":"2015-11-12T00:37:27.326Z","1.0.0":"2015-11-12T00:37:27.326Z","1.0.1":"2015-11-13T06:39:22.885Z"}}}