{"name":"cpp-eventemitter","version":"1.0.0","description":"A Native Nan version of EventEmitter that allows C++ and wrapped C to emit to javascript listeners as events happen.","main":"include_dirs.js","scripts":{"test":"eslint . && cd test && make clean && make alltests","jstests":"cd test && node-gyp configure && node-gyp rebuild && mocha ./js/*.js","lint":"eslint ."},"keywords":["nan","native","c++","cpp","cplusplus","eventemitter","event","emitter"],"license":"MIT","devDependencies":{"@scoop/eslint-config-scoop":"^3.1.0","catch":"^1.0.48","code":"^4.1.0","eslint":"^3.19.0","eslint-plugin-dependencies":"^2.4.0","mocha":"^3.4.2","node-gyp":"^3.6.2","path":"^0.12.7"},"dependencies":{"bindings":"^1.2.1","nan":"^2.6.2"},"gitHead":"2350405a533c84165c937f01aa85bc64578f8895","versions":[{"number":"1.0.0","date":"2017-07-18T01:26:32.155Z"}],"readme":"Node.js native EventEmitter. Allows you to implement Native C++ code that\nbehaves like an EventEmitter. Users of your native module will be able to write\ncode like \n\n```javascript\nfoo = new YourNativeExtension();\nfoo.on(\"some event\", function(value) {\n\tconsole.log(value);\n})\n```\n\nAnd inside your native code, you will be able to emit events as they happen,\nwhich will trigger the appropriate callbacks in javascript. The emit occurs in\na separate thread from your AsyncWorker, and so will not appreciably block the\nwork being done.\n\nExamples of using The EventEmitter, the first is the non-reentrant\nnon-threadsafe version, the second is the threadsafe and reentrant, but\nrequires you pass the emitter object around\n\n```c++\n\nclass TestWorker : public AsyncEventEmittingCWorker<1024> {\n public:\n    TestWorker(Nan::Callback* callback, std::shared_ptr<EventEmitter> emitter, size_t n)\n        : AsyncEventEmittingCWorker(callback, emitter), n_(n) {}\n\n    virtual void ExecuteWithEmitter(eventemitter_fn emitter) override {\n        for (int32_t i = 0; i < n_; ++i) {\n            stringstream ss;\n            ss << \"Test\" << i;\n            emitter(\"test\", ss.str().c_str());\n            emitter(\"test2\", ss.str().c_str());\n            emitter(\"test3\", ss.str().c_str());\n        }\n    }\n\n private:\n    int32_t n_;\n};\n\nclass TestReentrantWorker : public AsyncEventEmittingReentrantCWorker<1024> {\n public:\n    TestReentrantWorker(Nan::Callback* callback, std::shared_ptr<EventEmitter> emitter, size_t n)\n        : AsyncEventEmittingReentrantCWorker(callback, emitter), n_(n) {}\n\n    virtual void ExecuteWithEmitter(const ExecutionProgressSender* sender, eventemitter_fn_r emitter) override {\n        for (int32_t i = 0; i < n_; ++i) {\n            stringstream ss;\n            ss << \"Test\" << i;\n            emitter((void*)sender, \"test\", ss.str().c_str());\n            emitter((void*)sender, \"test2\", ss.str().c_str());\n            emitter((void*)sender, \"test3\", ss.str().c_str());\n        }\n    }\n\n private:\n    int32_t n_;\n};\n```\n\nAnd then for the object that behaves like an EventEmitter, you add the 'on'\nmethod to register callbacks on events, and have some sort of \"run\" methods\nthat do asynchronous work\n\n```c++\n\nclass EmittingThing : public Nan::ObjectWrap {\n public:\n    static NAN_MODULE_INIT(Init) {\n        auto clsName = Nan::New(\"EmitterThing\").ToLocalChecked();\n        auto constructor = Nan::New<v8::FunctionTemplate>(New);\n        auto tpl = constructor->InstanceTemplate();\n        constructor->SetClassName(clsName);\n        tpl->SetInternalFieldCount(1);\n\n        Nan::SetPrototypeMethod(constructor, \"on\", On);\n        Nan::SetPrototypeMethod(constructor, \"run\", Run);\n        Nan::SetPrototypeMethod(constructor, \"runReentrant\", RunReentrant);\n\n        Nan::Set(target, clsName, Nan::GetFunction(constructor).ToLocalChecked());\n    };\n\n private:\n    EmittingThing() : emitter_(std::make_shared<EventEmitter>()) {}\n    static NAN_METHOD(On) {\n        if (info.Length() != 2) {\n            info.GetIsolate()->ThrowException(Nan::TypeError(\"Wrong number of arguments\"));\n            return;\n        }\n        if (!info[0]->IsString()) {\n            info.GetIsolate()->ThrowException(Nan::TypeError(\"First argument must be string\"));\n            return;\n        }\n        if (!info[1]->IsFunction()) {\n            info.GetIsolate()->ThrowException(Nan::TypeError(\"Second argument must be function\"));\n            return;\n        }\n\n        auto s = std::string(*v8::String::Utf8Value(info[0]->ToString()));\n        Nan::Callback* callback = new Nan::Callback(info[1].As<Function>());\n\n        auto thing = Nan::ObjectWrap::Unwrap<EmittingThing>(info.Holder());\n        thing->emitter_->on(s, callback);\n    }\n\n    static NAN_METHOD(Run) {\n        if (info.Length() != 1) {\n            info.GetIsolate()->ThrowException(Nan::TypeError(\"Wrong number of arguments\"));\n            return;\n        }\n        if (!info[0]->IsNumber()) {\n            info.GetIsolate()->ThrowException(Nan::TypeError(\"First argument must be number\"));\n            return;\n        }\n\n        int32_t n = info[0]->Int32Value();\n        auto thing = Nan::ObjectWrap::Unwrap<EmittingThing>(info.Holder());\n\n        TestWorker* worker = new TestWorker(nullptr, thing->emitter_, n);\n        Nan::AsyncQueueWorker(worker);\n    }\n\n    static NAN_METHOD(RunReentrant) {\n        if (info.Length() != 1) {\n            info.GetIsolate()->ThrowException(Nan::TypeError(\"Wrong number of arguments\"));\n            return;\n        }\n        if (!info[0]->IsNumber()) {\n            info.GetIsolate()->ThrowException(Nan::TypeError(\"First argument must be number\"));\n            return;\n        }\n\n        int32_t n = info[0]->Int32Value();\n        auto thing = Nan::ObjectWrap::Unwrap<EmittingThing>(info.Holder());\n\n        TestReentrantWorker* worker = new TestReentrantWorker(nullptr, thing->emitter_, n);\n        Nan::AsyncQueueWorker(worker);\n    }\n\n    static NAN_METHOD(New) {\n        if (!info.IsConstructCall()) {\n            info.GetIsolate()->ThrowException(Nan::TypeError(\"call to constructor without keyword new\"));\n            return;\n        }\n\n        EmittingThing* o = new EmittingThing();\n        o->Wrap(info.This());\n        info.GetReturnValue().Set(info.This());\n    }\n\n    std::shared_ptr<NodeEvent::EventEmitter> emitter_;\n};\n\nNAN_MODULE_INIT(InitAll) { EmittingThing::Init(target); }\nNODE_MODULE(NanObject, InitAll);\n\n```\n\nBy default, this module uses a multiple-producer, multiple-consumer ringbuffer\nusing a mutex for synchronization. With EventEmitter, there can really only\never be a single consumer, and that's the thread running the main loop; however\nthere could be multiple producers. *IF* you can guarantee that you will only\never have a single producer thread emitting at a time via some external\nsynchronization method, and you have boost available, you can define\n\"HAVE_BOOST\" to enable the use of boost::lockfree::spsc_queue, which will\nprovide much lower latency, which could be particularly important in your\nworker thread if emitting occurs at a high rate. As an example of where you\nmight benefit from this, if you have an object which has a single emitter per\ninstance, and you only permit a single asynchronous method to be invoked on\nthat instance at any one time, then you can safely use the higher-performing\nboost::lockfree::spsc_queue \n\n","created":"2017-07-18T01:26:32.155Z","modified":"2017-07-18T01:26:32.155Z","lastPublisher":{"name":"scoop-ops","email":"scott@takescoop.com"},"owners":[{"name":"scoop-ops","email":"scott@takescoop.com"}],"other":{"_attachments":{},"_from":".","_id":"cpp-eventemitter","_nodeVersion":"5.12.0","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/cpp-eventemitter-1.0.0.tgz_1500341192059_0.41831914614886045"},"_npmUser":{"name":"scoop-ops","email":"scott@takescoop.com"},"_npmVersion":"3.8.6","_rev":"1-43614991e9811c5fe7c8fa85178ca35b","_shasum":"ca25ad68e49667e03dd45496e1ef405f31aabe3d","author":{"name":"Jamie Beverly"},"directories":{},"dist-tags":{"latest":"1.0.0"},"dist":{"shasum":"ca25ad68e49667e03dd45496e1ef405f31aabe3d","tarball":"https://registry.npmjs.org/cpp-eventemitter/-/cpp-eventemitter-1.0.0.tgz"},"maintainers":[{"name":"scoop-ops","email":"scott@takescoop.com"}],"readmeFilename":"README.md","time":{"modified":"2017-07-18T01:26:32.155Z","created":"2017-07-18T01:26:32.155Z","1.0.0":"2017-07-18T01:26:32.155Z"}}}