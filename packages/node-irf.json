{"name":"node-irf","version":"0.2.3","keywords":["incremental","random","forest","machine","learning","c++","native","sparse","classifier","ensemble","supervised"],"homepage":"https://github.com/yjhjstz","description":"incremental random forest ensemble classifier (native)","main":"./index.js","repository":"https://github.com/yjhjstz/node-irf","engines":{"node":">=0.6.0"},"dependencies":{"nan":"2.4.0"},"devDependencies":{"carrier":"0.1.7"},"licenses":[{"type":"MIT","url":"http://www.opensource.org/licenses/MIT"}],"scripts":{"test":"cd ./tests && node mushrooms.js","install":"node-gyp rebuild"},"gypfile":true,"gitHead":"debe77838677422cfd9b0b55cbe6fe6a090a8616","versions":[{"number":"0.2.0","date":"2016-07-21T02:55:30.205Z"},{"number":"0.2.1","date":"2016-07-26T09:22:39.941Z"},{"number":"0.2.2","date":"2016-07-26T10:01:58.552Z"},{"number":"0.2.3","date":"2016-07-26T10:44:13.439Z"}],"readme":"Incremental Random Forest\n=========================\n\n[![Build Status](https://secure.travis-ci.org/pconstr/irf.png)](http://travis-ci.org/pconstr/irf)\n\nAn implementation in C++ (with [node.js](http://nodejs.org) and Python bindings) of a variant of [Leo Breiman's Random Forests](http://stat-www.berkeley.edu/users/breiman/RandomForests/cc_home.htm)\n\nThe forest is maintained incrementally as samples are added or removed - rather than fully rebuilt from scratch every time - to save effort.\n\nIt is not a streaming implementation, all the samples are stored and will be reseen when required to recursively rebuild invalidated subtrees. The effort to update each individual tree can vary substantially but the overall effort to update the forest is averaged across the trees so tends not to vary so much.\n\nIRF is licensed under the MIT license.\n\nFeatures and limitations\n------------------------\n\n* Sparse feature vectors\n* Samples can be added, removed and changed\n* Learning can be performed lazily or initiated explicitly\n* The forest can be serialized to JSON for transmission/storage\n* The forest needs to fit fully in RAM, performance suffers dramatically when swapping\n* Currently only binary classification - 0 or 1. The classifier estimates the probability of belonging to class 1, as a float from 0 to 1\n* Currently only binary features: y >= 0.5 is considered 1, otherwise 0\n\nNode.js setup\n-----\n`npm install node-irf`\n\nNode.js usage\n-------------\n\n```javascript\nvar irf = require('node-irf');\n\nvar f = new irf.IRF(99); // create forest of 99 trees\n\nf.add('1', {1:1, 3:1, 5:1}, 0); // add a sample identified as '1' with the given feature values, classified as 0\nf.add('2', {1:0, 3:0, 4:1}, 0); // features are stored sparsely, when a value is not given it will be taken as 0\nf.add('3', {2:0, 3:0, 5:0}, 0); // but 0s can also be given explicitly\n// ...\n\nvar y = f.classify({1:1, 3:1, 5:1}); // classify feature vector\n                                     // the forest will be lazily updated before classification\nf.commit();                          // but you can force an update at any time\n                                     // you get a probability estimate from 0 to 1 for belong to class 1\nvar c = Math.round(y);               // round to nearest to get class (0 or 1)\n\nf.remove('8'); // remove a sample\nf.add('8', {1:0, 2:0, 3:0, 4:0, 5:1}, 0); // and add it again with new values\n\nconsole.log(f.asJSON()); // serialize to json (for classification, not suitable for incremental update)\n\nf.each(function(suid, features, y) {\n    // ...\n});\n\nvar b = f.toBuffer();    // serialize (complete) to buffer\nvar f2 = new irf.IRF(b); // construct from buffer contents\n```\n\nPython setup\n-----\n    cd irf\n    python setup.py install\n\nPython usage\n------------\n\n```python\nimport irf\n\nf = irf.IRF(99) # create forest of 99 trees\n\nf.add('1', {1:1, 3:1, 5:1}, 0) # add a sample identified as '1' with the given feature values, classified as 0\nf.add('2', {1:0, 3:0, 4:1}, 0) # features are stored sparsely, when a value is not given it will be taken as 0\nf.add('3', {2:0, 3:0, 5:0}, 0) # but 0s can also be given explicitly\n# ...\n\ny = f.classify({1:1, 2:1, 5:1}); print y, int(round(y)) # classify feature vector, round to nearest to get class\n\nf.save('simple.rf') # save forest to file\n\nf = irf.load('simple.rf') # load forest from file\n\nf.remove('8') # remove a sample\nf.add('8', {1:0, 2:0, 3:0, 4:0, 5:1}, 0) # and add it again with new values\n\ny = f.classify({1:1, 2:1, 5:1}); print y, int(round(y)) # the forest will be lazily updated before classification\n# f.commit() # but you can force it\n\nfor (sId, x, y) in f.samples(): # iterate through samples in the forest, in lexicographic ID order\n    print sId, x, y # and print them\n```\n\nC++ usage\n---------\n\n_to be written_\n\nDependencies\n------------\n\nSystem:\n\n* STL\n\nIncluded:\n\n* MurmurHash3 (from [smhasher](http://code.google.com/p/smhasher/))\n\n\n\nTests\n-----\n\n* simple.py - trivial made up data to illustrate how to use the API\n* mushrooms.js, mushrooms.py - using the [mushrooms dataset](http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary.html#mushrooms) collected by [LIBSVM](http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/) from the [UCI Machine Learning Repository](http://archive.ics.uci.edu/ml/)\n","starsCount":1,"created":"2016-07-21T02:55:30.205Z","modified":"2016-07-26T10:44:13.439Z","lastPublisher":{"name":"yjhjstz","email":"yjhjstz@gmail.com"},"owners":[{"name":"yjhjstz","email":"yjhjstz@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"node-irf","_nodeVersion":"4.4.3","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/node-irf-0.2.3.tgz_1469529851461_0.7073384479153901"},"_npmUser":{"name":"yjhjstz","email":"yjhjstz@gmail.com"},"_npmVersion":"2.15.1","_rev":"1-62532772bf3bfcca8a5ded1a3e8ea406","_shasum":"87c24214153af3fa663222e3941a1e0413d77a23","author":{"name":"Carlos Guerreiro","email":"carlos@perceptiveconstructs.com"},"bugs":{"url":"https://github.com/yjhjstz/node-irf"},"contributors":[{"name":"Jianghua Yang","email":"yjhjstz@gmail.com","url":"https://alinode.aliyun.com"},{"name":"Carlos Guerreiro","email":"cguerreiro@igalia.com","url":"http://igalia.com"}],"directories":{},"dist-tags":{"latest":"0.2.3"},"dist":{"shasum":"87c24214153af3fa663222e3941a1e0413d77a23","tarball":"http://registry.npmjs.org/node-irf/-/node-irf-0.2.3.tgz"},"maintainers":[{"name":"yjhjstz","email":"yjhjstz@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2016-07-26T10:44:13.439Z","created":"2016-07-21T02:55:30.205Z","0.2.0":"2016-07-21T02:55:30.205Z","0.2.1":"2016-07-26T09:22:39.941Z","0.2.2":"2016-07-26T10:01:58.552Z","0.2.3":"2016-07-26T10:44:13.439Z"},"users":{"yjhjstz":true}}}