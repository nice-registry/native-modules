{"name":"petard","version":"0.0.7-b","description":"a js llvm library","main":"index.js","scripts":{"clean":"make clean","build":"make","preinstall":"make libpetard","test":"make test"},"repository":"https://github.com/couchand/petard","keywords":["LLVM"],"license":"MIT","homepage":"https://github.com/couchand/petard#readme","dependencies":{"bindings":"^1.2.1","ffi":"^2.0.0","nan":"^2.1.0"},"devDependencies":{"chai":"^3.1.0","coffee-script":"^1.9.3","mocha":"^3.2.0","node-gyp":"^3.4.0","tmp":"0.0.31"},"gitHead":"52e38c35f213ee88a21c917054ff52e426bd7795","versions":[{"number":"0.0.3","date":"2016-02-05T19:38:37.397Z"},{"number":"0.0.4","date":"2016-02-06T17:46:14.868Z"},{"number":"0.0.5","date":"2016-02-09T19:32:31.533Z"},{"number":"0.0.6","date":"2016-02-10T17:35:04.305Z"},{"number":"0.0.7","date":"2017-06-19T19:44:10.864Z"},{"number":"0.0.7-b","date":"2017-06-19T19:49:28.892Z"}],"readme":"petard\n======\n\na js llvm library\n\n        For 'tis the sport to have the enginer\n        Hoist with his own petar'...\n\n                    - Hamlet, Shakespeare\n\n  * [introduction][90]\n  * [dependencies][91]\n  * [getting started][92]\n  * [documentation][93]\n    * [petard types][15]\n      * [Type][10]\n      * [Value][11]\n      * [Builder][12]\n      * [FunctionBuilder][13]\n      * [SwitchBuilder][18]\n      * [ChooseBuilder][19]\n      * [CodeUnit][14]\n    * [helpers][16]\n      * [`type` dict][17]\n  * [more information][94]\n\n[![Build Status](https://travis-ci.org/couchand/petard.svg?branch=master)](https://travis-ci.org/couchand/petard)\n\nintroduction\n------------\n\nFrustrated with the state of JS support for LLVM, I built another library.\nRather than trying to be generic bindings to libLLVM, **petard** tries to make\nthe most common case easy: generating fresh IR.  You don't have total control\nover the LLVM machinery and there aren't really facilities for working with IR\nthat already exists (so you can't write passes), but if those limitations aren't\na problem **petard** makes dealing with LLVM much simpler.\n\nThis software is under active development.  The README should reflect current\nfunctionality, but don't be surprised if something you think should work causes\nyour computer to segfault.  **petard** aims to catch these things and throw\nJavaScript errors, but we don't have very good coverage yet.  Please do submit\na ticket or pull request if there's a type of programmer error that could be\ncaught earlier and an error thrown.\n\none more warning: it is currently VERY leaky.  don't use in any program that\nwill be running very long.\n\ndependencies\n------------\n\n  * a recent version of node\n  * nan version 2.1\n  * llvm version 3.9\n\ngetting started\n---------------\n\nFirst you need to install LLVM version 3.9 on your system, including the dev libs.\nLook to the Travis build config for details.\n\nwhen you're building **petard** you will need to set the environment variable\n`LLVM_CONFIG` to be the llvm-config you've installed.  For example, if you're on\nUbuntu where it's isntalled as `llvm-config-3.9`, you'll enter:\n\n    > LLVM_CONFIG=llvm-config-3.9 npm run build\n\nor\n\n    > LLVM_CONFIG=llvm-config-3.9 npm install petard\n\nOnce you've got it built successfully, try this:\n\n```coffeescript\nllvm = require 'petard'\n\n{i8, i32, pointerTo} = llvm.type\n\nhello = llvm.CodeUnit \"hello\"\n\nmain = hello.makeFunction \"main\", i32\nputs = hello.declareFunction \"puts\", i32, pointerTo i8\n\ntext = hello.constant \"Hello, world!\\n\"\n\nmessage = main.loadConstant text\nmain.callFunction puts, message\n\nmain.return 0\n\nhello.writeBitcodeToFile \"hello.bc\"\n```\n\nThen use opt and clang as usual with the LLVM IR bitcode file.  Look at the\n[example][21] folder for more examples.\n\nAlternatively, you can JIT compile and call the function from JavaScript.\n\n```coffeescript\nhi = hello.makeFunction \"hi\", i32, pointerTo i8\n\nprefix = hello.constant \"Hello, \"\n\nhi.callFunction puts, hi.loadConstant prefix\nhi.callFunction puts, hi.parameter 0\n\nhi.return 0\n\ngreet = hi.jitCompile()\n\ngreet \"Bill\"\ngreet \"Janice\"\ngreet \"Bart\"\n```\n\ndocumentation\n-------------\n\nThe underlying C++ API exposes the basics of LLVM IR construction, and the node\nwrapper adds some higher-level functionality on top of that.  In the listing the\nmethods in JavaScript are marked with a *(js)*.\n\n  * [petard types][15]\n    * [Type][10]\n    * [Value][11]\n    * [Builder][12]\n    * [FunctionBuilder][13]\n    * [SwitchBuilder][18]\n    * [CodeUnit][14]\n  * [helpers][16]\n    * [`type` dict][17]\n\n### petard types\n\n#### Type\n\nRepresents an LLVM type.  You'll see these most commonly when you get them from\n`petard.type` and pass them when constructing functions and values.  The only\nthing you can do to a type is get its name as a string.\n\n##### String type.toString()\n\nReturns the type as a string.\n\n#### Value\n\nRepresents an LLVM value, or if you look at it another way, represents an\nabstract expression.  You'll get these and pass them in to many of the builder\nmethods.  The only thing you can do to a value is get its type.\n\n##### [Type][10] value.type\n\nA property containing the type of the value.\n\n#### Builder\n\nSomething that can construct LLVM IR.  It represents a particular part of a\nfunction (an LLVM block) as well as a cursor within that block where\ninstructions will be placed.  Calls to builder methods construct LLVM IR and\ntake and return values and other builders.\n\n##### return(\\[Number|[Value][11] value\\])\n\nReturn from the function.  If a value is provided, it is the return value of the\nfunction.  You must ensure that the value passed is of the same type as the\nreturn type of the function.\n\n##### [Value][11] parameter(Number index)\n\nReference function parameter `index`.\n\n##### [Value][11] getElementPointer([Value][11] base, Number|[Value][11] indexList...)\n\nPerform pointer math on the aggregate type pointer to produce a new pointer\nto the given structure member.  For details, see the [GetElementPointer FAQ][2].\n\n##### [Value][11] extractElement([Value][11] vec, Number|[Value][11] index)\n\nExtract the element at the specified index from the vector.\n\n##### [Value][11] insertElement([Value][11] vec, [Value][11] value, Number|[Value][11] index)\n\nInsert the value as the element at the specified index from the vector.\n\n##### [Value][11] loadConstant([Value][11] constant)\n\nLoad a constant value.  Currently the only usage is to load a string constant,\nsee the first example.\n\n##### [Value][11] callFunction([FunctionBuilder][13]|[FunctionValue][20] fn, \\[[Value][11] params...\\])\n\nCall the given internal or external function, passing in the parameter values.\n\n##### [Value][11] alloca([Type][10] type, \\[Number|[Value][11] arraySize\\])\n\nAllocate space the size of type on the stack.  If an arraySize is provided,\ninstead allocate that much space times the arraySize.  Returns a pointer value\nto the space.\n\n##### [Value][11] load([Value][11] pointer)\n\nLoad a value from the memory pointed to by pointer.\n\n##### store([Value][11] value, [Value][11] pointer)\n\nStore the value in the memory pointed to by pointer.\n\n##### [Value][11] add([Value][11] left, [Value][11] right)\n\nAdd the values.  Works on integer and float values.\n\n##### [Value][11] sub([Value][11] left, [Value][11] right)\n\nSubtract the right value from the left.  For integers and floats.\n\n##### [Value][11] mul([Value][11] left, [Value][11] right)\n\nMultiply the values.  They can be integers or floats.\n\n##### [Value][11] udiv([Value][11] left, [Value][11] right)\n\nUnsigned integer divide the left value by the right.\n\n##### [Value][11] sdiv([Value][11] left, [Value][11] right)\n\nSigned integer divide the left value by the right.\n\n##### [Value][11] fdiv([Value][11] left, [Value][11] right)\n\nFloating point divide the left value by the right.\n\n##### [Value][11] urem([Value][11] left, [Value][11] right)\n\nThe remainder when the left value is unsigned integer divided by the right.\n\n##### [Value][11] srem([Value][11] left, [Value][11] right)\n\nThe remainder when the left value is signed integer divided by the right.\n\n##### [Value][11] frem([Value][11] left, [Value][11] right)\n\nThe remainder when the left value is floating point divided by the right.\n\n##### [Value][11] and([Value][11] left, [Value][11] right)\n\nBitwise and the values.\n\n##### [Value][11] or([Value][11] left, [Value][11] right)\n\nBitwise or the values.\n\n##### [Value][11] xor([Value][11] left, [Value][11] right)\n\nBitwise xor the values.\n\n##### [Value][11] shl([Value][11] left, [Value][11] right)\n\nShift the left value left by the right value number of bits.\n\n##### [Value][11] lshr([Value][11] left, [Value][11] right)\n\nShift the left value right logically (sign-ignoring) by the right value number\nof bits.\n\n##### [Value][11] ashr([Value][11] left, [Value][11] right)\n\nShift the left value right arithmetically (sign-preserving) by the right value\nnumber of bits.\n\n##### [Value][11] equal([Value][11] left, [Value][11] right)\n\nCompare the values for equality.\n\n##### [Value][11] notEqual([Value][11] left, [Value][11] right)\n\nCompare the values for inequality.\n\n##### [Value][11] uGreaterThan([Value][11] left, [Value][11] right)\n\nUnsigned greater than comparison.\n\n##### [Value][11] uAtLeast([Value][11] left, [Value][11] right)\n\nUnsigned greater than or equal to comparison.\n\n##### [Value][11] uLessThan([Value][11] left, [Value][11] right)\n\nUnsigned less than comparison.\n\n##### [Value][11] uAtMost([Value][11] left, [Value][11] right)\n\nUnsigned less than or equal to comparison.\n\n##### [Value][11] sGreaterThan([Value][11] left, [Value][11] right)\n\nSigned greater than comparison.\n\n##### [Value][11] sAtLeast([Value][11] left, [Value][11] right)\n\nSigned greater than or equal to comparison.\n\n##### [Value][11] sLessThan([Value][11] left, [Value][11] right)\n\nSigned less than comparison.\n\n##### [Value][11] sAtMost([Value][11] left, [Value][11] right)\n\nSigned less than or equal to comparison.\n\n##### [Value][11] foEqual([Value][11] left, [Value][11] right)\n\nFloat value ordered equality comparison.\n\n##### [Value][11] foNotEqual([Value][11] left, [Value][11] right)\n\nFloat value ordered inequality comparison.\n\n##### [Value][11] foGreaterThan([Value][11] left, [Value][11] right)\n\nFloat value ordered greater than comparison.\n\n##### [Value][11] foAtLeast([Value][11] left, [Value][11] right)\n\nFloat value ordered greater than or equal to comparison.\n\n##### [Value][11] foLessThan([Value][11] left, [Value][11] right)\n\nFloat value ordered less than comparison.\n\n##### [Value][11] foAtMost([Value][11] left, [Value][11] right)\n\nFloat value ordered less than or equal to comparison.\n\n##### [Value][11] fuEqual([Value][11] left, [Value][11] right)\n\nFloat value unordered equality comparison.\n\n##### [Value][11] fuNotEqual([Value][11] left, [Value][11] right)\n\nFloat value unordered inequality comparison.\n\n##### [Value][11] fuGreaterThan([Value][11] left, [Value][11] right)\n\nFloat value unordered greater than comparison.\n\n##### [Value][11] fuAtLeast([Value][11] left, [Value][11] right)\n\nFloat value unordered greater than or equal to comparison.\n\n##### [Value][11] fuLessThan([Value][11] left, [Value][11] right)\n\nFloat value unordered less than comparison.\n\n##### [Value][11] fuAtMost([Value][11] left, [Value][11] right)\n\nFloat value unordered less than or equal to  comparison.\n\n##### [Value][11] trunc([Value][11] value, [Type][10] type)\n\nTruncate the integer value to a smaller type.\n\n##### [Value][11] zext([Value][11] value, [Type][10] type)\n\nZero extend the integer value to a larger type.\n\n##### [Value][11] sext([Value][11] value, [Type][10] type)\n\nSign extend the integer value to a larger type.\n\n##### [Value][11] fpToUI([Value][11] value, [Type][10] type)\n\nConvert the floating point value to an unsigned integer.\n\n##### [Value][11] fpToSI([Value][11] value, [Type][10] type)\n\nConvert the floating point value to a signed integer.\n\n##### [Value][11] uiToFP([Value][11] value, [Type][10] type)\n\nConvert the unsigned integer value to a floating point.\n\n##### [Value][11] siToFP([Value][11] value, [Type][10] type)\n\nConvert the signed integer value to a floating point.\n\n##### [Value][11] fpTrunc([Value][11] value, [Type][10] type)\n\nTruncate the floating point value to a smaller type.\n\n##### [Value][11] fpext([Value][11] value, [Type][10] type)\n\nExtend the floating point value to a larger type.\n\n##### [Value][11] ptrToInt([Value][11] value, [Type][10] type)\n\nConvert the pointer to an integer type.\n\n##### [Value][11] intToPtr([Value][11] value, [Type][10] type)\n\nConvert the integer to a pointer type.\n\n##### [Value][11] bitcast([Value][11] value, [Type][10] type)\n\nCast the value to another type without changing the bits.\n\n##### [Value][11] select([Value][11] condition, [Value][11] ifTrue, [Value][11] ifFalse)\n\nNon-branching value select.  Returns the value corresponding to the ifTrue value\nif the condition is true, and the ifFalse value if the condition is not true.\nAlso operates on vectors.\n\n##### [Value][11] value([Type][10] type, Any value)\n\nConstruct a new LLVM value of the given type for the given JavaScript value.\n\n##### {[Builder][12] then, [Builder][12] else} if([Value][11] condition) *(js)*\n\nBuilds the if conditional control structure for the given condition.  Returns an\nobject with then and else properties, each builders for the then and else blocks.\n\n##### [Builder][12] while(BuilderCallback buildCondition) *(js)*\n\nwith [Value][11] BuilderCallback([Builder][12] condition)\n\nBuilds the while loop control structure.  The callback should take a builder for\nthe loop condition and should return the condition value.  Returns a builder for\nthe body of the loop.\n\n##### br([Builder][12] target)\n\nUnconditional branch to the target.\n\n##### br([Value][11] condition, [Builder][12] ifTrue, [Builder][12] ifFalse)\n\nConditional branch.  If the condition is true, branch to the ifTrue builder,\notherwise branch to the ifFalse builder.\n\n##### [SwitchBuilder][18] switch([Value][11] condition, [Builder][12] defaultDest)\n\nMulti-way branch.  If none of the cases added to the returned switch builder\nmatch the value of the condition, control follows the defaultDest.\n\n##### [ChooseBuilder][19] choose([Value][11] condition) *(js)*\n\nBuilds the switch control structure.  While the `switch` method simply produces\na multi-way branch, this provides the high-level control you're expecting\nout of the box, namely merging back to one place at the end.\n\n##### [Builder][12] createBlock(String name)\n\nCreate another block in the same function.  Use with the branching instructions\nto create custom control structures.  See the node wrapper for examples on\nusing `createBlock`, `splitBlock`, `useBlock`, `insertBefore`, `insertAfter`,\nand `br` to build control structures.\n\n##### [Builder][12] splitBlock(String name)\n\nSplit the current block at the cursor.  The object itself retains the top half\n(all the instructions written _before_) and the returned builder takes the\nbottom half (all the instructions written _after_).  In practice this usually\nmeans the terminator of the block is the only instruction in the new block.\n\n##### useBlock([Builder][12] target)\n\nSet this builder to start building in the target block.  Make sure this builder\nalready has a terminator or you'll get into trouble.\n\n##### insertAfter()\n\nStart inserting instructions _after_ the cursor rather than before.  Mainly\nuseful to appending a terminator to a block ahead of time.\n\n##### insertBefore()\n\nResume inserting instructions _before_ the cursor, the default behavior.  Used\nto restore the standard mode after inserting a terminator.\n\n#### FunctionBuilder\n\nA specialization of a builder corresponding to a complete function.  In addition\nto the normal builder methods, it has a few special properties.\n\n##### String fnBuilder.name\n\nA property containing the name of the function.\n\n##### [Type][10] fnBuilder.type\n\nA property containing the type of the function.\n\n##### Function jitCompile() *(js)*\n\nJIT compile the function, the set up a foreign-function interface to make the\nfunction callable from JavaScript.  Uses the [ffi][70] library to dynamically\nbind the functino pointer.\n\n#### SwitchBuilder\n\nA special tool for working with switch statements.  It is returned from the\n[switch][22] method of a builder.\n\n##### addCase(Number onVal, [Builder][12] target)\n\nAdds a case for the value `onVal`, branching to target.\n\n#### ChooseBuilder *(js)*\n\nThe same thing as the switch builder, but for [choose][23] statements.\n\n##### [Builder][12] defaultCase\n\nThe default case builder.\n\n##### [Builder][12] addCase(Number onVal)\n\nAdds a case for the value `onVal`, returning a builder for the case.\n\n#### CodeUnit\n\nRepresents an overall unit of code, such as a file.  Directly corresponds to an\nLLVM Module.  It has a few helpful methods.\n\n##### [Value][11] unit.constant([Value][11] value)\n\nCompile a constant value into the IR.  At the moment the only use is to load a\nconstant string.  See the first example for usage.\n\n##### [Value][11] unit.declareFunction(String name, \\[[Type][10] returns\\], \\[[Type][10] takes...\\])\n\nDeclare a function external to this code unit that will be linked in.  Takes the\nname of the function and optionally the return type and parameter types.\nReturns a special FunctionValue.\n\n##### [FunctionBuilder][13] unit.makeFunction(String name, \\[[Type][10] returns\\], \\[[Type][10] takes...\\])\n\nCreate a new function in this code unit with the given name and optionall the\nreturn type and parameter types.\n\n##### unit.dump()\n\nDump the code unit IR to the screen.  Useful for debugging, not so much for\nregular usage, since the underlying LLVM method always dumps to stderr.\n\n##### unit.writeBitcodeToFile(String filename)\n\nWrite the bitcode for this code unit to a file with the given filename.  The\nfile must not exist, if it does this method will fail.\n\n##### Buffer unit.jitFunction([FunctionBuilder][13] fn)\n\nJIT compile the function.  Returns the raw pointer to the function as a Buffer.\nYou may find the corresponding helper method on [FunctionBuilder][13] to be more\nuseful since you can call the result of that method from JavaScript.\n\n### helpers\n\n#### `type` dict\n\nThis dict contains all the basic types for easy reference.\n\n  * `i1` - A one bit integer (a boolean).\n  * `i8` - A single byte.\n  * `i16` - A small word.\n  * `i32` - A medium word.\n  * `i64` - A long word.\n  * `f16` - A half-precision floating point value. (LLVM's `half`)\n  * `f32` - A single-precision floating point value. (LLVM's `float`)\n  * `f64` - A double-precision floating point value. (LLVM's `double`)\n  * [Type][10] arrayOf(Number size, [Type][10] element) - Takes a size and type\n    and returns an array of that size and type.\n  * [Type][10] vectorOf(Number size, [Type][10] element) - Takes a size and type\n    and returns a vector of that size and type.\n  * [Type][10] structOf(\\[[Type][10]\\] elements) - Takes an array of types and\n    returns a struct composed of those types.\n  * [Type][10] pointerTo([Type][10] pointee) - Takes a type and returns a\n    pointer to that type.\n\nmore information\n----------------\n\n  * [LLVM Language Reference][0]\n  * [LLVM Programmer's Manual][1]\n\n[0]: http://llvm.org/docs/LangRef.html\n[1]: http://llvm.org/docs/ProgrammersManual.html\n[2]: http://llvm.org/docs/GetElementPtr.html\n\n[70]: https://www.npmjs.com/package/ffi\n\n[10]: https://github.com/couchand/petard#type\n[11]: https://github.com/couchand/petard#value\n[12]: https://github.com/couchand/petard#builder\n[13]: https://github.com/couchand/petard#functionbuilder\n[14]: https://github.com/couchand/petard#codeunit\n[15]: https://github.com/couchand/petard#petard-types\n[16]: https://github.com/couchand/petard#helpers\n[17]: https://github.com/couchand/petard#type-dict\n[18]: https://github.com/couchand/petard#switchbuilder\n[19]: https://github.com/couchand/petard#choosebuilder-js\n\n[20]: https://github.com/couchand/petard#value-unitdeclarefunctionstring-name-type-returns-type-takes\n[21]: https://github.com/couchand/petard/tree/master/example\n[22]: https://github.com/couchand/petard#switchbuilder-switchvalue-condition-builder-defaultdest\n[23]: https://github.com/couchand/petard#choosebuilder-choosevalue-condition-js\n\n[90]: https://github.com/couchand/petard#introduction\n[91]: https://github.com/couchand/petard#dependencies\n[92]: https://github.com/couchand/petard#getting-started\n[93]: https://github.com/couchand/petard#documentation\n[94]: https://github.com/couchand/petard#more-information\n\n##### ╭╮☲☲☲╭╮ #####\n","created":"2016-02-05T19:38:37.397Z","modified":"2017-06-19T19:49:28.892Z","lastPublisher":{"name":"couchand","email":"npm@couchand.com"},"owners":[{"name":"couchand","email":"npm@couchand.com"}],"other":{"_attachments":{},"_from":".","_id":"petard","_nodeVersion":"6.2.0","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/petard-0.0.7-b.tgz_1497901767314_0.4239953097421676"},"_npmUser":{"name":"couchand","email":"npm@couchand.com"},"_npmVersion":"3.8.9","_rev":"3-eb1dacf00496bbd5c4a32df200248e2b","_shasum":"1a14c1caacee78f3591934abeca217570295822e","author":{"name":"Andrew Couch","email":"petard@andrewcou.ch"},"bugs":{"url":"https://github.com/couchand/petard/issues"},"directories":{},"dist-tags":{"latest":"0.0.7-b"},"dist":{"shasum":"1a14c1caacee78f3591934abeca217570295822e","tarball":"https://registry.npmjs.org/petard/-/petard-0.0.7-b.tgz"},"maintainers":[{"name":"couchand","email":"npm@couchand.com"}],"readmeFilename":"README.markdown","time":{"modified":"2017-06-19T19:49:28.892Z","created":"2016-02-05T19:38:37.397Z","0.0.3":"2016-02-05T19:38:37.397Z","0.0.4":"2016-02-06T17:46:14.868Z","0.0.5":"2016-02-09T19:32:31.533Z","0.0.6":"2016-02-10T17:35:04.305Z","0.0.7":"2017-06-19T19:44:10.864Z","0.0.7-b":"2017-06-19T19:49:28.892Z"}}}