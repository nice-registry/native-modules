{"name":"secureworker","version":"0.1.4","description":"Run JavaScript inside an Intel SGX enclave","main":"./lib/index.js","repository":"https://github.com/luckychain/node-secureworker","keywords":["sgx","enclave","worker"],"bin":{"secureworker-create":"bin/secureworker-create"},"scripts":{"build":"make node","install":"make node || true","test":"tests/run.js"},"dependencies":{"node-webcrypto-ossl":"^1.0.20","promise-polyfill":"^6.0.2","node-uuid":"^1.4.7","int64-buffer":"^0.1.9","nan":"^2.5.1","browserify":"^14.1.0","yargs":"^7.0.1","underscore":"^1.8.3"},"engines":{"node":"6.10.0"},"license":"BSD-3-Clause","homepage":"https://github.com/luckychain/node-secureworker","gitHead":"ff28c1196af78c9724c4e9f9b4ab7a07ad2f2378","versions":[{"number":"0.1.0","date":"2017-03-15T21:56:39.595Z"},{"number":"0.1.1","date":"2017-03-15T22:01:30.364Z"},{"number":"0.1.2","date":"2017-03-15T22:30:31.731Z"},{"number":"0.1.3","date":"2017-03-18T07:25:41.610Z"},{"number":"0.1.4","date":"2017-03-18T07:36:25.871Z"}],"readme":"# SecureWorker\n\nThis NPM package allows you to run JavaScript inside a secure (trusted) environment (enclave) provided by\n[Intel SGX](https://software.intel.com/en-us/sgx) technology on modern CPUs. When used properly,\neven operating system or a cloud provider cannot access data, and observe and interfere with\noperations inside an enclave.\n\nThis package executes JavaScript using the [Duktape](http://duktape.org/) JavaScript engine and provides\na web workers-like familiar environment. Cryptographic operations are exposed through a Web Crypto compatible API.\nPromises are available as well. This allows you to write isometric code and use the same code on client, server,\nand inside enclaves, and see secure workers as just another, secure and trusted, component in your JavaScript-based\narchitecture.\n\n**Warning: The project is still in development. Feel free to contribute.**\n\n## Installation\n\n```\nnpm install secureworker --save\n```\n\n## Intel SGX requirements\n\nOf course, to really use this package properly, you need [SGX hardware](https://github.com/ayeks/SGX-hardware).\n\nBut for development you have various options. Intel provides through its SDK an SGX simulator.\nThis package also fallbacks to mock mode of operation, where it uses [vm](https://nodejs.org/api/vm.html)\nto simulate an isolated running environment, if it cannot load necessary binaries.\nOf course, such execution does not give you added security, but it is good for experimentation.\n\nIf you would like to build enclaves, you need [Intel SGX SDK](https://software.intel.com/en-us/sgx-sdk/download).\nTo run them, you need [SGX PSW](https://github.com/01org/linux-sgx) (platform software, i.e., runtime).\nTo run them with SGX hardware, you need a [kernel driver](https://github.com/01org/linux-sgx-driver).\n\nAlternativelly, you can use this [Docker image](https://hub.docker.com/r/tozd/sgx/) which has all SDK and PSW\nalready installed. (If you install SGX kernel driver on the host, you can even use it in production to run\nyour SGX enabled apps.)\n\n**Warning: By default built enclaves are run in simulation and debug mode (or even mock mode). This does not provide any added security.**\n\n[Read more about various types of compiling and executing enclaves](https://software.intel.com/en-us/blogs/2016/01/07/intel-sgx-debug-production-prelease-whats-the-difference).\n\n## Bundling and building\n\nEach enclave you build with this package (`.so` file) can contain multiple JavaScript files.\nYou can bundle each of them with your favorite tool. For example, for [browserify](http://browserify.org/)\nthe following options work well to create a `enclave-bundle.js` file from input `enclave-source.js`\nfile, bundling any imports into the bundle as well.\n\n```\n$ browserify --insert-global-vars __filename,__dirname --no-commondir -t [ babelify --presets [ es2015 ] ] enclave-source.js > enclave-bundle.js\n```\n\nOnce you have files you want to build into an enclave (e.g., `enclave-bundle.js`, `tests.js`), you can use a tool\nprovided by this package to build an enclave file `enclave.so`:\n\n```\n$ secureworker-create --output enclave.so enclave-bundle.js tests.js\n```\n\nScripts are identified inside an enclave using their basename.\n\nNow, you can start your secure worker (enclave) using:\n\n```javascript\nconst worker = new SecureWorker('enclave.so', 'enclave-bundle.js');\n```\n\n## Remote attestation 101\n\nRunning code inside a secure environment (enclave) nobody can inspect or tamper with is great, but not very helpful\nif you cannot prove to others that you have really executed the code inside a specific enclave, or prove to\nothers that they are really communicating with the enclave, and not somebody who is pretending to be\nthat enclave.\n\nTo address this, Intel provides a service which can provide such proofs for you (now you have to trust\nIntel, but you are already trusting them with [correctness of their CPUs](https://www.wired.com/2016/06/demonically-clever-backdoor-hides-inside-computer-chip/)).\n\nThe process to prove to others that something executed inside a specific *enclave*, simplified, can be as follows:\n\n1. every *enclave* has a *measurement* which corresponds to its binary image (code);\n   in our case this consists of code provided by this package to run JavaScript inside an\n   *enclave*, and your scripts you built into the *enclave*\n2. when *enclave* wants to produce such proof, it generates a *report* which binds\n   a *measurement* with CPU identity and optional additional *report data* (often a *nonce* to\n   prevent proof we are generating to be reused)\n3. outside *enclave*, but on the same machine, a *report* is exchanged for a *quote* by a quoting *enclave* provided\n   by Intel, and running on the machine as well\n4. a *quote* is send to Intel's remote attestation service and if everything looks like it is coming\n   from the SGX platform and their CPUs, it produces an *attestation*\n5. one can verify offline this *attestation* using Intel's public key, furthermore, one should also\n   verify that the *measurement* corresponds to the expected code, and probably check *report data*\n   (especially if used as a *nonce*)\n\nAlternatively, steps 4. and 5. can be done directly, online, by a peer who would\ncontact Intel's remote attestation service with a *quote* and obtain *attestation*.\n\nOn the other hand, sometimes one wants to know if they are communicating with a specific *enclave*. Often\nso that they can provide it a secret nobody else should receive. In this case a process could be:\n\n1. one should embed their public key in the *enclave*\n2. one starts establishing a secure ephemeral channel with the *enclave*\n3. *enclave* verifies the identity of a peer by using one's public key\n4. one verifies the identity of the *enclave* by asking it to generate\n   a *report* with a *nonce*\n5. *report* is exchanged for a *quote*\n6. one sends the *quote* Intel's remote attestation service to verify it, furthermore, one verifies the\n   *measurement* and *nonce*\n7. if everything matches, the secure channel can be trusted and one can be sure they communicate with\n   the *enclave* directly\n\nIntel SGX SDK provides a set of `sgx_ra_*` functions to help with the latter process, but this package\ndoes not (yet) expose them. You can use Web Crypto API to instead establish a secure channel,\nand have code around the enclave transmit messages between the peer and the enclave using `postMessage`.\n\n## API (outside, untrusted)\n\n### `new SecureWorker(enclaveName:String, contentKey:String) : SecureWorker`\n\nStarts an enclave from file `enclaveName` and asynchronously runs the script under `contentKey` name.\nIt returns a worker instance.\n\n### `SecureWorker.getReportData(report:ArrayBuffer) : ArrayBuffer`\n\nReturns data provided when generating a `report`.\n\n### `SecureWorker.getQuote(report:ArrayBuffer, linkable:Boolean, spid:ArrayBuffer, [revocationList:ArrayBuffer]) : ArrayBuffer`\n\nReturns a quote based on the `report`. `spid` is SPID is an ID given to you by Intel when you register with the\nIntel Attestation Service.\n\nQuotes can be made `linkable` or anonymous. If it is linkable, it is bound to the CPU on which the report\nwas made. [More information](https://software.intel.com/en-us/blogs/2016/03/09/intel-sgx-epid-provisioning-and-attestation-services).\n\n`revocationList` is a list of revoked CPU keys managed by Intel. If you do not provide one, a recent\none will be used automatically. If you pass `null`, none will be used at all.\n\n**Automatic `revocationList` not yet implemented.**\n\n### `SecureWorker.getQuoteData(quote:ArrayBuffer) : ArrayBuffer`\n\nReturns data provided when generating a report, which is carried over to `quote`.\n\n### `SecureWorker.getRemoteAttestation(quote:ArrayBuffer) : ArrayBuffer`\n\nReturns a signed attestation for provided `quote`, if remote attestation succeeds.\n\n**Not yet implemented.**\n\n### `SecureWorker.validateRemoteAttestation(quote:ArrayBuffer, attestation:ArrayBuffer) : Boolean`\n\nValidates that an `attestation`'s signature belongs to Intel's public key.\n\n**Not yet implemented.**\n\n### `SecureWorker.getSGXVersion() : Object`\n\nReturns information about the SGX platform. Returns `null` if running in a mock mode.\n\n**Not yet implemented.**\n\n### `worker.onMessage(listener:Function) : Function`\n\nRegisters a `listener` for messages coming from `worker`.\n\n### `worker.removeOnMessage(listener:Function)`\n\nUnregisters a `listener`.\n\n### `worker.postMessage(message:Object)`\n\nSends a `message` to the `worker`, so that listeners inside get it.\n`message` should be JSON-serializable.\n\n### `worker.terminate()`\n\nStops the `worker`.\n\n**Not yet implemented.**\n\n## API (inside, trusted)\n\n### `SecureWorker.ready : Promise`\n\nA Promise which resolves once worker has fully loaded and all APIs and services have initialized.\n\n### `SecureWorker.getName() : String`\n\nReturns the name under which the current script is stored in an enclave.\n\n**Not yet implemented.**\n\n### `SecureWorker.onMessage(listener:Function) : Function`\n\nRegisters a `listener` for messages coming from outside.\n\n**Make sure you validate all messages before using them.**\n\n### `SecureWorker.removeOnMessage(listener:Function)`\n\nUnregisters a `listener`.\n\n### `SecureWorker.postMessage(message:Object)`\n\nSends a `message` to outside, so that listeners there get it.\n`message` should be JSON-serializable.\n\n***Make sure you do not leak any sensitive data from the enclave.**\n\n### `SecureWorker.close()`\n\nStops the `worker`.\n\n**Not yet implemented.**\n\n### `SecureWorker.importScripts(contentKeys:String...)`\n\nSynchronously run scripts under given names.\n\n### `SecureWorker.monotonicCounters.create() : {uuid:ArrayBuffer, value:Number}`\n\nCreates a new monotonic counter. `uuid` represents ID of the counter, and `value`\nis its current value. Monotonic counters are provided by the SGX platform\nand persist even across enclave resets, so you can use them to prevent rollback\nattacks.\n\n### `SecureWorker.monotonicCounters.destroy(counterId:ArrayBuffer)`\n\nDestroys a monotonic counter with ID `counterId`.\n\n### `SecureWorker.monotonicCounters.read(counterId:ArrayBuffer) : Number`\n\nReturns the value of a monotonic counter with ID `counterId`.\n\n### `SecureWorker.monotonicCounters.increment(counterId:ArrayBuffer) : Number`\n\nIncreases a monotonic counter with ID `counterId` and returns the new value.\n\n### `SecureWorker.getTrustedTime() : {currentTime:ArrayBuffer, timeSourceNonce:ArrayBuffer}`\n\n`currentTime` is of the second resolution in the little-endian byte ordering.\nIt can be used as a trusted source of elapsed time. This is not clock time.\nAll this holds while `timeSourceNonce` stays the same. If `timeSourceNonce` changes,\nthen the trusted time has restarted as well.\n\n### `SecureWorker.getReport([reportData:ArrayBuffer], [targetInfo:ArrayBuffer]) : ArrayBuffer`\n\nReturns a report for the calling enclave. Report can optionally include 64 bytes of `reportData`.\n\nIf `targetInfo` is not provided (is `undefined`) it will be automatically populated\nwith target information needed for quoting.\n\n### `crypto.subtle.*`\n\nA cryptographic API. It matches\n[Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API).\n\n### `crypto.random.getRandomValues(buffer:TypedArray) : TypedArray`\n\nA source of trusted randomness. It matches\n[Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues).\n\n### `Promise:Function`\n\n[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n[implementation](https://github.com/taylorhakes/promise-polyfill).\n\n### `nextTick:Function` and `setImmediate:Function`\n\nEnclaves do not have IO, so those behave the same.\n\n## Mock API\n\nTo use mock mode of operation, you have to provide a function which resolves\nscript names to their content. For example:\n\n```javascript\nimport fs from 'fs';\nimport path from 'path';\nimport SecureWorker from 'secureworker';\n\nSecureWorker._resolveContentKey = function _resolveContentKey(enclaveName, contentKey) {\n  return fs.readFileSync(path.join(__dirname, contentKey), 'utf8');\n};\n```\n\nIf you want to force loading the package in the mock mode, set `FORCE_MOCK_SECUREWORKER`\nenvironment variable.\n\n## Examples\n\nTo see example of package's use, check the [Luckychain project](https://github.com/luckychain/lucky),\na proof of luck [IPFS](https://ipfs.io/) based blockchain:\n* [its enclave code](https://github.com/luckychain/lucky/blob/master/enclave/luckychain.js)\n* [its code using enclave](https://github.com/luckychain/lucky/blob/master/src/js/enclave.js)\n\nSimpler examples can be found in [tests](https://github.com/luckychain/node-secureworker/tree/master/tests) as well.\n\n","created":"2017-03-15T21:56:39.595Z","modified":"2017-03-18T07:36:25.871Z","lastPublisher":{"name":"mitar","email":"mitar.npm@tnode.com"},"owners":[{"name":"mitar","email":"mitar.npm@tnode.com"}],"other":{"_attachments":{},"_from":".","_id":"secureworker","_nodeVersion":"6.10.0","_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/secureworker-0.1.4.tgz_1489822583384_0.24028686853125691"},"_npmUser":{"name":"mitar","email":"mitar.npm@tnode.com"},"_npmVersion":"3.10.10","_rev":"5-05872c1133622112c439cd0c4ad40dad","_shasum":"af6563b87b1bbd1575fce3b75078b02e0a2bbe1b","bugs":{"url":"https://github.com/luckychain/node-secureworker/issues"},"directories":{},"dist-tags":{"latest":"0.1.4"},"dist":{"shasum":"af6563b87b1bbd1575fce3b75078b02e0a2bbe1b","tarball":"https://registry.npmjs.org/secureworker/-/secureworker-0.1.4.tgz"},"maintainers":[{"name":"mitar","email":"mitar.npm@tnode.com"}],"readmeFilename":"README.md","time":{"modified":"2017-03-18T07:36:25.871Z","created":"2017-03-15T21:56:39.595Z","0.1.0":"2017-03-15T21:56:39.595Z","0.1.1":"2017-03-15T22:01:30.364Z","0.1.2":"2017-03-15T22:30:31.731Z","0.1.3":"2017-03-18T07:25:41.610Z","0.1.4":"2017-03-18T07:36:25.871Z"}}}