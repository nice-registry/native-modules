{"name":"sodium-native","version":"1.10.3","description":"Low level bindings for libsodium","main":"index.js","dependencies":{"nan":"^2.4.0","node-gyp-build":"^3.0.0"},"devDependencies":{"buffer-alloc":"^1.1.0","buffer-fill":"^0.1.0","node-gyp":"^3.6.1","prebuildify":"^2.3.3","sodium-test":"^0.7.0","sodium-vectors":"^1.0.0","standard":"^8.6.0","tape":"^4.6.3"},"scripts":{"dev":"node-gyp rebuild","test":"standard && tape \"test/*.js\"","install":"node-gyp-build \"node preinstall.js\" \"node postinstall.js\"","prebuild":"prebuildify -a --strip --preinstall \"node preinstall.js\" --postinstall \"node postinstall.js\"","prebuild-ia32":"prebuildify -a --strip --preinstall \"node preinstall.js\" --postinstall \"node postinstall.js\" --arch=ia32"},"repository":"https://github.com/sodium-friends/sodium-native","license":"MIT","homepage":"https://github.com/sodium-friends/sodium-native","gitHead":"dc89b00476d02ea7c1c10c025f19e2c84e96bac6","versions":[{"number":"0.0.0","date":"2016-11-24T20:15:13.976Z"},{"number":"0.0.1","date":"2016-11-25T19:04:34.323Z"},{"number":"1.0.0","date":"2016-11-29T07:40:39.775Z"},{"number":"1.1.0","date":"2016-11-29T13:31:51.347Z"},{"number":"1.1.1","date":"2016-11-29T13:47:19.415Z"},{"number":"1.1.2","date":"2016-11-29T14:11:35.701Z"},{"number":"1.2.0","date":"2017-01-24T10:43:23.473Z"},{"number":"1.3.0","date":"2017-01-26T04:38:22.079Z"},{"number":"1.3.1","date":"2017-01-26T16:52:32.670Z"},{"number":"1.3.2","date":"2017-02-01T18:44:33.443Z"},{"number":"1.3.3","date":"2017-02-04T03:17:30.448Z"},{"number":"1.4.0","date":"2017-02-04T07:21:00.105Z"},{"number":"1.4.1","date":"2017-02-09T00:09:58.453Z"},{"number":"1.5.0","date":"2017-02-11T21:19:33.596Z"},{"number":"1.5.1","date":"2017-02-12T12:20:37.101Z"},{"number":"1.6.0","date":"2017-03-01T11:01:04.351Z"},{"number":"1.7.0","date":"2017-03-22T15:31:11.261Z"},{"number":"1.8.0","date":"2017-04-05T18:01:06.518Z"},{"number":"1.9.0","date":"2017-04-21T20:17:19.471Z"},{"number":"1.10.0","date":"2017-05-21T21:36:05.211Z"},{"number":"1.10.1","date":"2017-06-04T10:02:36.282Z"},{"number":"1.10.2","date":"2017-07-07T13:20:59.355Z"},{"number":"1.10.3","date":"2017-07-23T15:22:40.490Z"}],"readme":"# sodium-native\n\nLow level bindings for [libsodium](https://github.com/jedisct1/libsodium).\n\n```\nnpm install sodium-native\n```\n\n[![build status](https://travis-ci.org/sodium-friends/sodium-native.svg?branch=master)](https://travis-ci.org/sodium-friends/sodium-native)\n[![build status](https://ci.appveyor.com/api/projects/status/8wi3my2clf1ami6k/branch/master?svg=true)](https://ci.appveyor.com/project/mafintosh/sodium-native/branch/master)\n\n\nThe goal of this project is to be thin, stable, unopionated wrapper around libsodium.\n\nAll methods exposed are more or less a direct translation of the libsodium c-api.\nThis means that most data types are buffers and you have to manage allocating return values and passing them in as arguments intead of receiving them as return values.\n\nThis makes this API harder to use than other libsodium wrappers out there, but also means that you'll be able to get a lot of perf / memory improvements as you can do stuff like inline encryption / decryption, re-use buffers etc.\n\nThis also makes this library useful as a foundation for more high level crypto abstractions that you want to make.\n\n## Usage\n\n``` js\nvar sodium = require('sodium-native')\n\nvar nonce = new Buffer(sodium.crypto_secretbox_NONCEBYTES)\nvar key = new Buffer(sodium.crypto_secretbox_KEYBYTES)\nvar message = new Buffer('Hello, World!')\nvar cipher = new Buffer(message.length + sodium.crypto_secretbox_MACBYTES)\n\nsodium.randombytes_buf(nonce) // insert random data into nonce\nsodium.randombytes_buf(key)  // insert random data into key\n\n// encrypted message is stored in cipher.\nsodium.crypto_secretbox_easy(cipher, message, nonce, key)\n\nconsole.log('Encrypted message:', cipher)\n\nvar plainText = new Buffer(cipher.length - sodium.crypto_secretbox_MACBYTES)\n\nif (!sodium.crypto_secretbox_open_easy(plainText, cipher, nonce, key)) {\n  console.log('Decryption failed!')\n} else {\n  console.log('Decrypted message:', plainText, '(' + plainText.toString() + ')')\n}\n```\n\n## API\n\n#### `var sodium = require('sodium-native')`\n\nLoads the bindings. If you get an module version error you probably need to reinstall the module because you switched node versions.\n\n### Memory Protection\n\nBindings to the secure memory API.\n[See the libsodium \"Securing memory allocations\" docs for more information](https://download.libsodium.org/doc/helpers/memory_management.html).\n\n#### `sodium.memzero(buffer)`\n\nZero out the data in `buffer`.\n\n#### `sodium.mlock(buffer)`\n\nLock the memory contained in `buffer`\n\n#### `sodium.munlock(buffer)`\n\nUnlock previously `mlock`ed memory contained in `buffer`. This will also `memzero` `buffer`\n\n#### `var buffer = sodium.malloc(size)`\n\nAllocate a buffer of `size` which is memory protected. See [libsodium docs](https://download.libsodium.org/doc/helpers/memory_management.html#guarded-heap-allocations) for details. Be aware that many Buffer methods may break the security guarantees of `sodium.malloc`'ed memory.\n\n#### `sodium.mprotect_noaccess(buffer)`\n\nMake `buffer` allocated using `sodium.malloc` inaccessible, crashing the process if any access is attempted.\nNote that this will have no effect for normal `Buffer`s.\n\n#### `sodium.mprotect_readonly(buffer)`\n\nMake `buffer` allocated using `sodium.malloc` read-only, crashing the process if any writing is attempted.\nNote that this will have no effect for normal `Buffer`s.\n\n#### `sodium.mprotect_readwrite(buffer)`\n\nMake `buffer` allocated using `sodium.malloc` read-write, undoing `mprotect_noaccess` or `mprotect_readonly`.\nNote that this will have no effect for normal `Buffer`s.\n\n### Generating random data\n\nBindings to the random data generation API.\n[See the libsodium randombytes_buf docs for more information](https://download.libsodium.org/doc/generating_random_data/).\n\n#### `sodium.randombytes_buf(buffer)`\n\nFill `buffer` with random data.\n\n### Signing\n\nBindings for the crypto_sign API.\n[See the libsodium crypto_sign docs for more information](https://download.libsodium.org/doc/public-key_cryptography/public-key_signatures.html).\n\n#### `crypto_sign_seed_keypair(publicKey, secretKey, seed)`\n\nCreate a new keypair based on a seed.\n\n* `publicKey` should be a buffer with length `crypto_sign_PUBLICKEYBYTES`.\n* `secretKey` should be a buffer with length `crypto_sign_SECRETKEYBYTES`.\n* `seed` should be a buffer with length `crypto_sign_SEEDBYTES`.\n\nThe generated public and secret key will be stored in passed in buffers.\n\n#### `crypto_sign_keypair(publicKey, secretKey)`\n\nCreate a new keypair.\n\n* `publicKey` should be a buffer with length `crypto_sign_PUBLICKEYBYTES`.\n* `secretKey` should be a buffer with length `crypto_sign_SECRETKEYBYTES`.\n\nThe generated public and secret key will be stored in passed in buffers.\n\n#### `crypto_sign(signedMessage, message, secretKey)`\n\nSign a message.\n\n* `signedMessage` should be a buffer with length `crypto_sign_BYTES + message.length`.\n* `message` should be a buffer of any length.\n* `secretKey` should be a secret key.\n\nThe generated signed message will be stored in `signedMessage`.\n\n#### `var bool = crypto_sign_open(message, signedMessage, publicKey)`\n\nVerify and open a message.\n\n* `message` should be a buffer with length `signedMessage - crypto_sign_BYTES`.\n* `signedMessage` at least `crypto_sign_BYTES` length.\n* `publicKey` should be a public key.\n\nWill return `true` if the message could be verified. Otherwise `false`.\nIf verified the originally signed message is stored in the `message` buffer.\n\n#### `crypto_sign_detached(signature, message, secretKey)`\n\nSame as `crypto_sign` except it only stores the signature.\n\n* `signature` should be a buffer with length `crypto_sign_BYTES`.\n* `message` should be a buffer of any length.\n* `secretKey` should be a secret key.\n\nThe generated signature is stored in `signature`.\n\n#### `var bool = crypto_sign_verify_detached(signature, message, publicKey)`\n\nVerify a signature.\n\n* `signature` should be a buffer with length `crypto_sign_BYTES`.\n* `message` should be a buffer of any length.\n* `publicKey` should be a public key.\n\nWill return `true` if the message could be verified. Otherwise `false`.\n\n#### `crypto_sign_ed25519_pk_to_curve25519(curve_pk, ed_pk)`\n\nconvert a ed25519 public key to curve25519 (which can be used with `box` and `scalarmult`)\n* `curve_pk` should be a buffer with length `crypto_box_PUBLICKEYBYTES`\n* `ed_pk` should be a buffer with length `crypto_sign_PUBLICKEYBYTES`\n\n#### `crypto_sign_ed25519_sk_to_curve25519(curve_sk, ed_sk)`\n\nconvert a ed25519 secret key to curve25519 (which can be used with `box` and `scalarmult`)\n* `curve_sk` should be a buffer with length `crypto_box_SECRETKEYBYTES`\n* `ed_sk` should be a buffer with length `crypto_sign_SECRETKEYBYTES`\n\n### Generic hashing\n\nBindings for the crypto_generichash API.\n[See the libsodium crypto_generichash docs for more information](https://download.libsodium.org/doc/hashing/generic_hashing.html).\n\n#### `crypto_generichash(output, input, [key])`\n\nHash a value with an optional key using the generichash method.\n\n* `output` should be a buffer with length within `crypto_generichash_BYTES_MIN` - `crypto_generichash_BYTES_MAX`.\n* `input` should be a buffer of any length.\n* `key` is an optional buffer of length within `crypto_generichash_KEYBYTES_MIN` - `crypto_generichash_KEYBYTES_MAX`.\n\nThe generated hash is stored in `output`.\n\nAlso exposes `crypto_generichash_BYTES` and `crypto_generichash_KEYBYTES` that can be used as \"default\" buffer sizes.\n\n#### `crypto_generichash_batch(output, inputArray, [key])`\n\nSame as `crypto_generichash` except this hashes an array of buffers instead of a single one.\n\n#### `var instance = crypto_generichash_instance([key], [outputLength])`\n\nCreate a generichash instance that can hash a stream of input buffers.\n\n* `key` is an optional buffer as above.\n* `outputLength` the buffer size of your output.\n\n#### `instance.update(input)`\n\nUpdate the instance with a new piece of data.\n\n* `input` should be a buffer of any size.\n\n#### `instance.final(output)`\n\nFinalize the instance.\n\n* `output` should be a buffer as above with the same length you gave when creating the instance.\n\nThe generated hash is stored in `output`.\n\n### Public / secret key box encryption\n\nBindings for the crypto_box API.\n[See the libsodium crypto_box docs for more information](https://download.libsodium.org/doc/public-key_cryptography/authenticated_encryption.html).\n\n#### `crypto_box_seed_keypair(publicKey, secretKey, seed)`\n\nCreate a new keypair based on a seed.\n\n* `publicKey` should be a buffer with length `crypto_box_PUBLICKEYBYTES`.\n* `secretKey` should be a buffer with length `crypto_box_SECRETKEYBYTES`.\n* `seed` should be a buffer with length `crypto_box_SEEDBYTES`.\n\nThe generated public and secret key will be stored in passed in buffers.\n\n#### `crypto_box_keypair(publicKey, secretKey)`\n\nCreate a new keypair.\n\n* `publicKey` should be a buffer with length `crypto_box_PUBLICKEYBYTES`.\n* `secretKey` should be a buffer with length `crypto_box_SECRETKEYBYTES`.\n\nThe generated public and secret key will be stored in passed in buffers.\n\n#### `crypto_box_detached(cipher, mac, message, nonce, publicKey, secretKey)`\n\nEncrypt a message.\n\n* `cipher` should be a buffer with length `message.length`.\n* `mac` should be a buffer with length `crypto_box_MACBYTES`.\n* `message` should be a buffer of any length.\n* `nonce` should be a buffer with length `crypto_box_NONCEBYTES`.\n* `publicKey` should be a public key.\n* `secretKey` should be a secret key.\n\nThe encrypted message will be stored in `cipher` and the authentification code will be stored in `mac`.\n\n#### `crypto_box_easy(cipher, message, nonce, publicKey, secretKey)`\n\nSame as `crypto_box_detached` except it encodes the mac in the message.\n\n* `cipher` should be a buffer with length `message.length + crypto_box_MACBYTES`.\n* `message` should be a buffer of any length.\n* `nonce` should be a buffer with length `crypto_box_NONCEBYTES`.\n* `publicKey` should be a public key.\n* `secretKey` should be a secret key.\n\nThe encrypted message and authentification code  will be stored in `cipher`.\n\n#### `var bool = crypto_box_open_detached(message, cipher, mac, nonce, publicKey, secretKey)`\n\nDecrypt a message.\n\n* `message` should be a buffer with length `cipher.length`.\n* `mac` should be a buffer with length `crypto_box_MACBYTES`.\n* `cipher` should be a buffer of any length.\n* `nonce` should be a buffer with length `crypto_box_NONCEBYTES`.\n* `publicKey` should be a public key.\n* `secretKey` should be a secret key.\n\nReturns `true` if the message could be decrypted. Otherwise `false`.\n\nThe decrypted message will be stored in `message`.\n\n#### `var bool = crypto_box_open_easy(message, cipher, nonce, publicKey, secretKey)`\n\nDecrypt a message encoded with the easy method.\n\n* `message` should be a buffer with length `cipher.length`.\n* `cipher` should be a buffer with length at least `crypto_box_MACBYTES`.\n* `nonce` should be a buffer with length `crypto_box_NONCEBYTES`.\n* `publicKey` should be a public key.\n* `secretKey` should be a secret key.\n\nReturns `true` if the message could be decrypted. Otherwise `false`.\n\nThe decrypted message will be stored in `message`.\n\n### Sealed box encryption\n\nBindings for the crypto_box_seal API.\n[See the libsodium crypto_box_seal docs for more information](https://download.libsodium.org/doc/public-key_cryptography/sealed_boxes.html).\n\nKeypairs can be generated with `crypto_box_keypair()` or `crypto_box_seed_keypair()`.\n\n#### `crypto_box_seal(cipher, message, publicKey)`\n\nEncrypt a message in a sealed box using a throwaway keypair.\nThe ciphertext cannot be associated with the sender due to the sender's key\nbeing a single use keypair that is overwritten during encryption.\n\n* `cipher` should be a buffer with length at least `message.length + crypto_box_SEALBYTES`.\n* `message` should be a buffer with any length.\n* `publicKey` should be the receipent's public key.\n\n#### `var bool = crypto_box_seal_open(message, cipher, publicKey, secretKey)`\n\nDecrypt a message encoded with the sealed box method.\n\n* `message` should be a buffer with length at least  `cipher.length - crypto_box_SEALBYTES`.\n* `cipher` should be a buffer with length at least `crypto_box_SEALBYTES`.\n* `publicKey` should be the receipient's public key.\n* `secretKey` should be the receipient's secret key.\n\nNote: the keypair of the recipient is required here, both public and secret key.\nThis is because during encryption the recipient's public key is used to generate\nthe nonce. The throwaway public key generated by the sender is stored in the first\n`crypto_box_PUBLICKEYBYTE`'s of the ciphertext.\n\n### Secret key box encryption\n\nBindings for the crypto_secretbox API.\n[See the libsodium crypto_secretbox docs for more information](https://download.libsodium.org/doc/secret-key_cryptography/authenticated_encryption.html).\n\n#### `crypto_secretbox_detached(cipher, mac, message, nonce, secretKey)`\n\nEncrypt a message.\n\n* `cipher` should be a buffer with length `message.length`.\n* `mac` should be a buffer with length `crypto_secretbox_MACBYTES`.\n* `message` should be a buffer of any length.\n* `nonce` should be a buffer with length `crypto_secretbox_NONCEBYTES`.\n* `secretKey` should be a secret key with legnth `crypto_secretbox_KEYBYTES`.\n\nThe encrypted message will be stored in `cipher` and the authentification code will be stored in `mac`.\n\n#### `crypto_secretbox_easy(cipher, message, nonce, secretKey)`\n\nSame as `crypto_secretbox_detached` except it encodes the mac in the message.\n\n* `cipher` should be a buffer with length `message.length + crypto_secretbox_MACBYTES`.\n* `message` should be a buffer of any length.\n* `nonce` should be a buffer with length `crypto_secretbox_NONCEBYTES`.\n* `secretKey` should be a secret key with legnth `crypto_secretbox_KEYBYTES`.\n\n#### `var bool = crypto_secretbox_open_detached(message, cipher, mac, nonce, secretKey)`\n\nDecrypt a message.\n\n* `message` should be a buffer with length `cipher.length`.\n* `mac` should be a buffer with length `crypto_secretbox_MACBYTES`.\n* `cipher` should be a buffer of any length.\n* `nonce` should be a buffer with length `crypto_secretbox_NONCEBYTES`.\n* `secretKey` should be a secret key.\n\nReturns `true` if the message could be decrypted. Otherwise `false`.\n\nThe decrypted message will be stored in `message`.\n\n#### `var bool = crypto_secretbox_open_easy(message, cipher, nonce, secretKey)`\n\nDecrypt a message encoded with the easy method.\n\n* `message` should be a buffer with length `cipher.length`.\n* `cipher` should be a buffer with length at least `crypto_secretbox_MACBYTES`.\n* `nonce` should be a buffer with length `crypto_secretbox_NONCEBYTES`.\n* `secretKey` should be a secret key.\n\nReturns `true` if the message could be decrypted. Otherwise `false`.\n\nThe decrypted message will be stored in `message`.\n\n### Non-authenticated streaming encryption\n\nBindings for the crypto_stream API.\n[See the libsodium crypto_stream docs for more information](https://download.libsodium.org/doc/advanced/xsalsa20.html).\n\n#### `crypto_stream(cipher, nonce, key)`\n\nGenerate random data based on a nonce and key into the cipher.\n\n* `cipher` should be a buffer of any size.\n* `nonce` should be a buffer with length `crypto_stream_NONCEBYTES`.\n* `key` should be a secret key with length `crypto_stream_KEYBYTES`.\n\nThe generated data is stored in `cipher`.\n\n#### `crypto_stream_xor(cipher, message, nonce, key)` or\n#### `crypto_stream_chacha20_xor(cipher, message, nonce, key)`\n\nEncrypt, but *not* authenticate, a message based on a nonce and key\n\n* `cipher` should be a buffer with length `message.length`.\n* `message` should be a buffer of any size.\n* `nonce` should be a buffer with length `crypto_stream_NONCEBYTES`.\n* `key` should be a secret key with length `crypto_stream_KEYBYTES`.\n\nThe encrypted data is stored in `cipher`. To decrypt, swap `cipher` and `message`.\nAlso supports in-place encryption where you use the same buffer as `cipher` and `message`.\n\nEncryption defaults to XSalsa20, use `crypto_stream_chacha20_xor` if you want\nto encrypt/decrypt with ChaCha20 instead.\n\n#### `var instance = crypto_stream_xor_instance(nonce, key)` or\n#### `var instance = crypto_stream_chacha20_xor_instance(nonce, key)`\n\nA streaming instance to the `crypto_stream_xor` api. Pass a nonce and key in the constructor.\n\nEncryption defaults to XSalsa20, use `crypto_stream_chacha20_xor_instance` if\nyou want to encrypt/decrypt with ChaCha20 instead.\n\n#### `instance.update(cipher, message)`\n\nEncrypt the next message\n\n#### `instance.final()`\n\nFinalize the stream. Zeros out internal state.\n\n### Authentication\n\nBindings for the crypto_auth API.\n[See the libsodium crypto_auth docs for more information](https://download.libsodium.org/doc/secret-key_cryptography/secret-key_authentication.html).\n\n#### `crypto_auth(output, input, key)`\n\nCreate an authentication token.\n\n* `output` should be a buffer of length `crypto_auth_BYTES`.\n* `input` should be a buffer of any size.\n* `key` should be a buffer of lenght `crypto_auth_KEYBYTES`.\n\nThe generated token is stored in `output`.\n\n#### `var bool = crypto_auth_verify(output, input, key)`\n\nVerify a token.\n\n* `output` should be a buffer of length `crypto_auth_BYTES`.\n* `input` should be a buffer of any size.\n* `key` should be a buffer of lenght `crypto_auth_KEYBYTES`.\n\nReturns `true` if the token could be verified. Otherwise `false`.\n\n### One-time Authentication\n\nBindings for the crypto_onetimeauth API.\n[See the libsodium crypto_onetimeauth docs for more information](https://download.libsodium.org/doc/advanced/poly1305.html).\n\n#### `crypto_onetimeauth(output, input, key)`\n\nCreate a authentication token based on a onetime key.\n\n* `output` should be a buffer of length `crypto_onetimauth_BYTES`.\n* `input` should be a buffer of any size.\n* `key` should be a buffer of lenght `crypto_onetimeauth_KEYBYTES`.\n\nThe generated token is stored in `output`.\n\n#### `var bool = crypto_onetimeauth_verify(output, input, key)`\n\nVerify a token.\n\n* `output` should be a buffer of length `crypto_onetimeauth_BYTES`.\n* `input` should be a buffer of any size.\n* `key` should be a buffer of lenght `crypto_onetimeauth_KEYBYTES`.\n\nReturns `true` if the token could be verified. Otherwise `false`.\n\n#### `var instance = crypto_onetimeauth_instance(key)`\n\nCreate an instance that create a token from a onetime key and a stream of input data.\n\n* `key` should be a buffer of length `crypto_onetimeauth_KEYBYTES`.\n\n#### `instance.update(input)`\n\nUpdate the instance with a new piece of data.\n\n* `input` should be a buffer of any size.\n\n#### `instance.final(output)`\n\nFinalize the instance.\n\n* `output` should be a buffer of length `crypto_onetimeauth_BYTES`.\n\nThe generated hash is stored in `output`.\n\n### Password Hashing\n\nBindings for the crypto_pwhash API.\n[See the libsodium crypto_pwhash docs for more information](https://download.libsodium.org/doc/password_hashing/).\n\n#### `crypto_pwhash(output, password, salt, opslimit, memlimit, algorithm)`\n\nCreate a password hash.\n\n* `output` should be a buffer with length within `crypto_pwhash_BYTES_MIN` - `crypto_pwhash_BYTES_MAX`.\n* `password` should be a buffer of any size.\n* `salt` should be a buffer with length `crypto_pwhash_SALTBYTES`.\n* `opslimit` should a be number containing your ops limit setting in the range `crypto_pwhash_OPSLIMIT_MIN` - `crypto_pwhash_OPSLIMIT_MAX`.\n* `memlimit` should a be number containing your mem limit setting in the range `crypto_pwhash_MEMLIMIT_MIN` - `crypto_pwhash_OPSLIMIT_MAX`.\n* `algorithm` should be a number specifying the algorithm you want to use.\n\nAvailable default ops and mem limits are\n\n* `crypto_pwhash_OPSLIMIT_INTERACTIVE`\n* `crypto_pwhash_OPSLIMIT_MODERATE`\n* `crypto_pwhash_OPSLIMIT_SENSITIVE`\n* `crypto_pwhash_MEMLIMIT_INTERACTIVE`\n* `crypto_pwhash_MEMLIMIT_MODERATE`\n* `crypto_pwhash_MEMLIMIT_SENSITIVE`\n\nThe available algorithms are\n\n* `crypto_pwhash_ALG_DEFAULT`\n\nThe generated hash will be stored in `output` and the entire `output` buffer will be used.\n\n#### `crypto_pwhash_str(output, password, opslimit, memlimit)`\n\nCreate a password hash with a random salt.\n\n* `output` should be a buffer with length `crypto_pwhash_STRBYTES`.\n* `password` should be a buffer of any size.\n* `opslimit` should a be number containing your ops limit setting in the range `crypto_pwhash_OPSLIMIT_MIN` - `crypto_pwhash_OPSLIMIT_MAX`.\n* `memlimit` should a be number containing your mem limit setting in the range `crypto_pwhash_MEMLIMIT_MIN` - `crypto_pwhash_OPSLIMIT_MAX`.\n\nThe generated hash, settings, salt, version and algorithm will be stored in `output` and the entire `output` buffer will be used.\n\n#### `var bool = crypto_pwhash_str_verify(str, password)`\n\nVerify a password hash generated with the above method.\n\n* `str` should be a buffer with length `crypto_pwhash_STRBYTES`.\n* `password` should be a buffer of any size.\n\nReturns `true` if the hash could be verified with the settings contained in `str`. Otherwise `false`.\n\n#### `crypto_pwhash_async(output, password, salt, opslimit, memlimit, algorithm, callback)`\n\nJust like `crypto_pwhash` but will run password hashing on a seperate worker so it will not block the event loop. `callback(err)` will receive any errors from the hashing but all argument errors will `throw`. The resulting hash is written to `output`.\n\n#### `crypto_pwhash_str_async(output, password, opslimit, memlimit, callback)`\n\nJust like `crypto_pwhash_str` but will run password hashing on a seperate worker so it will not block the event loop. `callback(err)` will receive any errors from the hashing but all argument errors will `throw`. The resulting hash with parameters is written to `output`.\n\n#### `crypto_pwhash_str_verify_async(str, password, callback)`\n\nJust like `crypto_pwhash_str_verify` but will run password hashing on a seperate worker so it will not block the event loop. `callback(err, bool)` will receive any errors from the hashing but all argument errors will `throw`. If the verification succeeds `bool` is `true`, otherwise `false`. Due to an issue with libsodium `err` is currently never set.\n\n### Scalar multiplication\n\nBindings for the crypto_scalarmult API.\n[See the libsodium crypto_scalarmult docs for more information](https://download.libsodium.org/doc/advanced/scalar_multiplication.html).\n\n#### `crypto_scalarmult_base(publicKey, secretKey)`\n\nCreate a scalar multiplication public key based on a secret key\n\n* `publicKey` should be a buffer of length `crypto_scalarmult_BYTES`.\n* `secretKey` should be a buffer of length `crypto_scalarmult_SCALARBYTES`.\n\nThe generated public key is stored in `publicKey`.\n\n#### `crypto_scalarmult(sharedSecret, secretKey, remotePublicKey)`\n\nDerive a shared secret from a local secret key and a remote public key.\n\n* `sharedSecret` shoudl be a buffer of length `crypto_scalarmult_BYTES`.\n* `secretKey` should be a buffer of length `crypto_scalarmult_SCALARBYTES`.\n* `remotePublicKey` should be a buffer of length `crypto_scalarmult_BYTES`.\n\nThe generated shared secret is stored in `sharedSecret`.\n\n### Short hashes\n\nBindings for the crypto_shorthash API.\n[See the libsodium crypto_shorthash docs for more information](https://download.libsodium.org/doc/hashing/short-input_hashing.html).\n\n#### `crypto_shorthash(output, input, key)`\n\nHash a value to a short hash based on a key.\n\n* `output` should be a buffer of length `crypto_shorthash_BYTES`.\n* `input` should be a buffer of any size.\n* `key` should be a buffer of length `crypto_shorthash_KEYBYTES`.\n\nThe generated short hash is stored in `output`.\n\n### Key derivation\n\nBindings for the crypto_kdf API.\n[See the libsodium crypto_kdf docs for more information](https://download.libsodium.org/doc/key_derivation/).\n\n#### `crypto_kdf_keygen(key)`\n\nGenerate a new master key.\n\n* `key` should be a buffer of length `crypto_kdf_KEYBYTES`\n\n#### `crypto_kdf_derive_from_key(subkey, subkeyId, context, key)`\n\nDerive a new key from a master key.\n\n* `subkey` should be a buffer between `crypto_kdf_BYTES_MIN` and `crypto_kdf_BYTES_MAX`.\n* `subkeyId` should be an integer.\n* `context` should be a buffer of length `crypto_kdf_CONTEXTBYTES`\n* `key` should by a buffer of length `crypto_kdf_KEYBYTES`\n\n### SHA\n\n#### `crypto_hash_sha256(output, input)`\n\nHash a value to a short hash based on a key.\n\n* `output` should be a buffer of length `crypto_hash_sha256_BYTES`.\n* `input` should be a buffer of any size.\n\nThe generated short hash is stored in `output`.\n\n#### `var instance = crypto_hash_sha256_instance()`\n\nCreate an instance that has stream of input data to sha256.\n\n#### `instance.update(input)`\n\nUpdate the instance with a new piece of data.\n\n* `input` should be a buffer of any size.\n\n#### `instance.final(output)`\n\nFinalize the instance.\n\n* `output` should be a buffer of length `crypto_hash_sha256_BYTES`.\n\nThe generated hash is stored in `output`.\n\n#### `crypto_hash_sha512(output, input)`\n\nHash a value to a short hash based on a key.\n\n* `output` should be a buffer of length `crypto_hash_sha512_BYTES`.\n* `input` should be a buffer of any size.\n\nThe generated short hash is stored in `output`.\n\n#### `var instance = crypto_hash_sha512_instance()`\n\nCreate an instance that has stream of input data to sha512.\n\n#### `instance.update(input)`\n\nUpdate the instance with a new piece of data.\n\n* `input` should be a buffer of any size.\n\n#### `instance.final(output)`\n\nFinalize the instance.\n\n* `output` should be a buffer of length `crypto_hash_sha512_BYTES`.\n\nThe generated hash is stored in `output`.\n\n## License\n\nMIT\n\n","starsCount":2,"created":"2016-11-24T20:15:13.976Z","modified":"2017-07-23T15:22:40.490Z","lastPublisher":{"name":"mafintosh","email":"mathiasbuus@gmail.com"},"owners":[{"name":"mafintosh","email":"mathiasbuus@gmail.com"}],"other":{"_attachments":{},"_id":"sodium-native","_nodeVersion":"8.2.1","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/sodium-native-1.10.3.tgz_1500823357837_0.016623609699308872"},"_npmUser":{"name":"mafintosh","email":"mathiasbuus@gmail.com"},"_npmVersion":"5.3.0","_rev":"25-4acf314c20cfbb143a20142970b6ea8a","author":{"name":"Mathias Buus","url":"@mafintosh"},"bugs":{"url":"https://github.com/sodium-friends/sodium-native/issues"},"directories":{},"dist-tags":{"latest":"1.10.3"},"dist":{"integrity":"sha512-FIeYaG5cc0YZjsAaWP/BCXDNO2xusbtDJbCbEvXrf6/6+dRo/8XCiEG0kwlRcR0wr56sgsZ327BId3ifFe2WYw==","shasum":"3fab41e91cc349bc59b89d7f7039389e62401549","tarball":"https://registry.npmjs.org/sodium-native/-/sodium-native-1.10.3.tgz"},"maintainers":[{"name":"mafintosh","email":"mathiasbuus@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-07-23T15:22:40.490Z","created":"2016-11-24T20:15:13.976Z","0.0.0":"2016-11-24T20:15:13.976Z","0.0.1":"2016-11-25T19:04:34.323Z","1.0.0":"2016-11-29T07:40:39.775Z","1.1.0":"2016-11-29T13:31:51.347Z","1.1.1":"2016-11-29T13:47:19.415Z","1.1.2":"2016-11-29T14:11:35.701Z","1.2.0":"2017-01-24T10:43:23.473Z","1.3.0":"2017-01-26T04:38:22.079Z","1.3.1":"2017-01-26T16:52:32.670Z","1.3.2":"2017-02-01T18:44:33.443Z","1.3.3":"2017-02-04T03:17:30.448Z","1.4.0":"2017-02-04T07:21:00.105Z","1.4.1":"2017-02-09T00:09:58.453Z","1.5.0":"2017-02-11T21:19:33.596Z","1.5.1":"2017-02-12T12:20:37.101Z","1.6.0":"2017-03-01T11:01:04.351Z","1.7.0":"2017-03-22T15:31:11.261Z","1.8.0":"2017-04-05T18:01:06.518Z","1.9.0":"2017-04-21T20:17:19.471Z","1.10.0":"2017-05-21T21:36:05.211Z","1.10.1":"2017-06-04T10:02:36.282Z","1.10.2":"2017-07-07T13:20:59.355Z","1.10.3":"2017-07-23T15:22:40.490Z"},"users":{"hal9zillion":true,"akiva":true}}}