{"name":"lzma-nativez","version":"2.0.7","engines":{"node":">=4"},"description":"Provides bindings to the native liblzma library (.xz file format, among others)","main":"index","bin":{"lzmajs":"./bin/lzmajs"},"dependencies":{"nan":"2.5.1","node-pre-gyp":"^0.6.21","readable-stream":"^2.0.5"},"keywords":["lzma","compression","crc32","xz","liblzma"],"homepage":"https://github.com/addaleax/lzma-native","license":"MIT","repository":"https://github.com/addaleax/lzma-native","scripts":{"install":"node-pre-gyp install --fallback-to-build","test":"mocha --expose-gc -s 1000 -t 5000","prepare":"cd deps && 7z x -y xz-5.2.3-windows.7z bin_i686/liblzma.dll bin_x86-64/liblzma.dll include doc/liblzma.def","jshint":"jshint ."},"gypfile":true,"devDependencies":{"bl":"^1.1.2","coveralls":"^2.11.6","istanbul":"^0.4.2","jshint":"^2.9.1","mocha":"^3.0.2"},"binary":{"module_name":"lzma_native","module_path":"./binding-v2.0.4-{node_abi}-{platform}-{arch}/","host":"https://s3-eu-west-1.amazonaws.com/zapper-possupport/release/zapper-zebra/libs","remote_path":"./lzma-native/","package_name":"{module_name}-v2.0.4-{node_abi}-{platform}-{arch}.tar.gz"},"gitHead":"043e929f5dabcbd47ac0fb14cf6cde064250a55e","bundleDependencies":["node-pre-gyp"],"versions":[{"number":"2.0.4","date":"2017-08-14T06:47:58.501Z"},{"number":"2.0.5","date":"2017-08-14T11:25:14.348Z"},{"number":"2.0.6","date":"2017-08-14T13:22:01.456Z"},{"number":"2.0.7","date":"2017-08-14T13:28:42.336Z"}],"readme":"lzma-native\r\n===========\r\n\r\n[![NPM Version](https://img.shields.io/npm/v/lzma-native.svg?style=flat)](https://npmjs.org/package/lzma-native)\r\n[![NPM Downloads](https://img.shields.io/npm/dm/lzma-native.svg?style=flat)](https://npmjs.org/package/lzma-native)\r\n[![Build Status](https://travis-ci.org/addaleax/lzma-native.svg?style=flat&branch=master)](https://travis-ci.org/addaleax/lzma-native?branch=master)\r\n[![Windows](https://img.shields.io/appveyor/ci/addaleax/lzma-native/master.svg?label=windows)](https://ci.appveyor.com/project/addaleax/lzma-native)\r\n[![Coverage Status](https://coveralls.io/repos/addaleax/lzma-native/badge.svg?branch=master)](https://coveralls.io/r/addaleax/lzma-native?branch=master)\r\n[![Dependency Status](https://david-dm.org/addaleax/lzma-native.svg?style=flat)](https://david-dm.org/addaleax/lzma-native)\r\n[![devDependency Status](https://david-dm.org/addaleax/lzma-native/dev-status.svg?style=flat)](https://david-dm.org/addaleax/lzma-native#info=devDependencies)\r\n\r\nNode.js interface to the native liblzma compression library (.xz file format, among others)\r\n\r\nThis package provides interfaces for compression and decompression\r\nof `.xz` (and legacy `.lzma`) files, both stream-based and string-based.\r\n\r\n<a name=\"example-usage\"></a>\r\n\r\n## Example usage\r\n\r\n<a name=\"installation\"></a>\r\n\r\n### Installation\r\n\r\nSimply install `lzma-native` via npm:\r\n```bash\r\n$ npm install --save lzma-native\r\n```\r\n\r\n*Note*: As of version 1.0.0, this module provides pre-built binaries for multiple Node.js\r\nversions and all major OS using [node-pre-gyp](https://github.com/mapbox/node-pre-gyp),\r\nso for 99 % of users no compiler toolchain is necessary.\r\nPlease [create an issue here](https://github.com/addaleax/lzma-native/issues/new)\r\nif you have any trouble installing this module.\r\n\r\n*Note*: `lzma-native@2.x` requires a Node version >= 4. If you want to support\r\nNode `0.10` or `0.12`, you can feel free to use `lzma-native@1.x`.\r\n\r\n<a name=\"streams-usage\"></a>\r\n\r\n### For streams\r\n\r\nIf you don’t have any fancy requirements, using this library is quite simple:\r\n\r\n<!--\r\nSome examples in this README file are executed as part of the automatic\r\ntesting process. See test/readme-examples.js for details.\r\n-->\r\n\r\n<!-- runtest:{Compress the README.md file} -->\r\n\r\n```js\r\nvar lzma = require('lzma-native');\r\n\r\nvar compressor = lzma.createCompressor();\r\nvar input = fs.createReadStream('README.md');\r\nvar output = fs.createWriteStream('README.md.xz');\r\n\r\ninput.pipe(compressor).pipe(output);\r\n```\r\n\r\nFor decompression, you can simply use `lzma.createDecompressor()`.\r\n\r\nBoth functions return a stream where you can pipe your\r\ninput in and read your (de)compressed output from.\r\n\r\n<a name=\"buffers-usage\"></a>\r\n\r\n### For simple strings/Buffers\r\n\r\nIf you want your input/output to be Buffers (strings will be accepted as input),\r\nthis even gets a little simpler:\r\n\r\n<!-- runtest:{Compress a simple string directly} -->\r\n\r\n```js\r\nlzma.compress('Banana', function(result) {\r\n    console.log(result); // <Buffer fd 37 7a 58 5a 00 00 01 69 22 de 36 02 00 21 ...>\r\n});\r\n```\r\n\r\nAgain, replace `lzma.compress` with `lzma.decompress` and you’ll get the inverse transformation.\r\n\r\n`lzma.compress()` and `lzma.decompress()`\r\nwill return promises and you don’t need to provide any kind of callback\r\n([Example code](#api-q-compress-examle)).\r\n\r\n<a name=\"api\"></a>\r\n\r\n## API\r\n\r\n<a name=\"api-compat-implementations\"></a>\r\n\r\n### Compatibility implementations\r\n\r\nApart from the API described here, `lzma-native` implements the APIs of the following\r\nother LZMA libraries so you can use it nearly as a drop-in replacement:\r\n\r\n* [node-xz][node-xz] via `lzma.Compressor` and `lzma.Decompressor`\r\n* [LZMA-JS][LZMA-JS] via `lzma.LZMA().compress` and `lzma.LZMA().decompress`,\r\n  though without actual support for progress functions and returning `Buffer` objects\r\n  instead of integer arrays. (This produces output in the `.lzma` file format, *not* the `.xz` format!)\r\n\r\n<a name=\"api-multithreading\"></a>\r\n\r\n### Multi-threaded encoding\r\n\r\nSince version `1.5.0`, lzma-native supports liblzma’s built-in multi-threading\r\nencoding capabilities. To make use of them, set the `threads` option to\r\nan integer value: `lzma.createCompressor({ threads: n });`. You can use\r\nvalue of `0` to use the number of processor cores. This option is only\r\navailable for the `easyEncoder` (the default) and `streamEncoder` encoders.\r\n\r\nNote that, by default, encoding will take place in Node’s libuv thread pool\r\nregardless of this option, and setting it when multiple encoders are running\r\nis likely to affect performance negatively.\r\n\r\n<a name=\"api-reference\"></a>\r\n\r\n### Reference\r\n\r\n[Encoding strings and Buffer objects](#api-encoding-buffers)\r\n * [`compress()`](#api-compress) – Compress strings and Buffers\r\n * [`decompress()`](#api-decompress) – Decompress strings and Buffers\r\n * [`LZMA().compress()`](#api-LZMA_compress) ([LZMA-JS][LZMA-JS] compatibility)\r\n * [`LZMA().decompress()`](#api-LZMA_decompress) ([LZMA-JS][LZMA-JS] compatibility)\r\n\r\n[Creating streams for encoding](#api-creating-streams)\r\n * [`createCompressor()`](#api-create-compressor) – Compress streams\r\n * [`createDecompressor()`](#api-create-decompressor) – Decompress streams\r\n * [`createStream()`](#api-create-stream) – (De-)Compression with advanced options\r\n * [`Compressor()`](#api-robey_compressor) ([node-xz][node-xz] compatibility)\r\n * [`Decompressor()`](#api-robey_decompressor) ([node-xz][node-xz] compatibility)\r\n\r\n[.xz file metadata](#api-parse-indexes)\r\n * [`isXZ()`](#api-isxz) – Test Buffer for `.xz` file format\r\n * [`parseFileIndex()`](#api-parse-file-index) – Read `.xz` file metadata\r\n * [`parseFileIndexFD()`](#api-parse-file-index-fd) – Read `.xz` metadata from a file descriptor\r\n\r\n[Miscellaneous functions](#api-functions)\r\n * [`crc32()`](#api-crc32) – Calculate CRC32 checksum\r\n * [`checkSize()`](#api-check-size) – Return required size for specific checksum type\r\n * [`easyDecoderMemusage()`](#api-easy-decoder-memusage) – Expected memory usage\r\n * [`easyEncoderMemusage()`](#api-easy-encoder-memusage) – Expected memory usage\r\n * [`rawDecoderMemusage()`](#api-raw-decoder-memusage) – Expected memory usage\r\n * [`rawEncoderMemusage()`](#api-raw-encoder-memusage) – Expected memory usage\r\n * [`versionString()`](#api-version-string) – Native library version string\r\n * [`versionNumber()`](#api-version-number) – Native library numerical version identifier\r\n\r\n<a name=\"api-encoding-buffers\"></a>\r\n\r\n### Encoding strings and Buffer objects\r\n\r\n<a name=\"api-compress\"></a>\r\n<a name=\"api-decompress\"></a>\r\n\r\n#### `lzma.compress()`, `lzma.decompress()`\r\n\r\n* `lzma.compress(string, [opt, ]on_finish)`\r\n* `lzma.decompress(string, [opt, ]on_finish)`\r\n\r\nParam        |  Type            |  Description\r\n------------ | ---------------- | --------------\r\n`string`     | Buffer / String  | Any string or buffer to be (de)compressed (that can be passed to `stream.end(…)`)\r\n[`opt`]      | Options / int    | Optional. See [options](#api-options)\r\n`on_finish`  | Callback         | Will be invoked with the resulting Buffer as the first parameter when encoding is finished, and as `on_finish(null, err)` in case of an error.\r\n\r\nThese methods will also return a promise that you can use directly.\r\n\r\nExample code:\r\n<!-- runtest:{Compress and decompress directly} -->\r\n\r\n```js\r\nlzma.compress('Bananas', 6, function(result) {\r\n    lzma.decompress(result, function(decompressedResult) {\r\n        assert.equal(decompressedResult.toString(), 'Bananas');\r\n    });\r\n});\r\n```\r\n\r\n<a name=\"api-q-compress-examle\"></a>\r\nExample code for promises:\r\n<!-- runtest:{Compress and decompress directly using promises} -->\r\n\r\n```js\r\nlzma.compress('Bananas', 6).then(function(result) {\r\n    return lzma.decompress(result);\r\n}).then(function(decompressedResult) {\r\n    assert.equal(decompressedResult.toString(), 'Bananas');\r\n}).catch(function(err) {\r\n    // ...\r\n});\r\n```\r\n\r\n<a name=\"api-LZMA_compress\"></a>\r\n<a name=\"api-LZMA_decompress\"></a>\r\n\r\n#### `lzma.LZMA().compress()`, `lzma.LZMA().decompress()`\r\n\r\n* `lzma.LZMA().compress(string, mode, on_finish[, on_progress])`\r\n* `lzma.LZMA().decompress(string, on_finish[, on_progress])`\r\n\r\n(Compatibility; See [LZMA-JS][LZMA-JS] for the original specs.)\r\n\r\n**Note that the result of compression is in the older LZMA1 format (`.lzma` files).**\r\nThis is different from the more universally used LZMA2 format (`.xz` files) and you will\r\nhave to take care of possible compatibility issues with systems expecting `.xz` files.\r\n\r\nParam         |  Type                   |  Description\r\n------------- | ----------------------- | --------------\r\n`string`      | Buffer / String / Array | Any string, buffer, or array of integers or typed integers (e.g. `Uint8Array`)\r\n`mode`        | int                     | [A number between 0 and 9](#api-options-preset), indicating compression level\r\n`on_finish`   | Callback                | Will be invoked with the resulting Buffer as the first parameter when encoding is finished, and as `on_finish(null, err)` in case of an error.\r\n`on_progress` | Callback                | Indicates progress by passing a number in [0.0, 1.0]. Currently, this package only invokes the callback with 0.0 and 1.0.\r\n\r\nThese methods will also return a promise that you can use directly.\r\n\r\nThis does not work exactly as described in the original [LZMA-JS][LZMA-JS] specification:\r\n * The results are `Buffer` objects, not integer arrays. This just makes a lot\r\n   more sense in a Node.js environment.\r\n * `on_progress` is currently only called with `0.0` and `1.0`.\r\n\r\nExample code:\r\n<!-- runtest:{Compress and decompress directly using LZMA-JS compatibility} -->\r\n\r\n```js\r\nlzma.LZMA().compress('Bananas', 4, function(result) {\r\n    lzma.LZMA().decompress(result, function(decompressedResult) {\r\n        assert.equal(decompressedResult.toString(), 'Bananas');\r\n    });\r\n});\r\n```\r\n\r\nFor an example using promises, see [`compress()`](#api-q-compress-examle).\r\n\r\n<a name=\"api-creating-streams\"></a>\r\n\r\n### Creating streams for encoding\r\n\r\n<a name=\"api-create-compressor\"></a>\r\n<a name=\"api-create-decompressor\"></a>\r\n\r\n#### `lzma.createCompressor()`, `lzma.createDecompressor()`\r\n\r\n* `lzma.createCompressor([options])`\r\n* `lzma.createDecompressor([options])`\r\n\r\nParam       |  Type            |  Description\r\n----------- | ---------------- | --------------\r\n[`options`] | Options / int    | Optional. See [options](#api-options)\r\n\r\nReturn a [duplex][duplex] stream, i.e. a both readable and writable stream.\r\nInput will be read, (de)compressed and written out. You can use this to pipe\r\ninput through this stream, i.e. to mimick the `xz` command line util, you can write:\r\n\r\n<!-- runtest:{Compress and decompress using streams} -->\r\n\r\n```js\r\nvar compressor = lzma.createCompressor();\r\n\r\nprocess.stdin.pipe(compressor).pipe(process.stdout);\r\n```\r\n\r\nThe output of compression will be in LZMA2 format (`.xz` files), while decompression\r\nwill accept either format via automatic detection.\r\n\r\n<a name=\"api-robey_compressor\"></a>\r\n<a name=\"api-robey_decompressor\"></a>\r\n\r\n#### `lzma.Compressor()`, `lzma.Decompressor()`\r\n\r\n* `lzma.Compressor([preset], [options])`\r\n* `lzma.Decompressor([options])`\r\n\r\n(Compatibility; See [node-xz][node-xz] for the original specs.)\r\n\r\nThese methods handle the `.xz` file format.\r\n\r\nParam       |  Type            |  Description\r\n----------- | ---------------- | --------------\r\n[`preset`]  | int              | Optional. See [options.preset](#api-options-preset)\r\n[`options`] | Options          | Optional. See [options](#api-options)\r\n\r\nReturn a [duplex][duplex] stream, i.e. a both readable and writable stream.\r\nInput will be read, (de)compressed and written out. You can use this to pipe\r\ninput through this stream, i.e. to mimick the `xz` command line util, you can write:\r\n\r\n<!-- runtest:{Compress and decompress using streams with node-xz compatibility} -->\r\n\r\n```js\r\nvar compressor = lzma.Compressor();\r\n\r\nprocess.stdin.pipe(compressor).pipe(process.stdout);\r\n```\r\n\r\n<a name=\"api-create-stream\"></a>\r\n\r\n#### `lzma.createStream()`\r\n\r\n* `lzma.createStream(coder, options)`\r\n\r\nParam       |  Type            |  Description\r\n----------- | ---------------- | --------------\r\n[`coder`]   | string           | Any of the [supported coder names](#api-coders), e.g. `\"easyEncoder\"` (default) or `\"autoDecoder\"`.\r\n[`options`] | Options / int    | Optional. See [options](#api-options)\r\n\r\nReturn a [duplex][duplex] stream for (de-)compression. You can use this to pipe\r\ninput through this stream.\r\n\r\n<a name=\"#api-coders\"></a>\r\nThe available coders are (the most interesting ones first):\r\n\r\n* `easyEncoder` \r\n  Standard LZMA2 ([`.xz` file format](https://en.wikipedia.org/wiki/.xz)) encoder.\r\n  Supports [`options.preset`](#api-options-preset) and [`options.check`](#api-options-check) options.\r\n* `autoDecoder`\r\n  Standard LZMA1/2 (both `.xz` and `.lzma`) decoder with auto detection of file format.\r\n  Supports [`options.memlimit`](#api-options-memlimit) and [`options.flags`](#api-options-flags) options.\r\n* `aloneEncoder`\r\n  Encoder which only uses the legacy `.lzma` format.\r\n  Supports the whole range of [LZMA options](#api-options-lzma).\r\n\r\nLess likely to be of interest to you, but also available:\r\n\r\n* `aloneDecoder`\r\n  Decoder which only uses the legacy `.lzma` format.\r\n  Supports the [`options.memlimit`](#api-options-memlimit) option.\r\n* `rawEncoder`\r\n  Custom encoder corresponding to `lzma_raw_encoder` (See the native library docs for details).\r\n  Supports the [`options.filters`](#api-options-filters) option.\r\n* `rawDecoder`\r\n  Custom decoder corresponding to `lzma_raw_decoder` (See the native library docs for details).\r\n  Supports the [`options.filters`](#api-options-filters) option.\r\n* `streamEncoder`\r\n  Custom encoder corresponding to `lzma_stream_encoder` (See the native library docs for details).\r\n  Supports [`options.filters`](#api-options-filters) and [`options.check`](#api-options-check) options.\r\n* `streamDecoder`\r\n  Custom decoder corresponding to `lzma_stream_decoder` (See the native library docs for details).\r\n  Supports [`options.memlimit`](#api-options-memlimit) and [`options.flags`](#api-options-flags) options.\r\n\r\n<a name=\"api-options\"></a>\r\n\r\n#### Options\r\n\r\n<a name=\"api-options-check\"></a>\r\n<a name=\"api-options-memlimit\"></a>\r\n<a name=\"api-options-preset\"></a>\r\n<a name=\"api-options-flags\"></a>\r\n<a name=\"api-options-synchronous\"></a>\r\n\r\nOption name   |  Type      |  Description\r\n------------- | ---------- | -------------\r\n`check`       | check      |  Any of `lzma.CHECK_CRC32`, `lzma.CHECK_CRC64`, `lzma.CHECK_NONE`, `lzma.CHECK_SHA256`\r\n`memlimit`    | float      |  A memory limit for (de-)compression in bytes \r\n`preset`      | int        |  A number from 0 to 9, 0 being the fastest and weakest compression, 9 the slowest and highest compression level. (Please also see the [xz(1) manpage][xz-manpage] for notes – don’t just blindly use 9!) You can also OR this with `lzma.PRESET_EXTREME` (the `-e` option to the `xz` command line utility).\r\n`flags`       | int        |  A bitwise or of `lzma.LZMA_TELL_NO_CHECK`, `lzma.LZMA_TELL_UNSUPPORTED_CHECK`, `lzma.LZMA_TELL_ANY_CHECK`, `lzma.LZMA_CONCATENATED`\r\n`synchronous` | bool       |  If true, forces synchronous coding (i.e. no usage of threading)\r\n`bufsize`     | int        |  The default size for allocated buffers\r\n`threads`     | int        |  Set to an integer to use liblzma’s multi-threading support. 0 will choose the number of CPU cores.\r\n`blockSize`   | int        |  Maximum uncompressed size of a block in multi-threading mode\r\n`timeout`     | int        |  Timeout for a single encoding operation in multi-threading mode\r\n\r\n<a name=\"api-options-filters\"></a>\r\n\r\n`options.filters` can, if the coder supports it, be an array of filter objects, each with the following properties:\r\n\r\n* `.id`\r\n  Any of `lzma.FILTERS_MAX`, `lzma.FILTER_ARM`, `lzma.FILTER_ARMTHUMB`, `lzma.FILTER_IA64`,\r\n  `lzma.FILTER_POWERPC`, `lzma.FILTER_SPARC`, `lzma.FILTER_X86` or\r\n  `lzma.FILTER_DELTA`, `lzma.FILTER_LZMA1`, `lzma.FILTER_LZMA2`\r\n\r\nThe delta filter supports the additional option `.dist` for a distance between bytes (see the [xz(1) manpage][xz-manpage]).\r\n\r\n<a name=\"api-options-lzma\"></a>\r\n\r\nThe LZMA filter supports the additional options `.dict_size`, `.lp`, `.lc`, `pb`, `.mode`, `nice_len`, `.mf`, `.depth`\r\nand `.preset`. See the [xz(1) manpage][xz-manpage] for meaning of these parameters and additional information.\r\n\r\n<a name=\"api-functions\"></a>\r\n\r\n### Miscellaneous functions\r\n\r\n<a name=\"api-crc32\"></a>\r\n\r\n#### `lzma.crc32()`\r\n\r\n* `lzma.crc32(input[, encoding[, previous]])`\r\n\r\nCompute the CRC32 checksum of a Buffer or string.\r\n\r\nParam        |  Type            |  Description\r\n------------ | ---------------- | --------------\r\n`input`      | string / Buffer  | Any string or Buffer.\r\n[`encoding`] | string           | Optional. If `input` is a string, an encoding to use when converting into binary.\r\n[`previous`] | int              | The result of a previous CRC32 calculation so that you can compute the checksum per each chunk\r\n\r\nExample usage:\r\n<!-- runtest:{Compute the CRC32 of a string} -->\r\n\r\n```js\r\nlzma.crc32('Banana') // => 69690105\r\n```\r\n\r\n<a name=\"api-check-size\"></a>\r\n\r\n#### `lzma.checkSize()`\r\n\r\n* `lzma.checkSize(check)`\r\n\r\nReturn the byte size of a check sum.\r\n\r\nParam        |  Type            |  Description\r\n------------ | ---------------- | --------------\r\n`check`      | check            | Any supported check constant.\r\n\r\nExample usage:\r\n<!-- runtest:{Calculate some check sizes} -->\r\n\r\n```js\r\nlzma.checkSize(lzma.CHECK_SHA256) // => 16\r\nlzma.checkSize(lzma.CHECK_CRC32)  // => 4\r\n```\r\n\r\n<a name=\"api-easy-decoder-memusage\"></a>\r\n\r\n#### `lzma.easyDecoderMemusage()`\r\n\r\n* `lzma.easyDecoderMemusage(preset)`\r\n\r\nReturns the approximate memory usage when decoding using easyDecoder for a given preset.\r\n\r\nParam        |  Type       |  Description\r\n------------ | ----------- | --------------\r\n`preset`     | preset      |  A compression level from 0 to 9\r\n\r\nExample usage:\r\n<!-- runtest:{Return memory usage for decoding} -->\r\n\r\n```js\r\nlzma.easyDecoderMemusage(6) // => 8454192\r\n```\r\n\r\n<a name=\"api-easy-encoder-memusage\"></a>\r\n\r\n#### `lzma.easyEncoderMemusage()`\r\n\r\n* `lzma.easyEncoderMemusage(preset)`\r\n\r\nReturns the approximate memory usage when encoding using easyEncoder for a given preset.\r\n\r\nParam        |  Type       |  Description\r\n------------ | ----------- | --------------\r\n`preset`     | preset      |  A compression level from 0 to 9\r\n\r\nExample usage:\r\n<!-- runtest:{Return memory usage for encoding} -->\r\n\r\n```js\r\nlzma.easyEncoderMemusage(6) // => 97620499\r\n```\r\n\r\n<a name=\"api-raw-decoder-memusage\"></a>\r\n\r\n#### `lzma.rawDecoderMemusage()`\r\n\r\n* `lzma.rawDecoderMemusage(filters)`\r\n\r\nReturns the approximate memory usage when decoding using rawDecoder for a given filter list.\r\n\r\nParam        |  Type       |  Description\r\n------------ | ----------- | --------------\r\n`filters`    | array       |  An array of [filters](#api-options-filters)\r\n\r\n<a name=\"api-raw-encoder-memusage\"></a>\r\n\r\n#### `lzma.rawEncoderMemusage()`\r\n\r\n* `lzma.rawEncoderMemusage(filters)`\r\n\r\nReturns the approximate memory usage when encoding using rawEncoder for a given filter list.\r\n\r\nParam        |  Type       |  Description\r\n------------ | ----------- | --------------\r\n`filters`    | array       |  An array of [filters](#api-options-filters)\r\n\r\n<a name=\"api-version-string\"></a>\r\n\r\n#### `lzma.versionString()`\r\n\r\n* `lzma.versionString()`\r\n\r\nReturns the version of the underlying C library.\r\n\r\nExample usage:\r\n<!-- runtest:{Return a version string} -->\r\n\r\n```js\r\nlzma.versionString() // => '5.2.3'\r\n```\r\n\r\n<a name=\"api-version-number\"></a>\r\n\r\n#### `lzma.versionNumber()`\r\n\r\n* `lzma.versionNumber()`\r\n\r\nReturns the version of the underlying C library.\r\n\r\nExample usage:\r\n<!-- runtest:{Return a numeric version identifier} -->\r\n\r\n```js\r\nlzma.versionNumber() // => 50020012\r\n```\r\n\r\n<a name=\"api-parse-indexes\"></a>\r\n\r\n### .xz file metadata\r\n\r\n<a name=\"api-isxz\"></a>\r\n\r\n#### `lzma.isXZ()`\r\n\r\n* `lzma.isXZ(input)`\r\n\r\nTells whether an input buffer is an XZ file (`.xz`, LZMA2 format) using the\r\nfile format’s magic number. This is not a complete test, i.e. the data\r\nfollowing the file header may still be invalid in some way.\r\n\r\nParam        |  Type            |  Description\r\n------------ | ---------------- | --------------\r\n`input`      | string / Buffer  | Any string or Buffer (integer arrays accepted).\r\n\r\nExample usage:\r\n<!-- runtest:{.isXZ() checks some strings correctly} -->\r\n\r\n```js\r\nlzma.isXZ(fs.readFileSync('test/hamlet.txt.xz')); // => true\r\nlzma.isXZ(fs.readFileSync('test/hamlet.txt.lzma')); // => false\r\nlzma.isXZ('Banana'); // => false\r\n```\r\n\r\n(The magic number of XZ files is hex `fd 37 7a 58 5a 00` at position 0.)\r\n\r\n<a name=\"api-parse-file-index\"></a>\r\n\r\n#### `lzma.parseFileIndex()`\r\n\r\n* `lzma.parseFileIndex(options[, callback])`\r\n\r\nRead `.xz` file metadata.\r\n\r\n`options.fileSize` needs to be an integer indicating the size of the file\r\nbeing inspected, e.g. obtained by `fs.stat()`.\r\n\r\n`options.read(count, offset, cb)` must be a function that reads `count` bytes\r\nfrom the underlying file, starting at position `offset`. If that is not\r\npossible, e.g. because the file does not have enough bytes, the file should\r\nbe considered corrupt. On success, `cb` should be called with a `Buffer`\r\ncontaining the read data. `cb` can be invoked as `cb(err, buffer)`, in which\r\ncase `err` will be passed along to the original `callback` argument when set.\r\n\r\n`callback` will be called with `err` and `info` as its arguments.\r\n\r\nIf no `callback` is provided, `options.read()` must work synchronously and\r\nthe file info will be returned from `lzma.parseFileIndex()`.\r\n\r\nExample usage:\r\n<!-- runtest:{Read .xz file metadata} -->\r\n\r\n```js\r\nfs.readFile('test/hamlet.txt.xz', function(err, content) {\r\n  // handle error\r\n\r\n  lzma.parseFileIndex({\r\n    fileSize: content.length,\r\n    read: function(count, offset, cb) {\r\n      cb(content.slice(offset, offset + count));\r\n    }\r\n  }, function(err, info) {\r\n    // handle error\r\n    \r\n    // do something with e.g. info.uncompressedSize\r\n  });\r\n});\r\n```\r\n\r\n<a name=\"api-parse-file-index-fd\"></a>\r\n\r\n#### `lzma.parseFileIndexFD()`\r\n\r\n* `lzma.parseFileIndexFD(fd, callback)`\r\n\r\nRead `.xz` metadata from a file descriptor.\r\n\r\nThis is like [`parseFileIndex()`](#api-parse-file-index), but lets you \r\npass an file descriptor in `fd`. The file will be inspected using\r\n`fs.stat()` and `fs.read()`. The file descriptor will not be opened or closed\r\nby this call.\r\n\r\nExample usage:\r\n<!-- runtest:{Read .xz file metadata from a file descriptor} -->\r\n\r\n```js\r\nfs.open('test/hamlet.txt.xz', 'r', function(err, fd) {\r\n  // handle error\r\n\r\n  lzma.parseFileIndexFD(fd, function(err, info) {\r\n    // handle error\r\n    \r\n    // do something with e.g. info.uncompressedSize\r\n    \r\n    fs.close(fd, function(err) { /* handle error */ });\r\n  });\r\n});\r\n```\r\n\r\n## Installation\r\n\r\nThis package includes the native C library, so there is no need to install it separately.\r\n\r\n## Licensing\r\n\r\nThe original C library package contains code under various licenses,\r\nwith its core (liblzma) being public domain. See its contents for details.\r\nThis wrapper is licensed under the MIT License.\r\n\r\n## Related projects\r\n\r\nOther implementations of the LZMA algorithms for node.js and/or web clients include:\r\n\r\n* [lzma-purejs](https://github.com/cscott/lzma-purejs)\r\n* [LZMA-JS](https://github.com/nmrugg/LZMA-JS)\r\n* [node-xz](https://github.com/robey/node-xz) (native)\r\n* [node-liblzma](https://github.com/oorabona/node-liblzma) (native)\r\n\r\nNote that LZMA has been designed to have much faster decompression than\r\ncompression, which is something you may want to take into account when\r\nchoosing an compression algorithm for large files. Almost always, LZMA achieves\r\nhigher compression ratios than other algorithms, though.\r\n\r\n## Acknowledgements\r\n\r\nInitial development of this project was financially supported by [Tradity](https://tradity.de/).\r\n\r\n[node-xz]: https://github.com/robey/node-xz\r\n[LZMA-JS]: https://github.com/nmrugg/LZMA-JS\r\n[Q]: https://github.com/kriskowal/q\r\n[duplex]: https://nodejs.org/api/stream.html#stream_class_stream_duplex\r\n[xz-manpage]: https://www.freebsd.org/cgi/man.cgi?query=xz&sektion=1&manpath=FreeBSD+8.3-RELEASE\r\n","created":"2017-08-14T06:47:58.501Z","modified":"2017-08-14T13:28:42.336Z","lastPublisher":{"name":"zapperadmin","email":"moreinfo@zapper.com"},"owners":[{"name":"zapperadmin","email":"moreinfo@zapper.com"}],"other":{"_attachments":{},"_from":".","_id":"lzma-nativez","_nodeVersion":"6.11.0","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/lzma-nativez-2.0.7.tgz_1502717321843_0.17302285484038293"},"_npmUser":{"name":"zapperadmin","email":"moreinfo@zapper.com"},"_npmVersion":"3.10.10","_rev":"4-431f0562f58114fa9fdc5fb00004bfe9","_shasum":"63cc7e26b6d7fa3b19378e6244f66a5078bc0141","bugs":{"url":"https://github.com/addaleax/lzma-native/issues"},"directories":{},"dist-tags":{"latest":"2.0.7"},"dist":{"shasum":"63cc7e26b6d7fa3b19378e6244f66a5078bc0141","tarball":"https://registry.npmjs.org/lzma-nativez/-/lzma-nativez-2.0.7.tgz"},"maintainers":[{"name":"zapperadmin","email":"moreinfo@zapper.com"}],"readmeFilename":"README.md","time":{"modified":"2017-08-14T13:28:42.336Z","created":"2017-08-14T06:47:58.501Z","2.0.4":"2017-08-14T06:47:58.501Z","2.0.5":"2017-08-14T11:25:14.348Z","2.0.6":"2017-08-14T13:22:01.456Z","2.0.7":"2017-08-14T13:28:42.336Z"}}}