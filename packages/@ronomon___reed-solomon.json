{"name":"@ronomon/reed-solomon","version":"4.1.0","description":"Reed-Solomon erasure coding in pure Javascript with an optional native binding","main":"index.js","repository":"https://github.com/ronomon/reed-solomon","keywords":["reedsolomon","reed-solomon","erasure coding","replication","parity","redundancy","forward","error","correction"],"license":"MIT","homepage":"https://github.com/ronomon/reed-solomon#readme","scripts":{"postinstall":"node-gyp clean","test":"node test.js","install":"node-gyp rebuild"},"dependencies":{"@ronomon/queue":"^2.1.0","nan":"^2.6.2"},"gypfile":true,"gitHead":"b01ffaed56abe731f48bfbafd7bd6cf633f3eacf","versions":[{"number":"4.0.0","date":"2017-03-20T11:52:00.537Z"},{"number":"4.0.1","date":"2017-03-20T11:52:46.679Z"},{"number":"4.1.0","date":"2017-08-03T12:47:10.285Z"}],"readme":"# reed-solomon\nReed-Solomon erasure coding in pure Javascript with an optional C++ binding for multi-core throughput. A port of the [JavaReedSolomon](https://github.com/Backblaze/JavaReedSolomon) library released by [Backblaze](http://backblaze.com). For an introduction to erasure coding, see the post by Brian Beach on the [Backblaze blog](https://www.backblaze.com/blog/reed-solomon/). Special thanks to [Backblaze](http://backblaze.com).\n\n## License\n`reed-solomon` is licensed under the [MIT License](https://en.wikipedia.org/wiki/MIT_License), which means that you can use it in your own projects for free. You can even use it in commercial projects.\n\n## Installation\n\n#### Linux, OS X\nThis will compile the native binding automatically:\n```\nnpm install @ronomon/reed-solomon\n```\n\n#### Windows\nThis will skip compiling the native binding automatically:\n```\nnpm install --ignore-scripts @ronomon/reed-solomon\n```\n\n## Efficiency\nData redundancy is typically achieved through mirroring or replication at a cost of 3x the original data. With Reed-Solomon erasure codes, you can achieve better redundancy at a cost of only 1.5x the original data. Various storage efficiencies of 1.4x and 1.18x are also possible. You can trade storage efficiency, redundancy and recovery time by fine-tuning the number of data shards and parity shards you use.\n\n## Performance\n`reed-solomon` includes a Javascript binding as well as an optional native binding. The native binding executes asynchronously in Node's threadpool for multi-core throughput and scalability without blocking the event loop:\n```\n           CPU: Intel(R) Xeon(R) CPU E3-1230 V2 @ 3.30GHz\n         Cores: 8\n       Threads: 4\n\n============================================================\n\n        Encode: 10000 x (Data=10 Parity=4 Shard=256)\n    Javascript: Latency: 0.028ms Throughput: 88.89 MB/s\n        Native: Latency: 0.044ms Throughput: 224.56 MB/s\n\n        Encode: 10000 x (Data=10 Parity=4 Shard=1024)\n    Javascript: Latency: 0.064ms Throughput: 159.75 MB/s\n        Native: Latency: 0.054ms Throughput: 747.45 MB/s\n\n        Encode: 10000 x (Data=10 Parity=4 Shard=4096)\n    Javascript: Latency: 0.207ms Throughput: 197.02 MB/s\n        Native: Latency: 0.124ms Throughput: 1312.82 MB/s\n\n        Encode: 2048 x (Data=10 Parity=4 Shard=65536)\n    Javascript: Latency: 3.099ms Throughput: 211.43 MB/s\n        Native: Latency: 1.637ms Throughput: 1597.83 MB/s\n\n        Encode: 1024 x (Data=10 Parity=4 Shard=131072)\n    Javascript: Latency: 6.202ms Throughput: 211.27 MB/s\n        Native: Latency: 3.357ms Throughput: 1558.86 MB/s\n\n        Encode: 128 x (Data=10 Parity=4 Shard=1048576)\n    Javascript: Latency: 51.338ms Throughput: 204.23 MB/s\n        Native: Latency: 26.021ms Throughput: 1595.93 MB/s\n\n============================================================\n\n        Decode: 10000 x (Data=10 Parity=4 Shard=256)\n    Javascript: Latency: 0.068ms Throughput: 37.10 MB/s\n        Native: Latency: 0.246ms Throughput: 41.36 MB/s\n\n        Decode: 10000 x (Data=10 Parity=4 Shard=1024)\n    Javascript: Latency: 0.095ms Throughput: 107.56 MB/s\n        Native: Latency: 0.271ms Throughput: 150.59 MB/s\n\n        Decode: 10000 x (Data=10 Parity=4 Shard=4096)\n    Javascript: Latency: 0.196ms Throughput: 208.13 MB/s\n        Native: Latency: 0.264ms Throughput: 618.73 MB/s\n\n        Decode: 2048 x (Data=10 Parity=4 Shard=65536)\n    Javascript: Latency: 2.390ms Throughput: 274.03 MB/s\n        Native: Latency: 1.397ms Throughput: 1871.93 MB/s\n\n        Decode: 1024 x (Data=10 Parity=4 Shard=131072)\n    Javascript: Latency: 4.656ms Throughput: 281.32 MB/s\n        Native: Latency: 2.683ms Throughput: 1950.84 MB/s\n\n        Decode: 128 x (Data=10 Parity=4 Shard=1048576)\n    Javascript: Latency: 36.400ms Throughput: 288.02 MB/s\n        Native: Latency: 24.051ms Throughput: 1711.96 MB/s\n```\n\n## Native Binding (Optional)\nThe native binding will be installed automatically when installing `reed-solomon` without the `--ignore-scripts` argument. The Javascript binding will be used if the native binding could not be compiled or is not available. To compile the native binding manually after installing `reed-solomon`, install [node-gyp](https://www.npmjs.com/package/node-gyp) globally:\n```\nsudo npm install node-gyp -g\n```\nThen build the binding from within the `reed-solomon` module directory:\n```\ncd node_modules/@ronomon/reed-solomon\nnode-gyp rebuild\n```\n\n## Usage\n\n#### Adjust threadpool size and control concurrency\nPlease see the [`crypto-async`](https://github.com/ronomon/crypto-async#adjust-threadpool-size-and-control-concurrency) module for advice on adjusting threadpool size and controlling concurrency.\n\n#### Encoding Parity Shards\n```javascript\nvar ReedSolomon = require('@ronomon/reed-solomon');\n\n// Specify the number of data shards (<=30):\nvar dataShards = 6;\n\n// Specify the number of parity shards (<=30):\nvar parityShards = 3; // Protect against loss of any 3 data or parity shards.\n\n// The total number of shards must be at most 31:\nvar totalShards = dataShards + parityShards;\n\n// Specify the total length of each shard in bytes:\nvar shardLength = 1024 * 1024;\n\nvar buffer = Buffer.concat([\n  // Non-ReedSolomon header data:\n  <Buffer (16)>,\n  // Data shards:\n  <Buffer (shardLength)>,\n  <Buffer (shardLength)>,\n  <Buffer (shardLength)>,\n  <Buffer (shardLength)>,\n  <Buffer (shardLength)>,\n  <Buffer (shardLength)>,\n  // Parity shards:\n  <Buffer (shardLength)>,\n  <Buffer (shardLength)>,\n  <Buffer (shardLength)>,\n  // Non-ReedSolomon footer data:\n  <Buffer (...)>\n]);\n\n// Specify the offset into the buffer at which shards begin:\n// This allows you to include non-ReedSolomon header data in the buffer.\nvar bufferOffset = 16;\n\n// Specify the size after this offset of all shards:\n// This allows you to include non-ReedSolomon footer data in the buffer.\nvar bufferSize = shardLength * totalShards;\n\n// Specify the offset into each shard from which to encode/decode:\n// This allows you to include non-ReedSolomon header data in each shard.\nvar shardOffset = 0;\n\n// Specify the size after this offset:\n// This allows you to include non-ReedSolomon footer data in each shard.\nvar shardSize = shardLength - shardOffset;\n\n// Instantiate a ReedSolomon instance:\n// This can be used concurrently across many `encode()`/`decode()` calls.\nvar rs = new ReedSolomon(dataShards, parityShards);\n\n// Encode all parity shards:\nrs.encode(\n  buffer,\n  bufferOffset,\n  bufferSize,\n  shardLength,\n  shardOffset,\n  shardSize,\n  function(error) {\n    if (error) throw error;\n    // Parity shards now contain parity data.\n  }\n);\n```\n\n#### Decoding Corrupted Shards\n```javascript\n// Corrupt data shard at index 0:\nbuffer[bufferOffset + (shardLength * 0) + shardOffset] = 255;\n// Corrupt parity shard at index 8:\nbuffer[bufferOffset + (shardLength * 8) + shardOffset] = 255;\n// We still have enough parity to corrupt another shard.\n\n// Specify every corrupted shard according to its index in the array:\n// If a corrupted shard is not specified, the result will be wrong.\nvar targets = 0;\ntargets |= (1 << 0); // Data shard at index 0 needs to be decoded.\ntargets |= (1 << 8); // Parity shard at index 8 needs to be decoded.\n\n// Decode the corrupted data and parity shards:\nrs.decode(\n  buffer,\n  bufferOffset,\n  bufferSize,\n  shardLength,\n  shardOffset,\n  shardSize,\n  targets,\n  function(error) {\n    if (error) throw error;\n    // Data shard at index 0 has been repaired.\n    // Parity shard at index 8 has been repaired.\n  }\n);\n```\n\n## Tests\n`reed-solomon` ships with extensive tests, including a long-running fuzz test.\n\nTo test the native and Javascript bindings:\n```\nnode test.js\n```\n\n## Benchmark\nTo benchmark the native and Javascript bindings:\n```\nnode benchmark.js\n```\n","starsCount":1,"created":"2017-03-20T11:52:00.537Z","modified":"2017-08-03T12:47:10.285Z","lastPublisher":{"name":"ronomon","email":"info@ronomon.com"},"owners":[{"name":"ronomon","email":"info@ronomon.com"}],"other":{"_attachments":{},"_id":"@ronomon/reed-solomon","_nodeVersion":"8.2.1","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/reed-solomon-4.1.0.tgz_1501764430207_0.6166095337830484"},"_npmUser":{"name":"ronomon","email":"info@ronomon.com"},"_npmVersion":"5.3.0","_rev":"4-9c2773e23dad850a5fcfd3af13bd1a8a","author":{"name":"Joran Dirk Greef"},"bugs":{"url":"https://github.com/ronomon/reed-solomon/issues"},"directories":{},"dist-tags":{"latest":"4.1.0"},"dist":{"integrity":"sha512-469jd6F/LKBCh24z52J5xJpgY0B6genI4szsL6pPeX1fZtrr9yzWTqTXXdRe6szOypMcfaXdWJFoj828/fjYdg==","shasum":"4d7bd73de1a07b5152b020fce479b01775d4412e","tarball":"https://registry.npmjs.org/@ronomon/reed-solomon/-/reed-solomon-4.1.0.tgz"},"maintainers":[{"name":"ronomon","email":"info@ronomon.com"}],"readmeFilename":"README.md","time":{"modified":"2017-08-03T12:47:10.285Z","created":"2017-03-20T11:52:00.537Z","4.0.0":"2017-03-20T11:52:00.537Z","4.0.1":"2017-03-20T11:52:46.679Z","4.1.0":"2017-08-03T12:47:10.285Z"},"users":{"dkimot":true}}}