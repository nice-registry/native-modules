{"name":"libpq","version":"1.8.7","description":"Low-level native bindings to PostgreSQL libpq","main":"index.js","keywords":["postgres","libpq"],"repository":"https://github.com/brianc/node-libpq","scripts":{"test":"node-gyp rebuild && node_modules/.bin/mocha","install":"node-gyp rebuild"},"license":"MIT","dependencies":{"nan":"^2.3.0","bindings":"1.2.1"},"devDependencies":{"async":"^0.9.0","lodash":"^2.4.1","mocha":"^1.21.4","okay":"^0.3.0"},"gypfile":true,"gitHead":"f1067769c0eab0c60cbf8095c58583a40d1a91ad","homepage":"https://github.com/brianc/node-libpq#readme","versions":[{"number":"0.2.0","date":"2014-09-01T18:09:06.686Z"},{"number":"0.2.1","date":"2014-09-01T18:23:31.513Z"},{"number":"0.2.2","date":"2014-09-02T13:30:29.200Z"},{"number":"0.2.3","date":"2014-09-02T13:33:50.924Z"},{"number":"0.2.4","date":"2014-09-02T13:47:49.899Z"},{"number":"0.2.5","date":"2014-09-03T03:03:45.813Z"},{"number":"0.3.0","date":"2014-09-03T03:28:02.369Z"},{"number":"0.4.0","date":"2014-09-04T23:32:17.736Z"},{"number":"0.4.1","date":"2014-09-04T23:36:41.808Z"},{"number":"0.5.0","date":"2014-09-09T09:47:31.250Z"},{"number":"0.5.1","date":"2014-09-14T01:56:19.894Z"},{"number":"0.5.2","date":"2014-09-14T20:41:37.045Z"},{"number":"0.5.3","date":"2014-09-14T20:56:46.832Z"},{"number":"1.0.0","date":"2014-09-25T16:19:34.717Z"},{"number":"1.0.1","date":"2014-10-07T04:29:26.301Z"},{"number":"1.1.0","date":"2014-10-09T19:32:14.243Z"},{"number":"1.2.0","date":"2014-10-16T03:17:53.467Z"},{"number":"1.2.1","date":"2014-10-18T03:04:57.094Z"},{"number":"1.3.0","date":"2014-11-18T19:31:34.826Z"},{"number":"1.3.1","date":"2014-11-20T23:47:06.620Z"},{"number":"1.4.0","date":"2014-12-17T05:42:06.438Z"},{"number":"1.4.1","date":"2014-12-27T21:53:34.306Z"},{"number":"1.4.2","date":"2015-01-02T16:23:24.122Z"},{"number":"1.5.0","date":"2015-01-20T15:40:38.206Z"},{"number":"1.5.1","date":"2015-01-20T16:45:26.014Z"},{"number":"1.6.0","date":"2015-04-26T17:39:18.537Z"},{"number":"1.6.1","date":"2015-05-01T15:06:40.796Z"},{"number":"1.6.2","date":"2015-05-03T19:03:59.346Z"},{"number":"1.6.3","date":"2015-05-05T17:11:35.616Z"},{"number":"1.6.4","date":"2015-05-18T12:49:42.863Z"},{"number":"1.7.0","date":"2015-09-08T16:48:45.881Z"},{"number":"1.8.0","date":"2015-11-17T17:05:20.584Z"},{"number":"1.8.1","date":"2016-02-25T16:56:54.477Z"},{"number":"1.8.2","date":"2016-04-27T19:18:48.875Z"},{"number":"1.8.3","date":"2016-06-21T13:54:43.048Z"},{"number":"1.8.4","date":"2016-07-14T16:17:11.580Z"},{"number":"1.8.5","date":"2016-08-03T15:30:37.964Z"},{"number":"1.8.6","date":"2017-04-05T14:44:39.973Z"},{"number":"1.8.7","date":"2017-04-10T14:21:46.619Z"}],"readme":"# node-libpq\n\n[![Build Status](https://travis-ci.org/brianc/node-libpq.svg?branch=master)](https://travis-ci.org/brianc/node-libpq)\n\nNode native bindings to the PostgreSQL [libpq](http://www.postgresql.org/docs/9.3/interactive/libpq.html) C client library.  This module attempts to mirror _as closely as possible_ the C API provided by libpq and provides the absolute minimum level of abstraction.  It is intended to be extremely low level and allow you the same access as you would have to libpq directly from C, except in node.js! The obvious trade-off for being \"close to the metal\" is having to use a very \"c style\" API in JavaScript.\n\nIf you have a good understanding of libpq or used it before hopefully the methods within node-libpq will be familiar; otherwise, you should probably spend some time reading [the official libpq C library documentation](http://www.postgresql.org/docs/9.3/interactive/libpq.html) to become a bit familiar. Referencing the libpq documentation directly should also provide you with more insight into the methods here. I will do my best to explain any differences from the C code for each method.\n\nI am also building some [higher level abstractions](https://github.com/brianc/node-pg-native) to eventually replace the `pg.native` portion of node-postgres.  They should help as reference material.\n\nThis module relies heavily on [nan](https://github.com/rvagg/nan) and wouldn't really be possible without it. Mucho thanks to the node-nan team.\n\n## install\n\nYou need libpq installed & the `pg_config` program should be in your path.  You also need [node-gyp](https://github.com/TooTallNate/node-gyp) installed.\n\n```bash\n$ npm install libpq\n```\n\n## use\n\n```js\nvar Libpq = require('libpq');\nvar pq = new Libpq();\n```\n\n## API\n\n### connection functions\n\nLibpq provides a few different connection functions, some of which are \"not preferred\" anymore.  I've opted to simplify this interface a bit into a single __async__ and single __sync__ connnection function.  The function accepts an  connection string formatted as outlined [in this documentation in section 31.1.1](http://www.postgresql.org/docs/9.3/static/libpq-connect.html). If the parameters are not supplied, libpq will automatically use environment variables, a pgpass file, and other options.  Consult the libpq documentation for a better rundown of all the ways it tries to determine your connection parameters.\n\nI personally __always__ connect with environment variables and skip supplying the optional `connectionParams`.  Easier, more 12 factor app-ish, and you never risk hard coding any passwords. YMMV. :smile:\n\n##### `pq.connect([connectionParams:string], callback:function)`\n\nAsyncronously attempts to connect to the postgres server.\n\n- `connectionParams` is an optional string\n- `callback` is mandatory. It is called when the connection has successfully been established.\n\n__async__ Connects to a PostgreSQL backend server process.\n\nThis function actually calls the `PQconnectdb` blocking connection method in a background thread within node's internal thread-pool. There is a way to do non-blocking network I/O for some of the connecting with libpq directly, but it still blocks when your local file system looking for config files, SSL certificates, .pgpass file, and doing possible dns resolution.  Because of this, the best way to get _fully_ non-blocking is to juse use `libuv_queue_work` and let node do it's magic and so that's what I do.  This function _does not block_.\n\n##### `pq.connectSync([connectionParams:string])`\n\nAttempts to connect to a PostgreSQL server. __BLOCKS__ until it either succeedes, or fails.  If it fails it will throw an exception.\n\n- `connectionParams` is an optional string\n\n##### `pq.finish()`\n\nDisconnects from the backend and cleans up all memory used by the libpq connection.\n\n### Connection Status Functions\n\n##### `pq.errorMessage():string`\n\nRetrieves the last error message from the connection.  This is intended to be used after most functions which return an error code to get more detailed error information about the connection.  You can also check this _before_ issuing queries to see if your connection has been lost.\n\n##### `pq.socket():int`\n\nReturns an int representing the file descriptor for the socket used internally by the connection\n\n### Sync Command Execution Functions\n\n##### `pq.exec(commandText:string)`\n\n__sync__ sends a command to the backend and blocks until a result is received.\n\n- `commandText` is a required string of the query.\n\n##### `pq.execParams(commandText:string, parameters:array[string])`\n\n__snyc__ sends a command and parameters to the backend and blocks until a result is received.\n\n- `commandText` is a required string of the query.\n- `parameters` is a required array of string values corresponding to each parameter in the commandText.\n\n##### `pq.prepare(statementName:string, commandText:string, nParams:int)`\n__sync__ sends a named statement to the server to be prepared for later execution. blocks until a result from the prepare operation is received.\n\n- `statementName` is a required string of name of the statement to prepare.\n- `commandText` is a required string of the query.\n- `nParams` is a count of the number of parameters in the commandText.\n\n##### `pq.execPrepared(statementName:string, parameters:array[string])`\n__sync__ sends a command to the server to execute a previously prepared statement. blocks until the results are returned.\n\n- `statementName` is a required string of the name of the prepared statement.\n- `parameters` are the parameters to pass to the prepared statement.\n\n### Async Command Execution Functions\n\nIn libpq the async command execution functions _only_ dispatch a request to the backend to run a query.  They do not start result fetching on their own.  Because libpq is a C api there is a somewhat complicated \"dance\" to retrieve the result information in a non-blocking way.  node-libpq attempts to do as little as possible to abstract over this; therefore, the following functions are only part of the story.  For a complete tutorial on how to dispatch & retrieve results from libpq in an async way you can [view the complete approach here](https://github.com/brianc/node-pg-native/blob/master/index.js#L105)\n\n##### `pq.sendQuery(commandText:string):boolean`\n__async__ sends a query to the server to be processed.\n\n- `commandText` is a required string containing the query text.\n\nReturns `true` if the command was sent succesfully or `false` if it failed to send.\n\n##### `pq.sendQueryParams(commandText:string, parameters:array[string]):boolean`\n__async__ sends a query and to the server to be processed.\n\n- `commandText` is a required string containing the query text.\n- `parameters` is an array of parameters as strings used in the parameterized query.\n\nReturns `true` if the command was sent succesfully or `false` if it failed to send.\n\n##### `pq.sendPrepare(statementName:string, commandText:string, nParams:int):boolean`\n__async__ sends a request to the backend to prepare a named statement with the given name.\n\n- `statementName` is a required string of name of the statement to prepare.\n- `commandText` is a required string of the query.\n- `nParams` is a count of the number of parameters in the commandText.\n\nReturns `true` if the command was sent succesfully or `false` if it failed to send.\n\n##### `pq.sendQueryPrepared(statementName:string, parameters:array[string]):boolean`\n__async__ sends a request to execute a previously prepared statement.\n\n- `statementName` is a required string of the name of the prepared statement.\n- `parameters` are the parameters to pass to the prepared statement.\n\n##### `pq.getResult():boolean`\nParses received data from the server into a `PGresult` struct and sets a pointer internally to the connection object to this result.  __warning__: this function will __block__ if libpq is waiting on async results to be returned from the server.  Call `pq.isBusy()` to determine if this command will block.\n\nReturns `true` if libpq was able to read buffered data & parse a result object.  Returns `false` if there are no results waiting to be parsed.  Generally doing async style queries you'll call this repeadedly until it returns false and then use the result accessor methods to pull results out of the current result set.\n\n### Result accessor functions\n\nAfter a command is run in either sync or async mode & the results have been received, node-libpq stores the results internally and provides you access to the results via the standard libpq methods.  The difference here is libpq will return a pointer to a PGresult structure which you access via libpq functions, but node-libpq stores the most recent result within itself and passes the opaque PGresult structure to the libpq methods.  This is to avoid passing around a whole bunch of pointers to unmanaged memory and keeps the burden of properly allocating and freeing memory within node-libpq.\n\n##### `pq.resultStatus():string`\n\nReturns either `PGRES_COMMAND_OK` or `PGRES_FATAL_ERROR` depending on the status of the last executed command.\n\n##### `pq.resultErrorMessage():string`\n\nRetrieves the error message from the result.  This will return `null` if the result does not have an error.\n\n##### `pq.resultErrorFields():object`\n\nRetrieves detailed error information from the current result object. Very similar to `PQresultErrorField()` except instead of passing a fieldCode and retrieving a single field, retrieves all fields from the error at once on a single object.  The object returned is a simple hash, _not_ an instance of an error object.  Example: if you wanted to access `PG_DIAG_MESSAGE_DETAIL` you would do the following:\n\n```js\nconsole.log(pq.errorFields().messageDetail)\n```\n\n##### `pq.clear()`\n\nManually frees the memory associated with a `PGresult` pointer.  Generally this is called for you, but if you absolutely want to free the pointer yourself, you can.\n\n##### `pq.ntuples():int`\n\nRetrieve the number of tuples (rows) from the result.\n\n##### `pq.nfields():int`\n\nRetrieve the number of fields (columns) from the result.\n\n##### `pq.fname(fieldNumber:int):string`\n\nRetrieve the name of the field (column) at the given offset. Offset starts at 0.\n\n##### `pq.ftype(fieldNumber:int):int`\n\nRetrieve the `Oid` of the field (column) at the given offset. Offset starts at 0.\n\n##### `pq.getvalue(tupleNumber:int, fieldNumber:int):string`\n\nRetrieve the text value at a given tuple (row) and field (column) offset. Both offsets start at 0.  A null value is returned as the empty string `''`.\n\n##### `pq.getisnull(tupleNumber:int, fieldNumber:int):boolean`\n\nReturns `true` if the value at the given offsets is actually `null`.  Otherwise returns `false`.  This is because `pq.getvalue()` returns an empty string for both an actual empty string and for a `null` value.  Weird, huh?\n\n##### `pq.cmdStatus():string`\n\nReturns the status string associated with a result.  Something akin to `INSERT 3 0` if you inserted 3 rows.\n\n##### `pq.cmdTuples():string`\n\nReturns the number of tuples (rows) affected by the command. Even though this is a number, it is returned as a string to mirror libpq's behavior.\n\n### Async socket access\n\nThese functions don't have a direct match within libpq.  They exist to allow you to monitor the readability or writability of the libpq socket based on your platforms equivilant to `select()`.  This allows you to perform async I/O completely from JavaScript.\n\n##### `pq.startReader()`\n\nThis uses libuv to start a read watcher on the socket open to the backend.  As soon as this socket becomes readable the `pq` instance will emit a `readable` event.  It is up to you to call `pq.consumeInput()` one or more times to clear this read notification or it will continue to emit read events over and over and over.  The exact flow is outlined [here] under the documentation for `PQisBusy`.\n\n##### `pq.stopReader()`\n\nTells libuv to stop the read watcher on the connection socket.\n\n##### `pq.writable(callback:function)`\n\nCall this to make sure the socket has flushed all data to the operating system.  Once the socket is writable, your callback will be called.  Usefully when using `PQsetNonBlocking` and `PQflush` for async writing.\n\n### More async methods\n\nThese are all documented in detail within the [libpq documentation](http://www.postgresql.org/docs/9.3/static/libpq-async.html) and function almost identically.\n\n##### `pq.consumeInput():boolean`\n\nReads waiting data from the socket.  If the socket is not readable and you call this it will __block__ so be careful and only call it within the `readable` callback for the most part.\n\nReturns `true` if data was read.  Returns `false` if there was an error.  You can access error details with `pq.errorMessage()`.\n\n##### `pq.isBusy():boolean`\n\nReturns `true` if calling `pq.consumeInput()` would block waiting for more data.  Returns `false` if all data has been read from the socket.  Once this returns `false` it is safe to call `pq.getResult()`\n\n##### `pq.setNonBlocking(nonBlocking:boolean):boolean`\n\nToggle the socket blocking on _write_.  Returns `true` if the socket's state was succesfully toggled.  Returns `false` if there was an error.\n\n- `nonBlocking` is `true` to set the connection to use non-blocking writes. `false` to use blocking writes.\n\n##### `pq.flush():int`\n\nFlushes buffered data to the socket.  Returns `1` if socket is not write-ready at which case you should call `pq.writable` with a callback and wait for the socket to be writable and then call `pq.flush()` again.  Returns `0` if all data was flushed.  Returns `-1` if there was an error.\n\n### listen/notify\n\n##### `pq.notifies():object`\n\nChecks for `NOTIFY` messages that have come in.  If any have been received they will be in the following format:\n\n```js\nvar msg = {\n  relname: 'name of channel',\n  extra: 'message passed to notify command',\n  be_pid: 130\n}\n```\n\n### COPY IN/OUT\n\n##### `pq.putCopyData(buffer:Buffer):int`\n\nAfter issuing a successful command like `COPY table FROM stdin` you can start putting buffers directly into the databse with this function.\n\n- `buffer` Is a required node buffer of text data such as `Buffer('column1\\tcolumn2\\n')`\n\nReturns `1` if sent succesfully. Returns `0` if the command would block (only if you have called `pq.setNonBlocking(true)`). Returns `-1` if there was an error sending the command.\n\n##### `pq.putCopyEnd([errorMessage:string])`\n\nSignals the backed your copy procedure is complete.  If you pass `errorMessage` it will be sent to the backend and effectively cancel the copy operation.\n\n- `errorMessage` is an _optional_ string you can pass to cancel the copy operation.\n\nReturns `1` if sent succesfully. Returns `0` if the command would block (only if you have called `pq.setNonBlocking(true)`). Returns `-1` if there was an error sending the command.\n\n\n##### `pq.getCopyData(async:boolean):Buffer or int`\n\nAfter issuing a successfuly command like `COPY table TO stdout` gets copy data from the connection.\n\nReturns a node buffer if there is data available.\n\nReturns `0` if the copy is still in progress (only if you have called `pq.setNonBlocking(true)`). Returns `-1` if the copy is completed. Returns `-2` if there was an error.\n\n- `async` is a boolean. Pass `false` to __block__ waiting for data from the backend. _defaults to `false`_\n\n### Misc Functions\n\n##### `pq.escapeLiteral(input:string):string`\n\nExact copy of the `PQescapeLiteral` function within libpq.  Requires an established connection but does not perform any I/O.\n\n##### `pq.escapeIdentifier(input:string):string`\n\nExact copy of the `PQescapeIdentifier` function within libpq.  Requires an established connection but does not perform any I/O.\n\n##### `pq.cancel():true -or- string`\n\nIssues a request to cancel the currently executing query _on this instance of libpq_.  Returns `true` if the cancel request was sent.  Returns a `string` error message if the cancel request failed for any reason. The string will contain the error message provided by libpq.\n\n##### `pq.serverVersion():number`\n\nReturns the version of the connected PostgreSQL backend server as a number.\n\n## testing\n\n```sh\n$ npm test\n```\n\nTo run the tests you need a PostgreSQL backend reachable by typing `psql` with no connection parameters in your terminal. The tests use [environment variables](http://www.postgresql.org/docs/9.3/static/libpq-envars.html) to connect to the backend. \n\nAn example of supplying a specific host the tests:\n\n```sh\n$ PGHOST=blabla.mydatabasehost.com npm test\n```\n\n\n## license\n\nThe MIT License (MIT)\n\nCopyright (c) 2014 Brian M. Carlson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n","starsCount":1,"created":"2014-09-01T18:09:06.686Z","modified":"2017-04-10T14:21:46.619Z","lastPublisher":{"name":"brianc","email":"brian.m.carlson@gmail.com"},"owners":[{"name":"brianc","email":"brian.m.carlson@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"libpq","_nodeVersion":"6.5.0","_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/libpq-1.8.7.tgz_1491834105915_0.43349113198928535"},"_npmUser":{"name":"brianc","email":"brian.m.carlson@gmail.com"},"_npmVersion":"3.10.3","_rev":"3-a017343ff3b06f9e4808ac3042a16874","_shasum":"c2deb121e28f7f84bd3b2451afff68b6663e74f9","author":{"name":"Brian M. Carlson"},"bugs":{"url":"https://github.com/brianc/node-libpq/issues"},"directories":{},"dist-tags":{"latest":"1.8.7"},"dist":{"shasum":"c2deb121e28f7f84bd3b2451afff68b6663e74f9","tarball":"https://registry.npmjs.org/libpq/-/libpq-1.8.7.tgz"},"maintainers":[{"name":"brianc","email":"brian.m.carlson@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-04-10T14:21:46.619Z","created":"2014-09-01T18:09:06.686Z","0.2.0":"2014-09-01T18:09:06.686Z","0.2.1":"2014-09-01T18:23:31.513Z","0.2.2":"2014-09-02T13:30:29.200Z","0.2.3":"2014-09-02T13:33:50.924Z","0.2.4":"2014-09-02T13:47:49.899Z","0.2.5":"2014-09-03T03:03:45.813Z","0.3.0":"2014-09-03T03:28:02.369Z","0.4.0":"2014-09-04T23:32:17.736Z","0.4.1":"2014-09-04T23:36:41.808Z","0.5.0":"2014-09-09T09:47:31.250Z","0.5.1":"2014-09-14T01:56:19.894Z","0.5.2":"2014-09-14T20:41:37.045Z","0.5.3":"2014-09-14T20:56:46.832Z","1.0.0":"2014-09-25T16:19:34.717Z","1.0.1":"2014-10-07T04:29:26.301Z","1.1.0":"2014-10-09T19:32:14.243Z","1.2.0":"2014-10-16T03:17:53.467Z","1.2.1":"2014-10-18T03:04:57.094Z","1.3.0":"2014-11-18T19:31:34.826Z","1.3.1":"2014-11-20T23:47:06.620Z","1.4.0":"2014-12-17T05:42:06.438Z","1.4.1":"2014-12-27T21:53:34.306Z","1.4.2":"2015-01-02T16:23:24.122Z","1.5.0":"2015-01-20T15:40:38.206Z","1.5.1":"2015-01-20T16:45:26.014Z","1.6.0":"2015-04-26T17:39:18.537Z","1.6.1":"2015-05-01T15:06:40.796Z","1.6.2":"2015-05-03T19:03:59.346Z","1.6.3":"2015-05-05T17:11:35.616Z","1.6.4":"2015-05-18T12:49:42.863Z","1.7.0":"2015-09-08T16:48:45.881Z","1.8.0":"2015-11-17T17:05:20.584Z","1.8.1":"2016-02-25T16:56:54.477Z","1.8.2":"2016-04-27T19:18:48.875Z","1.8.3":"2016-06-21T13:54:43.048Z","1.8.4":"2016-07-14T16:17:11.580Z","1.8.5":"2016-08-03T15:30:37.964Z","1.8.6":"2017-04-05T14:44:39.973Z","1.8.7":"2017-04-10T14:21:46.619Z"},"users":{"i-erokhin":true}}}