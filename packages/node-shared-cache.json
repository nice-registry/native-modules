{"name":"node-shared-cache","version":"1.6.2","description":"Interprocess shared memory cache for Node.JS","main":"index.js","dependencies":{"nan":"~2.4.0"},"devDependencies":{},"scripts":{"test":"node test/test","install":"node-gyp rebuild"},"repository":"https://github.com/kyriosli/node-shared-cache","keywords":["Node.JS","LRU","Cache","Shared"],"license":"ISC","gypfile":true,"homepage":"https://github.com/kyriosli/node-shared-cache","gitHead":"8b056028d808cd14b15cf024655c660726b1ac47","versions":[{"number":"1.0.0","date":"2015-06-08T08:07:21.938Z"},{"number":"1.0.1","date":"2015-06-17T08:16:34.417Z"},{"number":"1.1.0","date":"2015-06-18T11:12:56.320Z"},{"number":"1.2.0","date":"2016-03-15T08:04:07.375Z"},{"number":"1.3.0","date":"2016-03-17T02:24:19.902Z"},{"number":"1.4.0","date":"2016-03-17T02:26:33.224Z"},{"number":"1.5.0","date":"2016-11-18T01:58:37.031Z"},{"number":"1.6.0","date":"2016-11-18T02:04:10.679Z"},{"number":"1.6.2","date":"2016-11-21T09:23:58.369Z"}],"readme":"## node-shared-cache\r\n\r\nInterprocess shared memory cache for Node.JS\r\n\r\nIt supports auto memory-management and fast object serialization. It uses a hashmap and LRU cache internally to maintain its contents.\r\n\r\n## Updates\r\n\r\n  - 1.6.2\r\n    - Add `exchange` method which can be used as atomic lock as well as `increase`\r\n    - Add `fastGet` method which does not touch the LRU sequence\r\n  - 1.6.1 Update `nan` requirement to 2.4.0 \r\n  - 1.6.0 Add support for Win32 ([#7](https://github.com/kyriosli/node-shared-cache/issues/7)). Thanks to [@matthias-christen](https://github.com/matthias-christen) [@dancrumb](https://github.com/dancrumb)\r\n\r\n## Install\r\n\r\nYou can install it with npm. Just type `npm i node-shared-cache` will do it.\r\n\r\nYou can also download and install it manually, but you need to install Node.JS and `node-gyp` first.\r\n\r\n    git clone https://github.com/kyriosli/node-shared-cache.git\r\n    cd node-shared-cache\r\n    node-gyp rebuild\r\n\r\n\r\n## Terms of Use\r\n\r\nThis software (source code and its binary builds) is absolutely copy free and any download or modification is permitted except for unprohibited\r\ncommercial use.\r\n\r\nBut due to the complexity of this software, any bugs or runtime exceptions could happen when programs which includeed it run into an unexpected\r\nsituation, which in most cases should be harmless but also have the chance to cause:\r\n\r\n  - program crash\r\n  - system down\r\n  - software damage\r\n  - hardware damage\r\n\r\nwhich would lead to data corruption or even economic losses.\r\n\r\nSo when you are using this software, DO\r\n\r\n  - check the data\r\n  - double check the data\r\n  - avoid undefined behavior to happen\r\n\r\nTo avoid data crupption, we use a read-write lock to ensure that data modification is exclusive. But when a program is writting data when something\r\nbad, for example, a SIGKILL, happens that crashes the program before the write operation is complete and lock is released, other processes may not be\r\nable to enter the exclusive region again. I do not use an auto recovery lock such as `flock`, which will automatically release when process exits, just\r\nin case that wrong data is returned when performing a reading operation, or even, causing a segment fault.\r\n\r\n## usage\r\n\r\n```js\r\n// create cache instance\r\nvar cache = require('node-shared-cache');\r\nvar obj = new cache.Cache(\"test\", 557056);\r\n\r\n// setting property\r\nobj.foo = \"bar\";\r\n\r\n// getting property\r\nconsole.log(obj.foo);\r\n\r\n// enumerating properties\r\nfor(var k in obj);\r\nObject.keys(obj);\r\n\r\n// deleting property\r\ndelete obj.foo;\r\n\r\n// writing objects is also supported\r\nobj.foo = {'foo': 'bar'};\r\n// but original object reference is not saved\r\nvar test = obj.foo = {'foo': 'bar'};\r\ntest === obj.foo; // false\r\n\r\n// circular reference is supported.\r\ntest.self = test;\r\nobj.foo = test;\r\n// and saved result is also circular\r\ntest = obj.foo;\r\ntest.self === test; // true\r\n\r\n// increase a key\r\ncache.increase(obj, \"foo\");\r\ncache.increase(obj, \"foo\", 3);\r\n\r\n// exchange current key with new value, the old value is returned\r\ncache.set(obj, \"foo\", 123);\r\ncache.exchange(obj, \"foo\", 456); // 123\r\nobj.foo; // 456\r\n\r\n// release memory region\r\ncache.release(\"test\");\r\n\r\n// dump current cache\r\nvar values = cache.dump(obj);\r\n// dump current cache by key prefix\r\nvalues = cache.dump(obj, \"foo_\");\r\n```\r\n\r\n### class Cache\r\n\r\n#### constructor\r\n\r\n```js\r\n    function Cache(name, size, optional block_size)\r\n```\r\n\r\n`name` represents a file name in shared memory, `size` represents memory size in bytes to be used. `block_size` denotes the size of the unit of the memory block.\r\n\r\n`block_size` can be any of:\r\n\r\n  - cache.SIZE_64 (6): 64 bytes (default)\r\n  - cache.SIZE_128 (7): 128 bytes\r\n  - cache.SIZE_256 (8): 256 bytes\r\n  - cache.SIZE_512 (9): 512 bytes\r\n  - cache.SIZE_1K (10): 1KB\r\n  - cache.SIZE_2K (11): 2KB\r\n  - ...\r\n  - cache.SIZE_16K (14): 16KB\r\n\r\nNote that:\r\n\r\n  - `size` should not be smaller than 524288 (512KB)\r\n  - block count is 32-aligned\r\n  - key length should not be greater than `(block_size - 32) / 2`, for example, when block size is 64 bytes, maximum key length is 16 chars.\r\n  - key length should also not be greater than 256\r\n\r\nSo when block_size is set to default, the maximum memory size that can be used is 128M, and the maximum keys that can be stored is 2088960 (8192 blocks is used for data structure)\r\n\r\n#### property setter\r\n\r\n```js\r\nset(name, value)\r\n```\r\n\r\n### exported methods\r\n\r\n#### release\r\n\r\n```js\r\nfunction release(name)\r\n```\r\n\r\nThe shared memory named `name` will be released. Throws error if shared memory is not found. Note that this method simply calls `shm_unlink` and does not check whether the memory region is really initiated by this module.\r\n\r\nDon't call this method when the cache is still used by some process, may cause memory leak\r\n\r\n#### clear\r\n\r\n    function clear(instance)\r\n\r\nClears a cache\r\n\r\n#### increase\r\n\r\n```js\r\nfunction increase(instance, name, optional increase_by)\r\n```\r\n\r\nIncrease a key in the cache by an integer (default to 1). If the key is absent, or not an integer, the key will be set to `increase_by`.\r\n\r\n#### exchange\r\n\r\n```js\r\nfunction exchange(instance, name, new_value)\r\n```\r\n\r\nUpdate a key in the cache with a new value, the old value is returned.\r\n\r\n#### fastGet\r\n\r\n```js\r\nfunction fastGet(instance, name)\r\n```\r\n\r\nGet the value of a key without touching the LRU sequence. This method is usually faster than `instance[name]` because it uses\r\ndifferent lock mechanism to ensure shared reading across processes.\r\n\r\n#### dump\r\n\r\n```js\r\n    function dump(instance, optional prefix)\r\n```\r\n\r\nDump keys and values \r\n\r\n## Performance\r\n\r\nTests are run under a virtual machine with one processor: \r\n```sh\r\n$ node -v\r\nv0.12.4\r\n$ cat /proc/cpuinfo\r\nprocessor   : 0\r\nvendor_id   : GenuineIntel\r\ncpu family  : 6\r\nmodel       : 45\r\nmodel name  : Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz\r\nstepping    : 7\r\nmicrocode   : 0x70d\r\ncpu MHz     : 2300.090\r\ncache size  : 15360 KB    \r\n...\r\n```\r\n\r\nBlock size is set to 64 and 1MB of memory is used.\r\n\r\n### Setting property\r\n\r\nWhen setting property 100w times:\r\n\r\n```js\r\n// test plain object\r\nvar plain = {};\r\nconsole.time('plain obj');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    plain['test' + (i & 127)] = i;\r\n}\r\nconsole.timeEnd('plain obj');\r\n\r\n// test shared cache\r\nvar obj = new binding.Cache(\"test\", 1048576);\r\nconsole.time('shared cache');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    obj['test' + (i & 127)] = i;\r\n}\r\nconsole.timeEnd('shared cache');\r\n```\r\n\r\nThe result is:\r\n\r\n    plain obj: 227ms\r\n    shared cache: 492ms (1:2.17)\r\n\r\n### Getting property\r\n\r\nWhen trying to read existing key:\r\n\r\n```js\r\nconsole.time('read plain obj');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    plain['test' + (i & 127)];\r\n}\r\nconsole.timeEnd('read plain obj');\r\n\r\nconsole.time('read shared cache');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    obj['test' + (i & 127)];\r\n}\r\nconsole.timeEnd('read shared cache');\r\n```\r\n\r\nThe result is:\r\n\r\n    read plain obj: 138ms\r\n    read shared cache: 524ms (1:3.80)\r\n\r\nWhen trying to read keys that are not existed:\r\n\r\n```js\r\nconsole.time('read plain obj with key absent');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    plain['oops' + (i & 127)];\r\n}\r\nconsole.timeEnd('read plain obj with key absent');\r\n\r\nconsole.time('read shared cache with key absent');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    obj['oops' + (i & 127)];\r\n}\r\nconsole.timeEnd('read shared cache with key absent');\r\n```\r\n\r\nThe result is:\r\n\r\n    read plain obj with key absent: 265ms\r\n    read shared cache with key absent: 595ms (1:2.24)\r\n\r\n### Enumerating properties\r\n\r\nWhen enumerating all the keys:\r\n\r\n```js\r\nconsole.time('enumerate plain obj');\r\nfor(var i = 0; i < 100000; i++) {\r\n    Object.keys(plain);\r\n}\r\nconsole.timeEnd('enumerate plain obj');\r\n\r\nconsole.time('enumerate shared cache');\r\nfor(var i = 0; i < 100000; i++) {\r\n    Object.keys(obj);\r\n}\r\nconsole.timeEnd('enumerate shared cache');\r\n```\r\n\r\nThe result is:\r\n\r\n    enumerate plain obj: 1201ms\r\n    enumerate shared cache: 4262ms (1:3.55)\r\n\r\nWarn: Because the shared memory can be modified at any time even the current Node.js\r\nprocess is running, depending on keys enumeration result to determine whether a key\r\nis cached is unwise. On the other hand, it takes so long a time to build strings from\r\nmemory slice, as well as putting them into an array, so DO NOT USE IT unless you know\r\nthat what you are doing.\r\n\r\n### Object serialization\r\n\r\nWe choose a c-style binary serialization method rather than `JSON.stringify`, in two\r\nconcepts:\r\n\r\n  - Performance serializing and unserializing\r\n  - Support for circular reference\r\n\r\nTests code list:\r\n\r\n```js\r\nvar input = {env: process.env, arr: [process.env, process.env]};\r\nconsole.time('JSON.stringify');\r\nfor(var i = 0; i < 100000; i++) {\r\n    JSON.stringify(input);\r\n}\r\nconsole.timeEnd('JSON.stringify');\r\n\r\nconsole.time('binary serialization');\r\nfor(var i = 0; i < 100000; i++) {\r\n    obj.test = input;\r\n}\r\nconsole.timeEnd('binary serialization');\r\n\r\n// test object unserialization\r\ninput = JSON.stringify(input);\r\nconsole.time('JSON.parse');\r\nfor(var i = 0; i < 100000; i++) {\r\n    JSON.parse(input);\r\n}\r\nconsole.timeEnd('JSON.parse');\r\n\r\nconsole.time('binary unserialization');\r\nfor(var i = 0; i < 100000; i++) {\r\n    obj.test;\r\n}\r\nconsole.timeEnd('binary unserialization');\r\n```\r\n\r\nThe result is:\r\n\r\n    JSON.stringify: 5876ms\r\n    binary serialization: 2523ms (2.33:1)\r\n    JSON.parse: 2042ms\r\n    binary unserialization: 2098ms (1:1.03)\r\n\r\n\r\n## TODO\r\n","starsCount":2,"created":"2015-06-08T08:07:21.938Z","modified":"2017-03-13T01:30:29.428Z","lastPublisher":{"name":"kyriosli","email":"lz3259@gmail.com"},"owners":[{"name":"kyriosli","email":"lz3259@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"node-shared-cache","_nodeVersion":"7.0.0","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/node-shared-cache-1.6.2.tgz_1479720238134_0.21978691313415766"},"_npmUser":{"name":"kyriosli","email":"lz3259@gmail.com"},"_npmVersion":"3.10.8","_rev":"6-fe4da0bd3dd637bd1b8df936cada44ca","_shasum":"03f535962d5ed16f1d00413b28c663b8ce5d70ad","author":{"name":"Kyrios"},"bugs":{"url":"https://github.com/kyriosli/node-shared-cache/issues"},"directories":{},"dist-tags":{"latest":"1.6.2"},"dist":{"shasum":"03f535962d5ed16f1d00413b28c663b8ce5d70ad","tarball":"http://registry.npmjs.org/node-shared-cache/-/node-shared-cache-1.6.2.tgz"},"maintainers":[{"name":"kyriosli","email":"lz3259@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-03-13T01:30:29.428Z","created":"2015-06-08T08:07:21.938Z","1.0.0":"2015-06-08T08:07:21.938Z","1.0.1":"2015-06-17T08:16:34.417Z","1.1.0":"2015-06-18T11:12:56.320Z","1.2.0":"2016-03-15T08:04:07.375Z","1.3.0":"2016-03-17T02:24:19.902Z","1.4.0":"2016-03-17T02:26:33.224Z","1.5.0":"2016-11-18T01:58:37.031Z","1.6.0":"2016-11-18T02:04:10.679Z","1.6.2":"2016-11-21T09:23:58.369Z"},"users":{"satans17":true,"bengi":true}}}